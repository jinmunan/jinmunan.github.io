---
icon: page
order: 3
---
#  锁

#### 悲观锁

认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，**synchronized**关键字和**Lock**的实现类都是悲观锁，适应写操作频繁的场景。

#### 乐观锁

认为自己在使用数据时不会有别的线程修改数据或资源，所以不会添加锁。在 Java 中是通过使用无锁编程来实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据。

如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果这个数据已经被其它线程更新，则根据不同的实现执行不同的操作，比如放弃修改、重试抢锁等等

**判断规则**

- 版本号机制
- CAS 算法

适合读频繁的场景

#### synchronized

**synchronized 使用的三种方式：**

- 作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁。

  调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置。如果设置了，执行线程会将先持有 monitor 锁，然后再执行方法，最后在方法完成 (无论是正常完成还是非正常完成) 时释放 monitor

- 作用于代码块，对括号里配置的对象加锁。

  synchronized 同步代码块实现使用的是 monitorenter 和 monitorexit 指令，来保证持有锁，释放锁。会而外多加一个 monitorexit，为了出现异常时也能释放锁。

- 作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁。

  ACC_STATIC，ACC_SYNCHRONIZED 访问标志区分该方法是否静态同步方法

**为什么任何一个对象都能成为一个锁呢？**

objectMonitor.java -> objectMonitor.cpp -> objectMonitor.hpp

因为 monitor 采用 objectMonitor 实现的

**什么是管程 monitor**

管程 (英语：Monitors, 也称为监视器) 是一种程序结构，结构内的多个子程序 (对象或模块) 形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。对共享变量能够进行的所有操作集中在一个模块中。(把信号量及其操作原语“封装”在一个对象内部) 管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。

```
class Phone {
    public synchronized void sendEmail() {
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("----sendEmail");
    }
    public synchronized void sendSMS() {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("-----sendSMS");
    }
    public void hello() {
        System.out.println("-------he11o");
    }
}
public class JucTest {
    public static void main(String[] args) {
        Phone p1 = new Phone();
        Phone p2 = new Phone();
        new Thread(() -> {
            p1.sendEmail();
        }).start();
        
        new Thread(() -> {
            p1.sendSMS();
        }).start();
    }
}
```

先 Email，后 SMS

一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一 个线程去访间这些 synchronized 方法。

锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的 synchronized 方法。

```
public class JucTest {
    public static void main(String[] args) {
        Phone p1 = new Phone();
        Phone p2 = new Phone();
        new Thread(() -> {
            p1.sendEmail();
        }).start();
        
        new Thread(() -> {
            p1.hello();
        }).start();
    }
}
```

先 hello，后 Email

普通方法与同步锁无关

```
public class JucTest {
    public static void main(String[] args) {
        Phone p1 = new Phone();
        Phone p2 = new Phone();
        new Thread(() -> {
            p1.sendEmail();
        }).start();
        new Thread(() -> {
            p2.sendSMS();
        }).start();
    }
}
```

先 SMS，后 Email

不是同一把锁

```
class Phone {
    public static synchronized void sendEmail() {
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("----sendEmail");
    }
    public static synchronized void sendSMS() {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("-----sendSMS");
    }
    public void hello() {
        System.out.println("-------he11o");
    }
}
public class JucTest {
    public static void main(String[] args) {
        Phone p1 = new Phone();
        Phone p2 = new Phone();
        new Thread(() -> {
            p1.sendEmail();
        }).start();
        new Thread(() -> {
            p1.sendSMS();
        }).start();
    }
}
```

先 Email，后 SMS

```
public class JucTest {
    public static void main(String[] args) {
        Phone p1 = new Phone();
        Phone p2 = new Phone();
        new Thread(() -> {
            p1.sendEmail();
        }).start();
        new Thread(() -> {
            p2.sendSMS();
        }).start();
    }
}
```

先 Email，后 SMS

上述两种情况，加的是类锁

对 F 普通同步方法，锁的是当前实例对象，通常指 this，具体的一部部手机，所有的普通同步方法用的都是同把锁->实例对象本身，对于静态同步方法，锁的是当前类的 Class 对象，如 Phone.class 唯的一 个模板对于同步方法块，锁的是 synchronized 括号内的对象。

```
class Phone {
    public static synchronized void sendEmail() {
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("----sendEmail");
    }
    public synchronized void sendSMS() {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("-----sendSMS");
    }
    public void hello() {
        System.out.println("-------he11o");
    }
}
public class JucTest {
    public static void main(String[] args) {
        Phone p1 = new Phone();
        Phone p2 = new Phone();
        new Thread(() -> {
            p1.sendEmail();
        }).start();
        new Thread(() -> {
            p1.sendSMS();
        }).start();
    }
}
```

先 SMS，后 Email

前者为类锁，后者为对象锁

```
public class JucTest {
    public static void main(String[] args) {
        Phone p1 = new Phone();
        Phone p2 = new Phone();
        new Thread(() -> {
            p1.sendEmail();
        }).start();
        new Thread(() -> {
            p2.sendSMS();
        }).start();
    }
}
```

先 SMS，后 Email

上述两种情况：当个线程试图访问同步代码时 它直先必须得到锁，正常退出或抛出异常时必须释放锁。所有的普通同步方法用的都是同一把锁一实例对象本身，就是 new 出来的具体实例对象本身，本类 this 也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。所有的静态同步方法用的也是同一把锁一类对象本身，就是我们说过的唯一模板 Class 具体实例对象 this 和唯一模板 class, 这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。

#### 公平锁

是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买后来的人在队尾排着，这是公平的。

Lock lock = new ReentrantLock(true)

#### 非公平锁

是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并 发环境下，有可能造成优先级翻转或者饥饿的状态 (某个线程一直得不到锁)。

Lock lock = new ReentrantLock(false)

Lock lock = new ReentrantLock()//默认非公平锁

恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从 CPU 的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用 CPU 的时间片，尽量减少 CPU 空闲状态时间。使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当 1 个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。

非公平锁线程切换开销大。

#### 可重入锁又名递归锁

ReentrantLock 和 synchronized 都是可重入锁

是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁 (前提，锁对象得是同一个对 象)，不会因为之前已经获取过还没释放而阻塞。

**隐式锁（synchronized）**

默认就是可重入锁

在一个 synchronized 修饰的方法或代码块的内部调用本类的其他 synchronized 修饰的方法或代码块时，是永远可以得到锁的

```
public class JucTest {
    public static void main(String[] args) {
        reEntryM1();
    }

    private static void reEntryM1() {
        final Object object = new Object();
        new Thread(() -> {
            synchronized (object){
                System. out . println(Thread.currentThread(). getName()+"\t ---外层调用");
                synchronized (object){
                    System. out . println(Thread. currentThread(). getName()+"\t ----中层调用");
                    synchronized (object){
                        System. out . println( Thread.currentThread(). getName()+"\t ----内层调用");
                    }
                }
            }
        }, "t1"). start();
    }
}
public class JucTest {
    public static void main(String[] args) {
        new Thread(() -> {
            new JucTest().m1();
        }).start();
    }
    public synchronized void m1() {
        //指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入
        System.out.println(Thread.currentThread().getName()+"\t ----come in");
        m2();
        System.out.println(Thread.currentThread().getName()+"\t ----end m1");
    }
    public synchronized void m2(){
        System.out.println(Thread.currentThread().getName()+"\t ----come in");
        m3();
    }
    public synchronized void m3() {
        System.out.println(Thread.currentThread(). getName()+"\t ----come in");
    }

}
```

**显示锁（ReentrantLock）**

显示指定 lock() unlock()

加锁几次就要解锁几次

```
public class JucTest {
    static Lock lock = new ReentrantLock();
    public static void main(String[] args) {
        new Thread(() -> {
            lock.lock();
            try {
                System.out.println(Thread.currentThread().getName()+"\t ----come in外层调用");
                lock.lock();
                try {
                    System.out.println(Thread.currentThread().getName()+"\t ----come in内层调用");
                }finally {
                    lock.unlock();
                }
            }finally {
                lock.unlock();
            }
        }, "t1").start();
    }
}
```

#### 死锁

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。

```
//死锁代码
public class JucTest {
    public static void main(String[] args) {
        final Object objectA = new Object();
        final Object objectB = new Object();
        new Thread(() -> {
            synchronized (objectA) {
                System.out.println(Thread.currentThread().getName() + "\t自己持有A锁，希望获得B锁");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (objectB) {
                    System.out.println(Thread.currentThread().getName() + "\t成功获得B锁");
                }
            }
        }, "A").start();

        new Thread(() -> {
            synchronized (objectB) {
                System.out.println(Thread.currentThread().getName() + "\t自己持有B锁，希望获得A锁");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (objectA) {
                    System.out.println(Thread.currentThread().getName() + "\t成功获得A锁");
                }
            }
        }, "B").start();
    }
}
```

**排查死锁**

1.纯命令

 jps -l

 jstack 进程编号

2.jconsole 图形化界面

### 中断机制

**协商中断**

首先一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，自己来决定自己的命运。所以，Thread.stop，Thread.suspend，Thread.resume 都已经被废弃了。其次在 Java 中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java 提供了一种用于停止线程的协商机制-----中断，也即中断标识协商机制。中断只是一种协作协商机制，Java 没 有给中断增加任何语法，中断的过程完全需要程序员自己实现。若要中断一个线程，你需要手动调用该线程的 interrupt 方法，该方法也仅仅是将线程对象的中断标识设成 true

接着你需要自己写代码不断地检测当前线程的标识位，如果为 true，表示别的线程请求这条线程中断，此时究竟该做什么需要你自己写代码实现。每个线程对象中都有一个中断标识位，用于表示线程是否被中断;该标识位为 true 表示中断，为 false 表示未中断; 通过调用线程对象的 interrupt 方法将该线程的标识位设为 true;可以在别的线程中调用，也可以在自己的线程中调用。

如何实现线程中断停止

```
//1.使用volatile共享变量
public class JucTest {
    static volatile boolean isStop = false;
    public static void main(String[] args) {

        new Thread(() -> {
            while (true) {
                if (isStop) {
                    System.out.println(Thread.currentThread().getName() + "\t" + "thread stop");
                    break;
                }
                System.out.println("t1 -------hello volatile");
            }
        }, "t1").start();

        try {
            TimeUnit.MICROSECONDS.sleep(20);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(() -> {
            isStop = true;
        }, "t2").start();
    }
}

//使用原子类
public class JucTest {
    static AtomicBoolean atomicBoolean = new AtomicBoolean(false);
    public static void main(String[] args) {

        new Thread(() -> {
            while (true) {
                if (atomicBoolean.get()) {
                    System.out.println(Thread.currentThread().getName() + "\t" + "thread stop");
                    break;
                }
                System.out.println("t1 -------hello volatile");
            }
        }, "t1").start();

        try {
            TimeUnit.MICROSECONDS.sleep(20);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(() -> {
            atomicBoolean.set(true);
        }, "t2").start();
    }
}
```

通过线程自带的**中断 API**实列方法实现

- Thread.interrupted()

  返回当前线程的中断状态，测试当前线程是否已被中断 将当前线程的中断状态清零并重新设为 false，清除线程的中断状态

- Thread.interrupt()

  没有返回值

  仅仅是设置线程的中断状态为 true，发起一个协商而不会立刻停止线程

  ①如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以，interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。 ②如果线程处于被阻塞状态 ( 例如处于 sleep，wait，join 等状态)，在别的线程中调用当前线程对象的 interrupt 方法，那么线程将立即退出被阻塞状态，中断状态将被清除，并抛出一个 InterruptedException 异常。（可能程序会无限循环，解决方法须在异常 catch 处再调用 interrupt 方法）

- Thread.isInterrupted()

  判断当前线程是否被中断 (通过检查中断标志位)，不清除线程的中断状态。

```
//通过线程自带的中断API实列方法实现
public class JucTest {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            while (true) {
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println(Thread.currentThread().getName() + "\t" + "thread stop");
                    break;
                }
                System.out.println("t1 -------hello volatile");
            }
        }, "t1");
        t1.start();

        try {
            TimeUnit.MICROSECONDS.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(() -> {
            t1.interrupt();
        }, "t2").start();
    }
}
```
