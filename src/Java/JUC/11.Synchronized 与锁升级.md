---
icon: page
order: 11
---
# Synchronized 与锁升级

##  Synchronized 与锁升级

锁的升级过程

无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

![img](./assets/images_20221020200008.png)

#### 锁指向

偏向锁：MarkWord 存储的是偏向的线程 ID。轻量锁：MarkWord 存储的是指向线程栈中 LockRecord 的指针。重量锁：MarkWord 存储的是指向堆中的 monitor 对象的指针。

#### Monitor

Monitor 可以理解为一种同步工具，也可理解为一种同步机制，常常被描述为一个 Java 对 象。Java 对象是天生的 Monitor，每一个 Java 对象都有成为 Monitor 的潜质，因为在 Java 的设计中，每一个 Java 对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者 Monitor 锁。

#### Mutex Lock

Monitor 是在 jvm 底层实现的，底层代码是 c++。本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所 synchronized 是 Java 语言中的一个重量级操作。

Monitor 与 java 对象以及线程是如何关联？1.如果一个 java 对象被某个线程锁住，则该 java 对象的 Mark Word 字段中 LockWord 指向 monitor 的起始地址 2.Monitor 的 Owner 字段会存放拥有相关联对象锁的线程 id

synchronized 用的锁是存在 Java 对象头里的 Mark Word 中锁升级功能主要依赖 MarkWord 中锁标志位和释放偏向锁标志位

#### 偏向锁

**单线程竞争**

当线程 A 第一次竞争到锁时，通过操作修改 Mark Word 中的偏向线程 ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程将永远不需要进行同步

Hotspot 的作者经过研究发现，大多数情况下：多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一个线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。

偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也即偏向锁在资源没有竞争情况下消除了同步语句，懒的连 CAS 操作都不做了，直接提高程序性能。

**偏向锁的持有**

一个 synchronized 方法被一个线程抢到 了锁时，那这个方法所在的对象就会在其所在的 Mark Word 中将偏向锁修改状态位，同时还会有占用前 54 位来存储线程指针作为标识。若该线程再次访问同一个 synchronized 方法时，该线程只需去对象头的 Mark Word 中去判断一下是否有偏向锁指向本身的 ID，无需再进入 Monitor 去竞争对象了。

偏向锁，不主动释放锁，偏向指向的 ID，如果是当前指向线程 ID，当前线程就会直接进入临界区，无需加锁操作，无需沟通内核。

**偏向锁撤销**

竞争激烈，其他线程 CAS 操作替换线程 ID，原持有偏向锁的线程未执行完毕，则升级轻量级锁

Java15 后废弃

#### 轻量级锁

假如线程 A 已经拿到锁，这时线程 B 又来抢该对象的锁，由于该对象的锁已经被线程 A 拿到，当前该锁已是偏向锁了。而线程 B 在争抢时发现对象头 Mark Word 中的线程 ID 不是线程 B 自己的线程 ID(而是线程 A)，那线程 B 就会进行 CAS 操作希望能获得锁。 **此时线程 B 操作中有两种情况：**

如果锁获取成功，直接替换 Mark Word 中的线程 ID 为 B 自己的 ID(A→B)，重新偏向于其他线程 (即将偏向锁交给其他线程，相当于当前线程"被"释放了锁)，该锁会保持偏向锁状态，A 线程 Over，B 线程上位;

如果锁获取失败，则偏向锁升级为轻量级锁 (设置偏向锁标识为 0 并设置锁标志位为 00)，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程 B 会进入自旋等待获得该轻量级锁。

**轻量级锁的加锁**

JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，官方成为 Displaced Mark Word。若一个线程获得锁时发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 里面。然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。

**轻量级锁的释放**

在释放锁时，当前线程会使用 CAS 操作将 Displaced Mark Word 的内容复制回锁的 Mark Word 里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么 CAS 操作会失败，此时会释放锁并唤醒被阻塞的线程。

#### 重量级锁

自旋达到一定次数（自适应调节次数）时，升级锁。

**自适应：**线程如果自旋成功了，那下次自旋的最大次数会增加，因为 JVM 认为既然上次成功了，那么这一次也很大概率会成功。

Java 中 synchronized 的重量级锁，是基于进入和退出 Monitor 对象实现的。在编译时会将同步块的开始位置插入 monitor enter 指令，在结束位置插入 monitor exit 指令。当线程执行到 monitor enter 指令时，会尝试获取对象所对应的 Monitor 所有权，如果获取到了，即获取到了锁，会在 Monitor 的 owner 中存放当前线程的 id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个 Monitor。

升级为轻量级锁时，JVM 会在当前线程的栈帧中创建个锁记录 (**Lock Record**) 空间，用于存储锁对象的 Mark Word 拷贝，该拷贝中可以包含 identity hash code，所以轻量级锁可以和 identity hash code 共存，哈希码和 GC 年龄自然保存在此，释放锁后会将这些信息写回到对象头。

一个对象计算过 hash code 时无法进入偏向锁，直接进入轻量级锁

#### JIT

JIT 即时编译器会优化无效的锁（**锁消除**）

JIT 会融合一些锁（**锁粗化**）
