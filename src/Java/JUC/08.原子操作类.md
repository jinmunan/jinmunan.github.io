---
icon: page
order: 8
---
# 原子操作类

###  原子类

#### AtomicInteger

CountDownLatch 用法

 countDown()

 await()

#### AtomicIntegerArray

#### 引用类型原子类

AtomicStampedReference，version 号，+1；

AtomicMarkableReference，一次，解决一次性问题（动没动过）

#### 对象的属性修改原子类

使用目的：以一种线程安全的方式操作非线程安全对象内的某些字段

使用要求：更新的对象属性必须使用 public volatile 修饰符。因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater() 创建一个更新器，并且需要设置想要更新的类和属性。

AtomicIntegerFieldUpdater

```
class BankAccount {
    String bankName = "CCB";
    public volatile int money = 0;
//    public void add() {
//        money++;
//    }
    AtomicIntegerFieldUpdater<BankAccount> fieldUpdater =
            AtomicIntegerFieldUpdater.newUpdater(BankAccount.class, "money");
    public void transMoney() {
        fieldUpdater.getAndIncrement(this);
    }
}
public class JucTest {
    public static void main(String[] args) {
        BankAccount bankAccount = new BankAccount();
        CountDownLatch countDownLatch = new CountDownLatch(10);
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < 1000; j++) {
                        bankAccount.transMoney();
                    }
                }finally {
                    countDownLatch.countDown();
                }
            }).start();
        }
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(bankAccount.money);
    }
}
```

AtomicReferenceFieldUpdater

```
class MyCar {
    public volatile Boolean isInit = Boolean.FALSE;
    AtomicReferenceFieldUpdater<MyCar, Boolean> referenceFieldUpdater =
            AtomicReferenceFieldUpdater.newUpdater(MyCar.class, Boolean.class, "isInit");
    public void init() {
        if (referenceFieldUpdater.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {
            System.out.println("success init");
        } else {
            System.out.println("had been inited by other thread");
        }
    }
}
public class JucTest {
    public static void main(String[] args) {
        MyCar myCar = new MyCar();
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                myCar.init();
            }).start();
        }
    }
}
```

#### 原子操作增强类

LongAdder() 只能计算加法，且从 0 开始，比 AtomicLong（底层为 CAS，空轮询造成性能降低，但能保证精度）性能好。

LongAccumulator() 功能更强大

LongAdder 底层原理：

Stripend64 类

transient volatile cell[] cells;

transient volatile long base;

**为什么快：**

LongAdder 的基本思路就是分散热点，将 value 值分散到一个 Cell 数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的 long 值，只要将各个槽中的变量值累加返回。sum() 会将所有 Cell 数组中的 value 和 base 累加作为返回值，核心的思想就是将之前 AtomicLong 个 value 的更新压力分散到多个 value 中去，从而降级更新热点。（sum 不能保证精度，只能保证最终一致性）
