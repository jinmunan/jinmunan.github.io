---
icon: page
order: 6
---

# volatile 与 JMM

###  volatile

满足：可见性，有序性（禁重排）

可见性：保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见。

当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值立即刷新回主内存中，并及时发出通知，大家可以去主内存拿最新版，前面的修改对后面所有线程可见。当读一个 volatile 变量时，JMM 会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量所以 volatile 的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。

怎么保证可见性，有序性：**内存屏障**

#### 内存屏障

内存屏障 (也称内存栅栏，屏障指令等，是一类同步屏障指令，是 CPU 或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作)，避免代码重排序。内存屏障其实就是一种 JVM 指令，Java 内存模型的重排规则会要求 Java 编译器在生成 JVM 指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile 实现了 Java 内存模型中的可见性和有序性 (禁重排)，但 volatile 无法保证原 子性。

**内存屏障之前**的所有写操作都要回写到主内存，

**内存屏障之后**的所有读操作都能获得内存屏障之前的所有写操作的最新结果 (实现了可见性)。

**写屏障**( Store Memory Barrier) ：告诉处理器在写屏障之前将所有存储在缓存 (store bufferes) 中的数据同步到主内存。也就是说当看到 Store 屏障指令，就必须把该指令之前所有写入指令执行完毕才能继续往下执行。在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中。

**读屏障**(Load Memory Barrier)：处理器在读屏障之后的读操作，都在读屏障之后执行。也就是说在 Load 屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。即在读指令之前插入读屏障，让工作内存或 CPU 高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据。

#### 四大屏障

| 屏障类型   | 指令示例                   | 说明                                                         |
| ---------- | -------------------------- | ------------------------------------------------------------ |
| LoadLoad   | Load1; LoadLoad; Load2     | 保证 load1 的读取操作在 load2 及后续读取操作之前执行             |
| StoreStore | Store1; StoreStore; Store2 | 在 store2 及其后的写操作执行前，保证 store1 的写操作已刷新到主内存 |
| LoadStore  | Load1; LoadStore; Store2   | 在 stroe2 及其后的写操作执行前，保证 load1 的读操作已读取结束   |
| StoreLoad  | Store1; StoreLoad; Load2   | 保证 store1 的写操作已刷新到主内存之 后，load2 及 其后的读操作才能执行 |

```
public class JucTest {
    //static boolean flag = true;
    static volatile boolean flag = true;
    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "\t-------come in");
            while (flag);
            System.out.println(Thread.currentThread().getName() + "\t-------out");
        }, "t1");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        flag = false;
        System.out.println("修改完成");
    }
}
```

1.主线程修改了 flag 之后没有将其刷新到主内存，所以 t1 线程看不到。2.主线程将 flag 刷新到了主内存，但是 t1 一直读取的是自己工作内存中 flag 的值，没有去主内存中更新获取 flag 最新的值。

上述原因需要 volatile 解决

**volatile 没有原子性：**

对于 volatile 变量具备可见性，JVM 只是保证从主内存加载到线程工作内存的值是最新的，也仅是数据加载时是最新的。但是多线程环境下，"数据计算"和"数据赋值"操作可能多次出现，若数据在加载之后，若主内存 volatile 修饰变量发生修改之后，线程工作内存中的操作将会作废去读主内存最新值，操作出现写丢失问题。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致。由此可见 volatile 解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须使用加锁同步。

如：i++

**volatile 可以禁重排**

数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。

不存在数据依赖关系，可以重排序。

#### volatile 使用场景

- 单一赋值
- 布尔状态标志，判断业务是否结束
- 开销较低的读，写策略
- DCL 双端锁的发布

```
//单列模式
class SafeDoubleCheckSingleton {
    //private static SafeDoubleCheckSingleton singleton;
    private volatile static SafeDoubleCheckSingleton singleton;//解决下面隐患
    private SafeDoubleCheckSingleton(){}
    //双重锁设计
    public static SafeDoubleCheckSingleton getInstance() {
        if (singleton == null) {
            synchronized (SafeDoubleCheckSingleton.class) {
                if (singleton == null) {
                    //隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取
                    //1.分配内存
                    //2.初始化对象
                    //3.指向内存
                    singleton = new SafeDoubleCheckSingleton();
                }
            }
        }
        return singleton;
    }
}
```
