---
icon: page
order: 10
---
# 非对称加密

① 非对称加密算法又称现代 s 加密算法。

② 非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。

③ 与对称加密算法不同，非对称加密算法需要两个密钥：**公开密钥 (publickey) 和私有密 (privatekey)**

④ 公开密钥和私有密钥是一对

⑤ 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。

⑥ 如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。

⑦ 因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

* 示例
  * 首先生成密钥 s 对，公钥为 (5, 14), 私钥为 (11, 14)
  * 现在 A 希望将原文 2 发送给 B
  * A 使用公钥加密数据。2 的 5 次方 mod 14 = 4 , 将密文 4 发送给 B
  * B 使用私钥解密数据。4 的 11 次方 mod14 = 2, 得到原文 2
* 特点
  * 加密和解密使用不同的密钥
  * **如果使用私钥加密，只能使用公钥解密**
  * **如果使用公钥加密，只能使用私钥解密**
  * 处理数据的速度较慢，因为安全级别高
* 常见算法
  * RSA
  * ECC

## RSA 代码

```java
public class Rsa {
    public static void main(String[] args) throws Exception {
        // 要加密的内容
        String value = "硅谷";
        // 创建密钥对
        String algorithm = "RSA";

        // 生成密钥对并保存在本地文件中
        //generateKeyToFile(algorithm, "a.pub", "a.pri");

        // 获取属性文件的值
        String path = "Rsa.properties";
        Properties properties = new Properties();
        BufferedReader br = new BufferedReader(new FileReader(path));
        properties.load(br);
        String privateKeyStr = properties.getProperty("privateKey");
        String publicKeyStr = properties.getProperty("publicKey");

        // 方式二：读取 a.pri 文件信息
        //String privateKeyRead = FileUtils.readFileToString(new File("a.pri"), StandardCharsets.UTF_8);
        //System.out.println(privateKeyRead);

        // 获得公钥和私钥
        PrivateKey privateKey = getPrivateKey(privateKeyStr, algorithm);
        PublicKey publicKey = getPublicKey(publicKeyStr, algorithm);

        // 私钥加密
        //String s = rsaPrivateKeyEncode(value, algorithm, privateKey);
        //System.out.println(s);
        // 公钥解密
        //System.out.println(rsaPublicKeyDecode(s, algorithm, publicKey));

        // 公钥加密
        String s = rsaPublicKeyEncode(value, algorithm, publicKey);
        System.out.println(s);
        // 私钥解密
        System.out.println(rsaPrivateKeyDecode(s, algorithm, privateKey));
    }

    /**
     * 获得公钥
     *
     * @param publicKey
     * @param algorithm
     * @return
     * @throws Exception
     */
    public static PublicKey getPublicKey(String publicKey, String algorithm) throws Exception {
        // 获取密钥工厂
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        // 构建密钥规范 进行 Base64 解码
        X509EncodedKeySpec spec = new X509EncodedKeySpec(Base64.decodeBase64(publicKey));//X 509 编码密钥规范
        // 生成公钥
        return keyFactory.generatePublic(spec);// 生成公钥
    }

    /**
     * 获得私钥
     *
     * @param privateKey
     * @param algorithm
     * @return
     * @throws Exception
     */
    public static PrivateKey getPrivateKey(String privateKey, String algorithm) throws Exception {
        // 获取密钥工厂
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        // 构建密钥规范 进行 Base64 解码
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(Base64.decodeBase64(privateKey));//PKCS 8 编码密钥规范
        // 生成私钥
        return keyFactory.generatePrivate(spec);// 生成私钥
    }

    /**
     * 生成密钥对并保存在本地文件中
     */
    private static void generateKeyToFile(String algorithm, String val1, String val2) throws Exception {
        KeyPairGenerator instance = KeyPairGenerator.getInstance(algorithm);
        // 生成密钥对
        KeyPair keyPair = instance.generateKeyPair();
        // 生成公钥和私钥
        PrivateKey privateKey = keyPair.getPrivate();
        // 生成公钥
        PublicKey publicKey = keyPair.getPublic();
        // 获取私钥的字节数组
        byte[] privateKeyEncoded = privateKey.getEncoded();
        // 获取公钥的字节数组
        byte[] publicKeyEncoded = publicKey.getEncoded();
        //base64 进行转码
        String privateKeyEncodedString = Base64.encodeBase64String(privateKeyEncoded);
        String publicKeyEncodedString = Base64.encodeBase64String(publicKeyEncoded);
        //FileUtils 文件工具类 commons 导包
        FileUtils.writeStringToFile(new File(val1), publicKeyEncodedString, StandardCharsets.UTF_8);
        FileUtils.writeStringToFile(new File(val2), privateKeyEncodedString, StandardCharsets.UTF_8);
        // 将密钥保存到文件中
        String key = "privateKey=" + privateKeyEncodedString + "\n" + "publicKey=" + publicKeyEncodedString;
        IOUtil.string2File(key, "Rsa.properties");
    }

    /**
     * 私钥加密
     *
     * @param value
     * @param algorithm
     * @param privateKey
     * @throws NoSuchAlgorithmException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     */
    private static String rsaPrivateKeyEncode(String value, String algorithm, PrivateKey privateKey) throws Exception {
        // 创建加密对象
        Cipher cipher = Cipher.getInstance(algorithm);
        // 对加密进行初始化
        cipher.init(Cipher.ENCRYPT_MODE, privateKey);
        // 使用私钥进行加密
        byte[] bytes = cipher.doFinal(value.getBytes(StandardCharsets.UTF_8));
        return Base64.encodeBase64String(bytes);
    }

    /**
     * 公钥解密
     *
     * @param value
     * @param algorithm
     * @param publicKey
     * @throws NoSuchAlgorithmException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     */
    private static String rsaPublicKeyDecode(String value, String algorithm, PublicKey publicKey) throws Exception {
        // 创建加密对象
        Cipher cipher = Cipher.getInstance(algorithm);
        // 对加密进行初始化
        cipher.init(Cipher.DECRYPT_MODE, publicKey);
        // 使用私钥进行加密
        byte[] bytes = cipher.doFinal(Base64.decodeBase64(value));
        return new String(bytes);
    }

    /**
     * 公钥加密
     *
     * @param value
     * @param algorithm
     * @param publicKey
     * @throws NoSuchAlgorithmException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     */
    private static String rsaPublicKeyEncode(String value, String algorithm, PublicKey publicKey) throws Exception {
        // 创建加密对象
        Cipher cipher = Cipher.getInstance(algorithm);
        // 对加密进行初始化
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        // 使用私钥进行加密
        byte[] bytes = cipher.doFinal(value.getBytes(StandardCharsets.UTF_8));
        return Base64.encodeBase64String(bytes);
    }

    /**
     * 私钥解密
     *
     * @param value
     * @param algorithm
     * @param privateKey
     * @throws NoSuchAlgorithmException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     */
    private static String rsaPrivateKeyDecode(String value, String algorithm, PrivateKey privateKey) throws Exception {
        // 创建加密对象
        Cipher cipher = Cipher.getInstance(algorithm);
        // 对加密进行初始化
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        // 使用私钥进行加密
        byte[] bytes = cipher.doFinal(Base64.decodeBase64(value));
        return new String(bytes);
    }
}
```
