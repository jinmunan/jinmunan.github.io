---
icon: page
order: 11
---
# 其他知识点拓展

## ConcurrentSkipListMap 是什么

ConcurrentSkipListMap 是 Java 中的一个实现了 ConcurrentNavigableMap 接口的线程安全的有序映射，它使用跳表（Skip List）数据结构实现。

跳表是一种基于链表的数据结构，类似于平衡树，但实现起来比平衡树更简单，而且对于并发访问的支持也更好。ConcurrentSkipListMap 使用跳表实现，可以支持并发访问，同时也能够保证数据的有序性。

ConcurrentSkipListMap 的特点包括：

- 线程安全：ConcurrentSkipListMap 是线程安全的，多个线程可以同时对它进行读写操作。
- 有序性：ConcurrentSkipListMap 内部维护着一个有序的 key 集合，因此可以根据键值的大小快速地进行查找、插入和删除操作。
- 高效性：ConcurrentSkipListMap 的插入、删除、查找等操作的时间复杂度都是 O(log n)，因此在大多数情况下表现良好。

需要注意的是，虽然 ConcurrentSkipListMap 是线程安全的，但它并不能保证所有操作都是原子的。如果需要对 Map 中的键值对进行复合操作（例如 get and set），还需要使用锁或者其他同步机制来确保原子性操作。

## ConcurrentNavigableMap 是什么

ConcurrentNavigableMap 是 Java 中的一个接口，它继承了 ConcurrentMap 和 NavigableMap 接口。ConcurrentNavigableMap 实现了一个支持高效并发访问的可导航的键值对映射。

与其他 Map 实现不同，ConcurrentNavigableMap 提供了一些额外的方法，例如 subMap()、headMap()、tailMap()，这些方法可以返回给定键的子映射。同时，它还提供了一些方法，如 firstKey() 和 lastKey()，用于检索映射中的第一个和最后一个键。

ConcurrentNavigableMap 的实现类包括 TreeMap 和 ConcurrentSkipListMap。ConcurrentSkipListMap 是一个基于跳表的并发导航映射，而 TreeMap 是一个非并发的导航映射。因此，在需要高效并发访问的情况下，应该优先选择 ConcurrentSkipListMap。

## ConcurrentMap  是什么

ConcurrentMap 是 Java 中的一个接口，它定义了一组操作，用于在多线程环境下同时修改和访问 Map 中的键值对，以实现并发访问。ConcurrentMap 支持高效的并发操作，因此可以用于需要高并发性能的应用程序中。

ConcurrentMap 接口中定义的方法与普通的 Map 接口方法类似，包括 put()、get()、remove() 等等，但是它们都支持并发操作，能够在多线程环境下安全地修改 Map 的内容。

ConcurrentMap 的常用实现类包括 ConcurrentHashMap 和 ConcurrentSkipListMap。其中，ConcurrentHashMap 是基于哈希表实现的线程安全 Map，支持高并发性能，而 ConcurrentSkipListMap 是基于跳表实现的线程安全 Map，它支持有序映射，并且在高并发环境下表现出色。

需要注意的是，虽然 ConcurrentMap 支持并发访问，但它并不能保证所有操作都是原子的。如果需要对 Map 中的键值对进行复合操作（例如 get and set），还需要使用锁或者其他同步机制来确保原子性操作。

## ConcurrentHashMap 是什么

ConcurrentHashMap 是 Java 中的一个线程安全的哈希表实现的 Map，它支持高并发性能。与普通的 HashMap 不同，ConcurrentHashMap 能够在多线程环境下同时修改和访问 Map 中的键值对，而且它能够确保在多线程并发操作时不会出现死锁等问题。

ConcurrentHashMap 的特点包括：

- 线程安全：ConcurrentHashMap 是线程安全的，多个线程可以同时对它进行读写操作。
- 分段锁：ConcurrentHashMap 内部使用了分段锁（Segment），将整个 Map 拆分成多个小的 Segment，每个 Segment 独立维护一个哈希表。不同的线程可以同时访问不同的 Segment，从而提高了并发性能。
- 高效性：ConcurrentHashMap 支持高并发性能，在大多数情况下比同步的 Hashtable 或同步的 HashMap 更加高效。此外，ConcurrentHashMap 也支持批量操作，如批量插入、批量删除等，可以在特定场景下进一步提高性能。

需要注意的是，虽然 ConcurrentHashMap 是线程安全的，但它并不能保证所有操作都是原子的。如果需要对 Map 中的键值对进行复合操作（例如 get and set），还需要使用锁或者其他同步机制来确保原子性操作。

## ConcurrentSkipListMap 的 headMap 作用

ConcurrentSkipListMap 是 Java 并发包中提供的一种高效的并发有序映射表实现，支持高并发访问和操作。headMap 是 ConcurrentSkipListMap 中的一个方法，它的作用是返回此映射表中小于给定键的部分映射，即返回键小于指定键的所有键值对。

具体来说，ConcurrentSkipListMap 的 headMap 方法有多个重载，其中最常用的方法是：

```java
public ConcurrentNavigableMap<K,V> headMap(K toKey)
```

这个方法返回一个视图，它包含此映射表中键小于 toKey 的所有键值对。该视图是基于此映射表的，因此对此视图的更改会反映到原映射表中，反之亦然。

例如，假设我们有一个 ConcurrentSkipListMap，它的键是字符串，值是整数：

```java
ConcurrentSkipListMap<String, Integer> map = new ConcurrentSkipListMap<>();
map.put("apple", 1);
map.put("banana", 2);
map.put("cherry", 3);
map.put("date", 4);
```

然后我们调用 headMap 方法：

```java
ConcurrentNavigableMap<String, Integer> headMap = map.headMap("cherry");
```

headMap 变量将包含键小于 "cherry" 的所有键值对，即键为 "apple" 和 "banana" 的键值对。

headMap 方法对于需要遍历映射表中的部分数据的场景非常有用，因为它可以避免遍历整个映射表。在多线程并发访问时，headMap 方法可以安全地返回并发有序映射表的部分视图，而不会影响其他线程的操作。
