---
icon: page
order: 6
---
# PLSQL 存储函数和过程

## 引言

**ORACLE 提供可以把 PL/SQL 程序存储在数据库中，并可以在任何地方来运行它。这样就叫存储过程或函数**。过程和函数统称为 PL/SQL 子程序，他们是被命名的 PL/SQL 块，均存储在数据库中，并通过输入、输出参数或输入/输出参数与其调用者交换信息。**过程和函数的唯一区别是函数总向调用者返回数据，而过程则不返回数据。**

存储函数：有返回值，创建完成后，通过`select function() from dual;`执行

存储过程：由于没有返回值，创建完成后，不能使用 select 语句，只能使用 pl/sql 块执行

## 存储函数

### 建立内嵌函数

```sql
CREATE [OR REPLACE] FUNCTION function_name
    [ (argment [ { IN | IN OUT }] Type,
    argment [ { IN | OUT | IN OUT } ] Type ]
    [ AUTHID DEFINER | CURRENT_USER ]
    RETURN return_type 
{ IS | AS }
    <类型.变量的说明>
BEGIN
	FUNCTION_body
EXCEPTION
	其它语句
END;
```

**说明**

1) OR REPLACE 为可选。有了它，可以或者创建一个新函数或者替换相同名字的函数，而不会出现冲突
2) 函数名后面是一个可选的参数列表，其中包含 IN、OUT 或 IN OUT 标记。参数之间用逗号隔开。
   - IN 参数标记表示传递给函数的值在该函数执行中不改变

   - OUT 标记表示一个值在函数中进行计算并通过该参数传递给调用语句

   - IN OUT 标记表示传递给函数的值可以变化并传递给调用语句

   - 若省略标记，则参数隐含为 IN

3) 因为函数需要返回一个值，所以 RETURN 包含返回结果的数据类型

### 内嵌函数的调用

函数声明时所定义的参数称为形式参数，应用程序调用时为函数传递的参数称为实际参数。应用程序在调用函数时，可以使用以下三种方法向函数传递参数：

**第一种参数传递格式称为****位置表示法****，格式为：**

argument_value1[,argument_value2 …]



**第二种参数传递格式称为****名称表示法****，格式为：**

argument => parameter [,…]

其中：argument 为形式参数，它**必须与函数定义时所声明的形式参数名称相同**。Parameter 为实际参数。

在这种格式中，形势参数与实际参数成对出现，相互间关系唯一确定，所以参数的顺序可以任意排列。



**第三种参数传递格式称为****混合表示法****：**

即在调用一个函数时，同时使用位置表示法和名称表示法为函数传递参数。采用这种参数传递方法时，

**使用位置表示法所传递的参数必须放在名称表示法所传递的参数前面**。也就是说，无论函数具有多少个参

数，只要其中有一个参数使用名称表示法，其后所有的参数都必须使用名称表示法。





无论采用哪一种参数传递方法，实际参数和形式参数之间的数据传递只有两种方法**：传址法和传值法**。

所谓传址法是指在调用函数时，**将实际参数的地址指针传递给形式参数**，**使形式参数和实际参数指向内存**

**中的同一区域**，从而实现参数数据的传递。这种方法又称作参照法，即形式参数参照实际参数数据。**输入**

**参数均采用传址法传递数据**。

**传值法是指将实际参数的数据拷贝到形式参数，**而不是传递实际参数的地址。默认时，**输出参数和输**

**入****/****输出参数均采用传值法**。在函数调用时，ORACLE 将实际参数数据拷贝到输入/输出参数，而当函数正常

运行退出时，又将输出形式参数和输入/输出形式参数数据拷贝到实际参数变量中。



### 参数默认值

在CREATE OR REPLACE FUNCTION 语句中声明函数参数时 **可以使用DEFAULT关键字为输入参数指定默认值**

> 

```sql
create or replace function get_sal(
	dept_id emp.deptno%type default 10,
	emp_count out number)
	return number
is
	v_sum number;
begin
	select sum(sal),count(*) into v_sum,emp_count from emp where deptno = dept_id;
	return v_sum;
exception 
	when no_data_found then
		dbms_output.put_line('数据不存在');
	when others then 
		dbms_output.put_line(sqlcode || ':' || sqlerrm);
end;

declare
	v_num number;
	v_sum number;
begin 
	v_sum := get_sal(emp_count => v_num);
    DBMS_OUTPUT.PUT_LINE('middle');

```

具有默认值的函数创建后，在函数调用时，如果没有为具有默认值的参数提供实际参数值，函数将使用该参数的默认值。但当调用者为默认参数提供实际参数时，函数将使用实际参数值。在创建函数时，只能为输入参数设置默认值，而不能为输入/输出参数设置默认值。

### 应用实例

> 不带参数的函数

```sql
create or replace function hello_fun
	return date
is
	v_date date;
begin
	select sysdate into v_date from dual;
	return v_date;
end;

select hello_fun() from dual;
```

> 带参数的函数

```sql
create or replace function hello_func(v_logo varchar2)
	return varchar2
is 
begin
	return 'helloworld'|| v_logo;
end;

select hello_func('jinmunan') from dual;
```

> 两个数相加

```sql
create or replace function add_func(a number, b number)
	return number
is
begin
   return (a + b);
end;

select add_func(1,2) from dual;
```

> 获取部门的工资总和

```sql
create or replace function sum_sal(dept_id number)
	return number
is
    cursor sal_cursor is select sal from emp where deptno = dept_id;
    v_sum_sal number(8) := 0;   
begin
    for c in sal_cursor loop
       v_sum_sal := v_sum_sal + c.sal;
    end loop;       
	return v_sum_sal;
end;

select sum_sal(10) from dual;
```





## 存储过程

### 建立存储过程

在 ORACLE SERVER 上建立存储过程，可以被多个应用程序调用，可以向存储过程传递参数，也可以向存储过程传回参数

### 建立存储过程语法

```sql
CREATE [OR REPLACE] PROCEDURE Procedure_name
    [ (argment [ { IN | IN OUT }] Type,
    argment [ { IN | OUT | IN OUT } ] Type ]
    [ AUTHID DEFINER | CURRENT_USER ]
{ IS | AS }
    <类型.变量的说明>
BEGIN
    <执行部分>
EXCEPTION
    <可选的异常错误处理程序>
END;
```

#### ①删除指定员工记录

```sql
create or replace procedure del_emp(
	v_empno in emp.empno%type)
is
	no_result exception;
begin
	delete from emp where empno = v_empno;
	if sql%notfound then
	 	raise no_result;
	 end if;
	 dbms_output.put_line('编号为：' || v_empno || '的员工已被除名');
exception
	when no_result then
		dbms_output.put_line('数据不存在');
	when others then
		dbms_output.put_line(sqlcode || ':' || sqlerrm);
end;
```

```sql
declare
    v_ename emp.ename%type,
    v_sal emp.sal%type
begin
	del_emp(7369)
   
end;
```

#### ②插入员工记录

```sql
create or replace procedure insert_emp(
	v_empno emp.empno%type,
	v_ename emp.ename%type,
    v_deptno emp.deptno%type)
is
	empno_remaining exception;
	pragma exception_init(empno_remaining,-1);
begin
	insert into emp (empno,ename,deptno) values (v_empno,v_ename,v_deptno);
	 dbms_output.put_line('插入数据成功');
exception
	when empno_remaining then
		dbms_output.put_line('违反完整性约束');
	when others then
		dbms_output.put_line(sqlcode || ':' || sqlerrm);
end;
```

### 调用存储过程

```sql
# ORACLE 使用 EXECUTE 语句来实现对存储过程的调用
EXEC[UTE] Procedure_name( parameter1, parameter2…);
```

#### ①查询指定员工记录

```sql
create or replace procedure query_emp(
	v_empno emp.empno%type,
	v_name emp.ename%type,
    v_sal emp.sal%type)
is
	no_result exception;
begin
    select ename, sal into v_name, v_sal from emp where empno = v_empno;
	 dbms_output.put_line('编号为：' || v_empno || '的员工已被找到');
exception
	when no_result then
		dbms_output.put_line('数据不存在');
	when others then
		dbms_output.put_line(sqlcode || ':' || sqlerrm);
end;
```

```sql
declare
    v_ename emp.ename%type;
    v_sal emp.sal%type;
begin
	query_emp(7369,v_ename,v_sal);
    DBMS_OUTPUT.PUT_LINE('姓名：' || v_ename || '，工资：' || v_sal);
    query_emp(7521,v_ename,v_sal);
    DBMS_OUTPUT.PUT_LINE('姓名：' || v_ename || '，工资：' || v_sal);
end;
```



#### ②计算指定部门的工资总和，并统计其中的职工数量

```sql
```



### AUTHID

### 开发存储过程步骤

#### 使用文字编辑处理软件编辑存储过程源码

#### 在 SQLPLUS 或用调试工具将存储过程程序进行解释

#### 调试源码直到正确

#### 授权执行权给相关的用户或角色

#### 与过程相关数据字典

### 删除过程和函数

删除过程

删除函数
