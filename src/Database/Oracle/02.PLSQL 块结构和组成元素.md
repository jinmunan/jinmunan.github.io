---
icon: page
order: 2
---
# PL/SQL 块结构和组成元素

## PL/SQL 块

PL/SQL 程序由三个块组成，即声明部分、执行部分、异常处理部分

```sql
DECLARE 
/* 声明部分：在此声明 PL/SQL 用到的变量，类型及游标，以及局部的存储过程和函数 */
BEGIN
 /* 执行部分：过程及 SQL 语句 , 即程序的主要部分 */
EXCEPTION
 /* 执行异常部分：错误处理 */
END;
```

PL/SQL 块可以分为三类：

- 无名块：动态构造，只能执行一次
- 子程序：存储在数据库中的存储过程、函数及包等。当在数据库上建立好后可以在其它程序中调用它们

- 触发器：当数据库发生操作时，会触发一些事件，从而自动执行相应的程序

## PL/SQL 结构

- PL/SQL 块中可以包含子块
- 子块可以位于 PL/SQL 中的任何部分
- 子块也即 PL/SQL 中的一条命令

## 标识符

PL/SQL 程序设计中的标识符定义与 SQL 的标识符定义的要求相同。要求和限制有：

- 标识符名不能超过 30 字符
- 第一个字符必须为字母
- 不分大小写
- 不能用“-”（减号）
- 不能是 SQL 保留字

提示：一般不要把变量名声明与表中字段名完全一样，如果这样可能得到不正确的结果

例如：下面的例子将会删除所有的纪录，而不是 KING 的记录；

```sql
DECLARE
    Ename varchar2(20) := ’KING’;
BEGIN
	DELETE FROM emp WHERE ename=ename;
END;
```

变量命名在 PL/SQL 中有特别的讲究，建议在系统的设计阶段就要求所有编程人员共同遵守一定的要求，使得整个系统的文档在规范上达到要求。下面是建议的命名方法：

| 标识符            | 命名规则        | 例子            |
| ----------------- | --------------- | --------------- |
| 程序变量          | V_name          | V_name          |
| 程序常量          | C_Name          | C_company_name  |
| 游标变量          | Name_cursor     | Emp_cursor      |
| 异常标识          | E_name          | E_too_many      |
| 表类型            | Name_table_type | Emp_record_type |
| 表                | Name_table      | Emp             |
| 记录类型          | Name_record     | Emp_record      |
| SQL*Plus 替代变量 | P_name          | P_sal           |
| 绑定变量          | G_name          | G_year_sal      |

## PL/SQL 变量类型

在前面的介绍中，有系统的数据类型，也可以自定义数据类型。下表是 ORACLE 类型和 PL/SQL 中的变量类型的合法使用列表：

### 变量类型

在 ORACLE8i 中可以使用的变量类型有：

![image-20230404094759050](C:/Users/zhongnan/Pictures/Camera Roll/image-20230404094759050.png)

### 复合类型

ORACLE 在 PL/SQL 中除了提供像前面介绍的各种类型外，还提供一种称为复合类型的类型，记录和表

#### 记录类型

记录类型是把逻辑相关的数据作为一个单元存储起来，称作 PL/SQL RECORD 的域 (FIELD)，其作用是存放互不相同但逻辑相关的信息。

```sql
TYPE record_type IS RECORD(
    Field1 type1 [NOT NULL] [:= exp1 ],
    Field2 type2 [NOT NULL] [:= exp2 ],
    . . . . . .
    Fieldn typen [NOT NULL] [:= expn ] ) ;
```

```sql
declare
	type test_rec is record(
		l_name varchar2 (30),
		d_id number (4));
	v_emp test_rec;
begin
	v_emp.l_name := 'Tom';
	v_emp.d_id := 1234;
    DBMS_OUTPUT.PUT_LINE(v_emp.l_name || v_emp.d_id);
end;
```

```sql
declare
	type test_rec is record(
		l_name varchar2 (30),
		d_id number (4));
	v_emp test_rec;
begin
	select ename,deptno into v_emp from emp where empno = 7369;
    DBMS_OUTPUT.PUT_LINE(v_emp.l_name || v_emp.d_id);
end;
```

### %TYPE

定义一个变量，其数据类型与已经定义的某个数据变量的类型相同，或者与数据库表的某个列的数据类型相同，这时可以使用%TYPE。

- 所引用的数据库列的数据类型可以不必知道
- 所引用的数据库列的数据类型可以实时改变

```sql
declare
	type test_rec is record(
		l_name emp.ename%type,
		d_id emp.deptno%type);
	v_emp test_rec;
begin
	select ename,deptno into v_emp from emp where empno = 7369;
    DBMS_OUTPUT.PUT_LINE(v_emp.l_name || v_emp.d_id);
end;
```

### %ROWTYPE

PL/SQL 提供%ROWTYPE 操作符，返回一个记录类型，其数据类型和数据库表的数据结构相一致。

- 所引用的数据库中列的个数和数据类型可以不必知道
- 所引用的数据库中列的个数和数据类型可以实时改变

```sql
declare
	v_emp emp%rowtype;
begin
	select * into v_emp from emp where empno = 7369;
    DBMS_OUTPUT.PUT_LINE(v_emp.ename || v_emp.deptno);
end;
```

### PL/SQL 表（嵌套表）

PL/SQL 程序可使用嵌套表类型创建具有一个或多个列和无限行的变量，这很像数据库中的表，声明嵌套表类型的一般语法如下：

```sql
TYPE type_name IS TABLE OF
	{datatype | {variable | table.column} % type | table%rowtype};
```

### PL/SQL 表方法

1. `EXTEND` 方法：用于增加嵌套表的长度。可以使用 `EXTEND` 方法向嵌套表中添加一个或多个元素。例如：`my_nested_table.EXTEND(2);` 将嵌套表的长度增加 2 个元素。
2. `TRIM` 方法：用于减少嵌套表的长度。可以使用 `TRIM` 方法从嵌套表中删除一个或多个元素。例如：`my_nested_table.TRIM(2);` 将嵌套表的长度减少 2 个元素。
3. `FIRST` 方法：返回嵌套表的第一个元素的下标。例如：`my_nested_table.FIRST` 将返回嵌套表的第一个元素的下标。
4. `LAST` 方法：返回嵌套表的最后一个元素的下标。例如：`my_nested_table.LAST` 将返回嵌套表的最后一个元素的下标。
5. `COUNT` 方法：返回嵌套表中元素的数量。例如：`my_nested_table.COUNT` 将返回嵌套表中元素的数量。
6. `EXISTS` 方法：检查嵌套表中是否存在指定元素。例如：`my_nested_table.EXISTS(10)` 将返回一个布尔值，表示嵌套表中是否存在值为 10 的元素。
7. `DELETE` 方法：从嵌套表中删除指定元素。例如：`my_nested_table.DELETE(3)` 将从嵌套表中删除下标为 3 的元素。
8. `TRUNCATE` 方法：删除嵌套表中的所有元素。例如：`my_nested_table.TRUNCATE()` 将删除嵌套表中的所有元素。

使用嵌套表打印出每个员工的姓名和工资

```sql
DECLARE
    -- 声明嵌套表类型
    TYPE emp_list IS TABLE OF emp%ROWTYPE;
    -- 声明嵌套表变量
    emp_nt emp_list;
BEGIN
    -- 从 emp 表中选取数据并存储到嵌套表中
    SELECT * BULK COLLECT INTO emp_nt FROM emp;

    -- 循环遍历嵌套表
    FOR i IN emp_nt.FIRST .. emp_nt.LAST LOOP
    	DBMS_OUTPUT.PUT_LINE(emp_nt(i).ename || ' 的工资是 ' || emp_nt(i).sal);
    END LOOP;
END;
```

在上面的案例中，我们首先声明了一个嵌套表类型 `emp_list`，它的数据类型是 `emp%ROWTYPE`，表示包含了 `emp` 表的所有列。然后我们声明了一个 `emp_nt` 变量，它是 `emp_list` 类型的嵌套表变量。

接下来，我们使用 `SELECT` 语句从 `emp` 表中选取所有数据，并使用 `BULK COLLECT INTO` 语句将数据存储到 `emp_nt` 嵌套表中。

最后，我们使用 `FOR` 循环遍历 `emp_nt` 嵌套表，并使用 `DBMS_OUTPUT.PUT_LINE` 函数打印出每个员工的姓名和工资。

需要注意的是，在这个案例中我们使用了 `BULK COLLECT INTO` 语句来从数据库中一次性获取多条数据并存储到嵌套表中，这样可以提高代码的执行效率

### PL/SQL 表（嵌套表）和 普通表的区别 和 临时表的区别

PL/SQL 嵌套表和普通表之间的区别在于它们的数据结构和用途不同。嵌套表是一种 PL/SQL 数据类型，用于存储多个相同类型的数据元素，并且可以随时动态添加或删除元素。而普通表是数据库中的一种物理存储结构，用于存储多个不同类型的数据记录，并且其结构和内容在创建时就已经确定，一般不会动态变化。

另外，嵌套表通常用于存储和处理临时数据，而普通表则用于长期存储和管理数据。由于嵌套表是在内存中创建和管理的，因此其操作速度较快，但是其存储容量较有限，适用于存储相对较小的数据集。而普通表则可以存储大量的数据，并且可以通过索引等机制进行快速查询和处理。

临时表是指在 SQL 语句执行期间创建的一种临时数据结构，它通常用于存储中间结果或者辅助计算。临时表可以是普通表或者嵌套表，其主要区别在于其生命周期和作用域。普通表是长期存储的数据结构，而临时表通常只在 SQL 语句执行期间存在，并且其作用域仅限于当前会话或者事务。嵌套表通常用于存储和处理程序中的临时数据，而普通表则用于长期存储和管理数据。

## 运算符和表达式

### 关系运算符

| 运算符            | 意义       |
| ----------------- | ---------- |
| =                 | 等于       |
| <> , != , ~= , ^= | 不等于     |
| <                 | 小于       |
| >                 | 大于       |
| <=                | 小于或等于 |
| >=                | 大于或等于 |

### 一般运算符

| 运算符 | 意义       |
| ------ | ---------- |
| +      | 加号       |
| -      | 减号       |
| *      | 乘号       |
| /      | 除号       |
| :=     | 赋值号     |
| =>     | 关系号     |
| ..     | 范围运算符 |
| \|\|   | 字符连接符 |

### 逻辑运算符

| 运算符      | 意义         |
| ----------- | ------------ |
| IS NULL     | 是空值       |
| BETWEEN AND | 介于两者之间 |
| IN          | 在一列值中间 |
| AND         | 逻辑与       |
| OR          | 逻辑或       |
| NOT         | 取反         |

## 变量赋值

variable 是一个 PL/SQL 变量，expression 是一个 PL/SQL 表达式

```sql
variable := expression;
```

### 字符及数字运算特点

空值加数字仍是空值：`NULL + <数字> = NULL`

空值拼接（连接）字符，结果为字符：`NULL || <字符串> = <字符串>`

### BOOLEAN 赋值

布尔值只有 TRUE, FALSE 及 NULL 三个值

### 数据库赋值

数据库赋值是通过 SELECT 语句来完成的，每次执行 SELECT 语句就赋值一次，一般要求被赋值的变量与 SELECT 中的列名要一一对应

```sql
DECLARE
    emp_id emp.empno%TYPE :=7788;
    emp_name emp.ename%TYPE;
    wages emp.sal%TYPE;
BEGIN
    SELECT ename, NVL(sal,0) + NVL(comm,0) INTO emp_name, wages
    FROM emp WHERE empno = emp_id;
    DBMS_OUTPUT.PUT_LINE(emp_name || '----' || to_char(wages));
END;
```

提示：不能将 SELECT 语句中的列赋值给布尔变量

### 可转换的类型赋值

#### CHAR 转换为 NUMBER

使用 TO_NUMBER  函数来完成字符到数字的转换

```sql
DECLARE
	v_total number;
BEGIN
    v_total := TO_NUMBER('100.0');
    DBMS_OUTPUT.PUT_LINE(v_total);
END;
```

#### NUMBER 转换为 CHAR

使用 TO_CHAR 函数可以实现数字到字符的转换

```sql
DECLARE
	v_comm CHAR(2000);
BEGIN
    v_comm := TO_CHAR('123.45') || '元';
    DBMS_OUTPUT.PUT_LINE(v_comm);
END;
```

#### 字符转换为日期

使用 TO_DATE 函数可以实现  字符到日期的转换

```sql
DECLARE
	v_date date;
BEGIN
    v_date := TO_DATE('2001.07.03','yyyy.mm.dd');
    DBMS_OUTPUT.PUT_LINE(v_date);
END;
```

#### 日期转换为字符

使用 TO_CHAR 函数可以实现日期到字符的转换

```sql
DECLARE
	v_today varchar2(2000);
BEGIN
    v_today := TO_CHAR(SYSDATE, 'yyyy.mm.dd hh24:mi:ss');
    DBMS_OUTPUT.PUT_LINE(v_today);
END;
```

## 变量作用范围及可见性

- 变量的作用范围是在你所引用的程序单元（块、子程序、包）内。即从声明变量开始到该块的结束
- 一个变量（标识）只能在你所引用的块内是可见的
- 当一个变量超出了作用范围，PL/SQL 引擎就释放用来存放该变量的空间
- 在子块中重新定义该变量后，它的作用仅在该块内

## 注释 

```sql
DECLARE
	v_today varchar2(2000); -- 我是注释
BEGIN
    v_today := TO_CHAR(SYSDATE, 'yyyy.mm.dd hh24:mi:ss');
    DBMS_OUTPUT.PUT_LINE(v_today);
	/*
		我是多行注释
		我是多行注释
	*/
END;
```

## 应用案例

### 数据插入

```sql
DECLARE
	v_ename VARCHAR2(20) := 'Bill';
	v_sal NUMBER(7,2) := 1234.56;
	v_deptno NUMBER(2) := 10;
	v_empno NUMBER(4) := 8888;
BEGIN
	INSERT INTO emp ( empno, ename, JOB, sal, deptno, hiredate )
	VALUES ( v_empno, v_ename, 'Manager', v_sal, v_deptno, TO_DATE('1954.06.09','yyyy.mm.dd') );
	COMMIT;
END;

select * from emp where empno = 8888;
```

### 数据删除

```sql
DECLARE
	v_empno number(4) := 8888;
BEGIN
	DELETE FROM emp WHERE empno=v_empno;
	COMMIT;
END;
```

