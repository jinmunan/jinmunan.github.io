---
icon: page
order: 7
---
# Spring 事务

## Spring 事务概念

### 什么是事务？

数据库事务 ( transaction) 是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。

### 事务的哪些特性？

#### 原子性 (Atomicity)

一个事务 (transaction) 中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

#### 一致性 (Consistency)

事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。

如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。

如果事务出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

#### 隔离性 (Isolation)

指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

#### 持久性 (Durability)

指的是只要事务成功结束，它对数据库所做的更新就必须保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

### 什么是编程式事务？

事务功能的相关操作全部通过自己编写代码来实现

```java
Connection conn = ...;

try {

    // 开启事务：关闭事务的自动提交
    conn.setAutoCommit(false);

    // 核心操作

    // 提交事务
    conn.commit();

}catch(Exception e){

    // 回滚事务
    conn.rollBack();

}finally{

    // 释放数据库连接
    conn.close();

}
```

编程式的实现方式存在缺陷

- 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。
- 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。

### 什么是声明式事务？

既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。

封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。

- 好处 1：提高开发效率
- 好处 2：消除了冗余的代码
- 好处 3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化

所以，我们可以总结下面两个概念：

- 编程式：自己写代码实现功能
- 声明式：通过配置让框架实现功能

## ✨基于注解的声明式事务

### 准备工作

#### 添加依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.17</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.2.8</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <version>5.3.1</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aspects</artifactId>
        <version>5.3.17</version>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.47</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.3.17</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-orm</artifactId>
        <version>5.3.17</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-tx</artifactId>
        <version>5.3.17</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>RELEASE</version>
        <scope>compile</scope>
    </dependency>
</dependencies>
```

#### 创建数据表

```sql
CREATE TABLE `t_book` (
  `book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `book_name` varchar(20) DEFAULT NULL COMMENT '图书名称',
  `price` int(11) DEFAULT NULL COMMENT '价格',
  `stock` int(10) unsigned DEFAULT NULL COMMENT '库存（无符号）',
  PRIMARY KEY (`book_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
insert  into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,'斗破苍穹',80,100),(2,'斗罗大陆',50,100);
CREATE TABLE `t_user` (
  `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `username` varchar(20) DEFAULT NULL COMMENT '用户名',
  `balance` int(10) unsigned DEFAULT NULL COMMENT '余额（无符号）',
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
insert  into `t_user`(`user_id`,`username`,`balance`) values (1,'admin',50);
```

#### 基础代码

略

#### 测试代码

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class TxByAnnotationTest {

    @Resource
    private BookService bookService;

    @Test
    public void testBuyBook() {
        System.out.println(bookService);
        // mysql 数据库中余额字段设置了无符号
        bookService.buyBook(1, 1);
    }
}
```

#### 模拟场景

用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额

假设用户 id 为 1 的用户，购买 id 为 1 的图书

用户余额为 50，而图书价格为 80

购买图书之后，用户的余额为 -30，数据库中余额字段设置了无符号，因此无法将 -30 插入到余额字段

此时执行 sql 语句会抛出 SQLException

#### 观察结果

因为没有添加事务，图书的库存更新了，但是用户的余额没有更新

显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败

### 加入事务

#### 修改 Spring 的配置文件

```xml
<!-- 配置事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!-- 开启事务注解 -->
<tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>
```

#### 添加事务注解

因为 service 层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在 service 层处理

在 BookServiceImpl 的 buybook() 添加注解@Transactional

#### 观察结果

由于使用了 Spring 的声明式事务，更新库存和更新余额都没有执行

### @Transactional

#### @Transactional 注解代码

```java
@Target({ElementType.TYPE, ElementType.METHOD})  // 可以应用在方法和类上
@Retention(RetentionPolicy.RUNTIME)  // 运行时
@Inherited
@Documented
public @interface Transactional {
    @AliasFor("transactionManager")
    String value() default "";

    @AliasFor("value")
    String transactionManager() default "";

    String[] label() default {};

    // 事务的传播行为：有事务和无事务相互调用的过程，事务是如何操作的
    // 7 种传播行为
    // 默认是 required
    Propagation propagation() default Propagation.REQUIRED;

    // 事务的隔离级别：4 种
    //mysql 默认可重复读
    //oralce 默认读以提交
    Isolation isolation() default Isolation.DEFAULT;

    // 超时时间
    int timeout() default -1;

    String timeoutString() default "";

    // 是否只读
    // 默认是 false
    // 设置为 true 后就不可以更改
    boolean readOnly() default false;

    // 回滚：设置哪些异常进行事务回滚
    Class<? extends Throwable>[] rollbackFor() default {};

    String[] rollbackForClassName() default {};

    // 不回滚：设置哪些异常不进行事务回滚
    Class<? extends Throwable>[] noRollbackFor() default {};

    String[] noRollbackForClassName() default {};
}
```

#### @Transactional 注解标识的位置

@Transactional 标识在方法上，则只会影响该方法

@Transactional 标识的类上，则会影响类中所有的方法

### ✨事务属性

#### 事务属性：只读

对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。

```java
@Transactional(readOnly = true)
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}
```

对增删改操作设置只读会抛出下面异常：

`Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed`

#### 事务属性：超时

事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是 Java 程序或 MySQL 数据库或网络连接等等）。此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。

概括来说就是一句话：超时回滚，释放资源。

```java
//超时时间单位秒
@Transactional(timeout = 3)
public void buyBook(Integer bookId, Integer userId) {
    try {
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}
```

执行过程中抛出异常：

`org.springframework.transaction.**TransactionTimedOutException**: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022`

#### 事务属性：回滚策略

声明式事务默认只针对运行时异常回滚，编译时异常不回滚。

可以通过@Transactional 中相关属性设置回滚策略

- rollbackFor 属性：需要设置一个 Class 类型的对象
- rollbackForClassName 属性：需要设置一个字符串类型的全类名

- noRollbackFor 属性：需要设置一个 Class 类型的对象
- rollbackFor 属性：需要设置一个字符串类型的全类名

```java
@Transactional(noRollbackFor = ArithmeticException.class)
//@Transactional(noRollbackForClassName = "java.lang.ArithmeticException")
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    System.out.println(1/0);
}
```

虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现 ArithmeticException 不发生回滚，因此购买图书的操作正常执行

#### 事务属性：隔离级

数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL 标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。

隔离级别一共有四种：

- 读未提交：READ UNCOMMITTED

  允许 Transaction01 读取 Transaction02 未提交的修改。

- 读已提交：READ COMMITTED、

  要求 Transaction01 只能读取 Transaction02 已提交的修改。

- 可重复读：REPEATABLE READ

  确保 Transaction01 可以多次从一个字段中读取到相同的值，即 Transaction01 执行期间禁止其它事务对这个字段进行更新。

- 串行化：SERIALIZABLE

  确保 Transaction01 可以多次从一个表中读取到相同的行，在 Transaction01 执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。

各个隔离级别解决并发问题的能力见下表：

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ UNCOMMITTED | 有   | 有         | 有   |
| READ COMMITTED   | 无   | 有         | 有   |
| REPEATABLE READ  | 无   | 无         | 有   |
| SERIALIZABLE     | 无   | 无         | 无   |

各种数据库产品对事务隔离级别的支持程度：

| 隔离级别         | Oracle  | MySQL   |
| ---------------- | ------- | ------- |
| READ UNCOMMITTED | ×       | √       |
| READ COMMITTED   | √(默认) | √       |
| REPEATABLE READ  | ×       | √(默认) |
| SERIALIZABLE     | √       | √       |

```java
@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别
@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交
@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交
@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读
@Transactional(isolation = Isolation.SERIALIZABLE)//串行化
```

#### 事务属性：传播行为

什么是事务的传播行为？

在 service 类中有 a() 方法和 b() 方法，a() 方法上有事务，b() 方法上也有事务，当 a() 方法执行过程中调用了 b() 方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。

一共有七种传播行为：

- REQUIRED：支持当前事务，如果不存在就新建一个 (默认)【**没有就新建，有就加入**】
- SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【**有就加入，没有就不管了**】
- MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【**有就加入，没有就抛异常**】
- REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【**不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起**】
- NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务【**不支持事务，存在就挂起**】
- NEVER：以非事务方式运行，如果有事务存在，抛出异常【**不支持事务，存在就抛异常**】
- NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像 REQUIRED 一样。【**有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和 REQUIRED 一样**】

#### 测试事务的传播行为

1、在数据库中将用户的余额修改为 100 元

2、可以通过@Transactional 中的 propagation 属性设置事务传播行为

3、修改 BookServiceImpl 中 buyBook() 上，注解@Transactional 的 propagation 属性

4、创建接口 CheckoutService：

```java
public interface CheckoutService {
    void checkout(Integer[] bookIds, Integer userId);
}
```

5、创建实现类 CheckoutServiceImpl：

```java
package com.atguigu.spring6.service.impl;

@Service
public class CheckoutServiceImpl implements CheckoutService {

    @Autowired
    private BookService bookService;

    @Override
    @Transactional
    //一次购买多本图书
    public void checkout(Integer[] bookIds, Integer userId) {
        for (Integer bookId : bookIds) {
            bookService.buyBook(bookId, userId);
        }
    }
}
```

6、在 BookController 中添加方法：

```java
@Autowired
private CheckoutService checkoutService;

public void checkout(Integer[] bookIds, Integer userId){
    checkoutService.checkout(bookIds, userId);
}
```

7、测试代码

```java
@Test
public void testBuyBooks() throws InterruptedException {
    System.out.println(checkoutService);
    // mysql int 类型是 0 开始的 因此 50-80=-30 会报错
    checkoutService.checkout(new Integer[]{1, 2}, 1);
}
```

8、测试结果

```
checkout() 开启 propagation = Propagation.REQUIRED
buyBook() 也开启 propagation = Propagation.REQUIRED
因为checkout()本身开启了一个新事务，buyBook()就会加入到checkout()的事务中去，合并成一个事务，因此多次buyBook()的动作都会合并，只要有一个失败就失败

checkout() 不开启事务支持
buyBook() 开启 propagation = Propagation.REQUIRED
因为checkout()本身没有开启事务，只是buyBook()开启了事务，因此每次购买操作都是独立的，能成功的成功，失败的失败

checkout() 开启 propagation = Propagation.REQUIRED
buyBook() 开启 propagation = Propagation.SUPPORTS
因为checkout()本身开启了一个新事务，buyBook()就会加入到checkout()的事务中去，合并成一个事务，因此多次buyBook()的动作都会合并，只要有一个失败就失败，可以理解为SUPPORTS事务是个墙头草

checkout() 不开启事务支持
buyBook() 也开启 propagation = Propagation.SUPPORTS
因为checkout()本身没有开启事务，虽然buyBook()写了事务注解，但是是SUPPORTS并且前面没有事务，buyBook()也就以非事务方式执行了

checkout() 开启 propagation = Propagation.REQUIRED
buyBook() 开启 propagation = Propagation.MANDATORY
checkout() 开启事务 buyBook()就会加入该事务，只要checkout()不开启事务，执行buyBook()就会报异常

checkout() 开启 propagation = Propagation.REQUIRED
buyBook() 开启 propagation = Propagation.REQUIRES_NEW
checkout() 开启事务 buyBook()不管那个事务，自己开了一个新事务，成功的事务就成功了，失败的事务就回滚，checkout() 的事务并不会影响到成功的事务，相当于每个事物都是独立的

checkout() 开启 propagation = Propagation.REQUIRED
buyBook() 开启 propagation = Propagation.NOT_SUPPORTED
不管checkout()是否开启了事务，buyBook()执行结果都是不会被checkout()的事务影响的，等于checkout()没开事务一样

checkout() 开启 propagation = Propagation.REQUIRED
buyBook() 开启 propagation = Propagation.NEVER
很好理解。checkout() 开启事务就抛出异常

checkout() 开启 propagation = Propagation.REQUIRED
buyBook() 开启 propagation = Propagation.NESTED
主事务和嵌套事务属于同一个事务
嵌套事务出错回滚不会影响到主事务
主事务回滚会将嵌套事务一起回滚了
```

## 全注解配置事务

```java
@Configuration // 作为配置类，代替 xml 配置文件
@ComponentScan(basePackages = "com.cj.spring.*")
@EnableAspectJAutoProxy(proxyTargetClass = true)// 开启 AspectJ 注解配置
@EnableTransactionManagement
public class SpringConfig {
    @Bean
    public DataSource getDataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&useSSL=false");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        return dataSource;
    }

    @Bean(name = "jdbcTemplate")
    public JdbcTemplate getJdbcTemplate(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    }

    // 事务管理器
    @Bean
    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) {
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }
}
```

## 基于 XML 的声明式事务

原理是通过 AOP 对方法进行增强，为方法添加上事务控制。

将 Spring 配置文件中去掉`tx:annotation-driven` 标签，并添加配置

```xml
<aop:config>
    <!-- 配置事务通知和切入点表达式 -->
    <aop:advisor advice-ref="txAdvice" pointcut="execution(* com.cj.spring.service.impl.*.*(..))"/>
</aop:config>
<!-- tx:advice标签：配置事务通知 -->
<!-- id属性：给事务通知标签设置唯一标识，便于引用 -->
<!-- transaction-manager属性：关联事务管理器 -->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <!-- tx:method标签：配置具体的事务方法 -->
        <!-- name属性：指定方法名，可以使用星号代表多个字符 -->
        <tx:method name="get*" read-only="true"/>
        <tx:method name="query*" read-only="true"/>
        <tx:method name="find*" read-only="true"/>

        <!-- read-only属性：设置只读属性 -->
        <!-- rollback-for属性：设置回滚的异常 -->
        <!-- no-rollback-for属性：设置不回滚的异常 -->
        <!-- isolation属性：设置事务的隔离级别 -->
        <!-- timeout属性：设置事务的超时属性 -->
        <!-- propagation属性：设置事务的传播行为 -->
        <tx:method name="save*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/>
        <tx:method name="update*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/>
        <tx:method name="delete*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/>
    </tx:attributes>
</tx:advice>
```

