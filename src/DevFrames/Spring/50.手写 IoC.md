---
icon: page
order: 14
---
# 手写 IoC

我们都知道，Spring 框架的 IOC 是基于 Java 反射机制实现的，下面我们先回顾一下 java 反射。

## 回顾 Java 反射

`Java`反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为`Java`语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。

要想解剖一个类，必须先要获取到该类的 Class 对象。而剖析一个类或用反射解决具体的问题就是使用相关 API（1）java.lang.Class（2）java.lang.reflect，所以，Class 对象是反射的根源。

### 自定义类

```java
public class Car {
    //属性
    private String name;
    private int age;
    private String color;
    public Integer money;

    //无参数构造
    public Car() {
    }

    //有参数私有构造
    private Car(String name) {
        this.name = name;
    }

    //有参数构造
    public Car(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    //普通方法
    private void run() {
        System.out.println("私有方法-run.....");
    }

    //get 和 set 方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        System.out.println("执行了 toString 方法");
        return "Car{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }
}
```

### 编写测试类

```java
public class CarTest {

    //1、获取 Class 对象多种方式
    @Test
    public void test01() throws Exception {
        //1 类名.class
        Class clazz1 = Car.class;
        //2 对象.getClass()
        Class clazz2 = new Car().getClass();
        //3 Class.forName("全路径")
        Class clazz3 = Class.forName("com.cj.spring.Car");
        //实例化
        Car car = (Car) clazz3.getConstructor().newInstance();
        System.out.println(car);
    }

    //2、获取构造方法
    @Test
    public void test02() throws Exception {
        Class clazz = Car.class;
        //获取所有构造
        //getConstructors() 获取所有 public 的构造方法
        Constructor[] constructors = clazz.getConstructors();
        //getDeclaredConstructors() 获取所有的构造方法 public  private
        Constructor[] constructorAll = clazz.getDeclaredConstructors();
        for (Constructor c : constructors) {
            System.out.println("方法名称：" + c.getName() + " 参数个数：" + c.getParameterCount());
        }
        System.out.println("------------------------------------------------------------------");
        for (Constructor c : constructorAll) {
            System.out.println("方法名称：" + c.getName() + " 参数个数：" + c.getParameterCount());
        }
        System.out.println("------------------------------------------------------------------");
        //指定有参数构造创建对象
        //1 构造 public
        Constructor c1 = clazz.getConstructor(String.class, int.class, String.class);
        Car car1 = (Car) c1.newInstance("夏利", 10, "红色");
        System.out.println(car1);
        System.out.println("------------------------------------------------------------------");
        //2 构造 private
        Constructor c2 = clazz.getDeclaredConstructor(String.class);
        c2.setAccessible(true);  // 访问私有成员
        Car car2 = (Car) c2.newInstance("捷达");
        System.out.println(car2);
    }

    //3、获取属性
    @Test
    public void test03() throws Exception {
        Class clazz = Car.class;
        Car car = (Car) clazz.getDeclaredConstructor().newInstance();
        //获取所有 public 属性
        Field[] fields = clazz.getFields();
        Arrays.stream(fields).forEach(System.out::println);
        System.out.println("------------------------------------------------------------------");
        //获取所有属性（包含私有属性）
        Field[] fieldAll = clazz.getDeclaredFields();
        Arrays.stream(fieldAll).forEach(System.out::println);
        for (Field field : fields) {
            if (field.getName().equals("name")) {
                //设置允许访问
                field.setAccessible(true);
                field.set(car, "五菱宏光");
                System.out.println(car);
            }
            System.out.println(field.getName());
        }
    }

    //4、获取方法
    @Test
    public void test04() throws Exception {
        Car car = new Car("奔驰", 10, "黑色");
        Class clazz = car.getClass();
        //1 public 方法
        Method[] methods = clazz.getMethods();
        System.out.println("------------------------------------------------------------------");
        for (Method m1 : methods) {
            //System.out.println(m1.getName());
            //执行方法 toString
            if (m1.getName().equals("toString")) {
                m1.invoke(car);
            }
        }
        System.out.println("------------------------------------------------------------------");
        //2 private 方法
        Method[] methodsAll = clazz.getDeclaredMethods();
        for (Method m : methodsAll) {
            //执行方法 run
            if (m.getName().equals("run")) {
                m.setAccessible(true);
                m.invoke(car);
            }
        }
    }
}
```

## 实现 Spring 的 IoC

### 添加依赖

```xml
<dependencies>
    <!--junit5测试-->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
        <version>5.3.1</version>
    </dependency>
</dependencies>
```

### 创建 UserDao 接口

```java
public interface UserDao {
    public void print();
}
```

### 创建 UserDaoImpl 实现

```java
public class UserDaoImpl implements UserDao {
    @Override
    public void print() {
        System.out.println("------------------------------------------------");
    }
}
```

### 创建 UserService 接口

```java
public interface UserService{
    public void sound();
}
```

### 创建 UserServiceImpl 实现类

```java
public class UserServiceImpl implements UserService {

    @Di
    private UserDao userDao;

    @Override
    public void sound() {
        userDao.print();
        System.out.println("123");
    }
}
```

### 定义注解

我们通过注解的形式加载 bean 与实现依赖注入

### bean 注解

模拟@Component

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Bean {
}
```

### Di 注解

模拟@Autowired

```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Di {
}
```

说明：上面两个注解可以随意取名

### ApplicationContext 容器

模拟 spring 容器

```java
public interface ApplicationContext {
    Object getBean(Class clazz);
}
```

### AnnotationApplicationContext 容器

AnnotationApplicationContext 基于注解扫描 bean

```java
public class AnnotationApplicationContext implements ApplicationContext {
    //存储 bean 的容器
    private HashMap<Class, Object> beanFactory = new HashMap<>();
    private static String rootPath;

    @Override
    public Object getBean(Class clazz) {
        return beanFactory.get(clazz);
    }

    public static void main(String[] args) {
        AnnotationApplicationContext annotationApplicationContext = new AnnotationApplicationContext("com.cj.spring");
    }

    /**
     * 这段代码实现了一个注解式的应用程序上下文，用于扫描指定包中的类并将其作为 bean 注册到应用程序上下文中
     * @param basePackage
     */
    public AnnotationApplicationContext(String basePackage) {
        try {
            // 将 basePackage 中的点（.）替换为斜杠（\），得到 packageDirName，用于查找包路径下的所有类
            String packageDirName = basePackage.replace(".", "\\");
            // com.cj.spring.test --> com\cj\spring\test
            System.out.println(packageDirName);
            // 通过 Thread.currentThread().getContextClassLoader().getResources(packageDirName) 方法获取指定包路径下的所有资源 URL，
            // 其中可能包含多个 URL，因为一个包可能会被拆分成多个 jar 或目录。
            Enumeration<URL> dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);
            //java.lang.CompoundEnumeration@3feba861
            System.out.println(dirs);
            // 遍历所有的资源 URL，对于每一个 URL，获取其对应的文件路径，并将其解码为 UTF-8 编码格式的字符串，得到 filePath。
            while (dirs.hasMoreElements()) {
                URL url = dirs.nextElement();
                String filePath = URLDecoder.decode(url.getFile(), "utf-8");
                System.out.println(filePath);
                // 通过 filePath 和 packageDirName 的长度计算出 rootPath，即包路径的根目录。
                rootPath = filePath.substring(0, filePath.length() - packageDirName.length());
                System.out.println("rootPath--->" + rootPath);
                // 调用 loadBean 方法加载 filePath 对应的类，并将其作为 bean 注册到应用程序上下文中。
                loadBean(new File(filePath));
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        // 依赖注入
        loadDi();
    }

    // 依赖注入
    private void loadDi() {
        for (Map.Entry<Class, Object> entry : beanFactory.entrySet()) {
            // 就是咱们放在容器的对象
            Object obj = entry.getValue();
            Class<?> aClass = obj.getClass();
            // 获取全部属性
            Field[] declaredFields = aClass.getDeclaredFields();
            for (Field field : declaredFields) {
                // 如果属性上有 Di 注解
                Di annotation = field.getAnnotation(Di.class);
                if (annotation != null) {
                    // 私有注入
                    field.setAccessible(true);
                    try {
                        System.out.println(field); // private com.cj.spring.dao.UserDao com.cj.spring.service.UserServiceImpl.userDao，他现在是空的
                        // 相当于我在 UserServiceImpl 注入了 userDao，他从工厂中获取
                        System.out.println(field.getType()); // interface com.cj.spring.dao.UserDao
                        System.out.println("正在给【" + obj.getClass().getName() + "】属性【" + field.getName() + "】注入值【" + beanFactory.get(field.getType()).getClass().getName() + "】");
                        System.out.println(beanFactory.get(field.getType())); // com.cj.spring.dao.UserDaoImpl@533ddba 为什么
                        // 正在加载【interface com.cj.spring.dao.UserDao】,实例对象是：com.cj.spring.dao.UserDaoImpl
                        // 因为在工厂中我们设置 key 是接口，value 是实现类，所有通过接口返回了实现类
                        // 他给 userDao 设置了一个对象，就是 UserDaoImpl 的实现类
                        // 相当于初始化的时候  UserDao userDao = new userDaoImpl();
                        field.set(obj, beanFactory.get(field.getType()));
                    } catch (IllegalAccessException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    private void loadBean(File fileParent) {
        if (fileParent.isDirectory()) {
            // 列出包下的所有的类和子包
            File[] childrenFiles = fileParent.listFiles();
            // 包下没有类和子包就返回
            if (childrenFiles == null || childrenFiles.length == 0) {
                return;
            }
            // 对类和子包进行遍历
            for (File child : childrenFiles) {
                if (child.isDirectory()) {
                    //如果是个文件夹就继续调用该方法，使用了递归
                    loadBean(child);
                } else {
                    //通过文件路径转变成全类名，第一步把绝对路径部分去掉
                    System.out.println(child.getAbsolutePath());
                    String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1);
                    System.out.println(pathWithClass);
                    //选中 class 文件
                    if (pathWithClass.contains(".class")) {
                        //com\cj\spring\myioc\Bean.class ---> com.cj.spring.myioc.Bean
                        //去掉.class 后缀，并且把 \ 替换成 .
                        String fullName = pathWithClass.replace("\\", ".").replace(".class", "");
                        System.out.println(fullName);
                        // 获取类的全限定类名后，就可以通过反射创建对象，解析 xml 也就是为了获取类的全限定类名
                        try {
                            // 获取类的 Class 对象
                            Class<?> aClass = Class.forName(fullName);
                            //把非接口的类实例化放在 map 中
                            if (!aClass.isInterface()) {
                                // 获取注解
                                Bean annotation = aClass.getAnnotation(Bean.class);
                                // 如果注解不等于 null 则创建实例对象
                                if (annotation != null) {
                                    Object instance = aClass.newInstance();
                                    // 判断一下有没有接口
                                    // 这段代码是调用一个 Java 类 aClass 的 getInterfaces() 方法，
                                    // 该方法返回一个包含该类实现的所有接口的 Class 对象数组。
                                    // 具体来说，该方法返回一个数组，其中每个元素都是一个 Class 对象，
                                    // 表示 aClass 类实现的一个接口。
                                    // 通过调用该方法，可以获取 aClass 类实现的所有接口的信息，
                                    // 从而进行进一步的操作，例如查询接口的方法和属性等。
                                    if (aClass.getInterfaces().length > 0) {
                                        // TODO : 接口多实现问题？
                                        System.out.println(Arrays.toString(aClass.getInterfaces()));
                                        //如果有接口把接口的 class 当成 key，实例对象当成 value
                                        System.out.println("正在加载【" + aClass.getInterfaces()[0] + "】,实例对象是：" + instance.getClass().getName());
                                        beanFactory.put(aClass.getInterfaces()[0], instance);
                                    } else {
                                        //如果没有接口把自己的 class 当成 key，实例对象当成 value
                                        System.out.println("正在加载【" + aClass.getName() + "】,实例对象是：" + instance.getClass().getName());
                                        beanFactory.put(aClass, instance);
                                    }
                                }
                            }
                        } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}
```

### 标识 Bean 和 Di 注解

```java
@Bean
public class UserDaoImpl implements UserDao {
    @Override
    public void print() {
        System.out.println("------------------------------------------------");
    }
}
```

```java
@Bean
public class UserServiceImpl implements UserService {

    @Di
    private UserDao userDao;

    @Override
    public void sound() {
        userDao.print();
        System.out.println("123");
    }
}
```

### 测试 Bean 加载和 Di 依赖注入

```java
public class UserTest {
    @Test
    public void testIoc() {
        // 初始化的时候就全部加载了
        ApplicationContext applicationContext = new AnnotationApplicationContext("com.cj.spring");

        // 这里就是直接从工厂取数据了
        UserService userService = (UserService) applicationContext.getBean(UserService.class);
        userService.sound();
        System.out.println("run success");
    }
}
```

控制台打印测试

### 扫描 bean 逻辑

> 扫描 bean 逻辑就是在 Spring 容器初始化的时候，通过构造方法传入的包路径，通过遍历包和子包，将所有标注 Bean 的类放入到一个 hashmap 的 beanFactory 工厂中，如果这个类实现了某个接口，就将这个接口作为 key，实例对象作为值放入，否则就将该类作为 key，实例对象作为值放入放入 beanFactory 工厂。

我们通过构造方法传入包的 base 路径，扫描被 @Bean 注解的 java 对象，完整代码如下：

```java
private void loadBean(File fileParent) {
    if (fileParent.isDirectory()) {
        // 列出包下的所有的类和子包
        File[] childrenFiles = fileParent.listFiles();
        // 包下没有类和子包就返回
        if (childrenFiles == null || childrenFiles.length == 0) {
            return;
        }
        // 对类和子包进行遍历
        for (File child : childrenFiles) {
            if (child.isDirectory()) {
                //如果是个文件夹就继续调用该方法，使用了递归
                loadBean(child);
            } else {
                //通过文件路径转变成全类名，第一步把绝对路径部分去掉
                System.out.println(child.getAbsolutePath());
                String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1);
                System.out.println(pathWithClass);
                //选中 class 文件
                if (pathWithClass.contains(".class")) {
                    //com\cj\spring\myioc\Bean.class ---> com.cj.spring.myioc.Bean
                    //去掉.class 后缀，并且把 \ 替换成 .
                    String fullName = pathWithClass.replace("\\", ".").replace(".class", "");
                    System.out.println(fullName);
                    // 获取类的全限定类名后，就可以通过反射创建对象，解析 xml 也就是为了获取类的全限定类名
                    try {
                        // 获取类的 Class 对象
                        Class<?> aClass = Class.forName(fullName);
                        //把非接口的类实例化放在 map 中
                        if (!aClass.isInterface()) {
                            // 获取注解
                            Bean annotation = aClass.getAnnotation(Bean.class);
                            // 如果注解不等于 null 则创建实例对象
                            if (annotation != null) {
                                Object instance = aClass.newInstance();
                                // 判断一下有没有接口
                                // 这段代码是调用一个 Java 类 aClass 的 getInterfaces() 方法，
                                // 该方法返回一个包含该类实现的所有接口的 Class 对象数组。
                                // 具体来说，该方法返回一个数组，其中每个元素都是一个 Class 对象，
                                // 表示 aClass 类实现的一个接口。
                                // 通过调用该方法，可以获取 aClass 类实现的所有接口的信息，
                                // 从而进行进一步的操作，例如查询接口的方法和属性等。
                                if (aClass.getInterfaces().length > 0) {
                                    // TODO : 接口多实现问题？
                                    System.out.println(Arrays.toString(aClass.getInterfaces()));
                                    //如果有接口把接口的 class 当成 key，实例对象当成 value
                                    System.out.println("正在加载【" + aClass.getInterfaces()[0] + "】,实例对象是：" + instance.getClass().getName());
                                    beanFactory.put(aClass.getInterfaces()[0], instance);
                                } else {
                                    //如果没有接口把自己的 class 当成 key，实例对象当成 value
                                    System.out.println("正在加载【" + aClass.getName() + "】,实例对象是：" + instance.getClass().getName());
                                    beanFactory.put(aClass, instance);
                                }
                            }
                        }
                    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```

### 依赖注入逻辑

> 依赖注入的逻辑就是在 Spring 容器初始化设置好 beanFactory 工厂后，对工厂的所有 bean 进行遍历，对 bean 中标注 Di 注解的属性进行赋值，它会在工厂中找到一个相同类型的对象并且赋值给这个对象的熟悉。

```java
// 依赖注入
private void loadDi() {
    for (Map.Entry<Class, Object> entry : beanFactory.entrySet()) {
        // 就是咱们放在容器的对象
        Object obj = entry.getValue();
        Class<?> aClass = obj.getClass();
        // 获取全部属性
        Field[] declaredFields = aClass.getDeclaredFields();
        for (Field field : declaredFields) {
            // 如果属性上有 Di 注解
            Di annotation = field.getAnnotation(Di.class);
            if (annotation != null) {
                // 私有注入
                field.setAccessible(true);
                try {
                    System.out.println(field); // private com.cj.spring.dao.UserDao com.cj.spring.service.UserServiceImpl.userDao，他现在是空的
                    // 相当于我在 UserServiceImpl 注入了 userDao，他从工厂中获取
                    System.out.println(field.getType()); // interface com.cj.spring.dao.UserDao
                    System.out.println("正在给【" + obj.getClass().getName() + "】属性【" + field.getName() + "】注入值【" + beanFactory.get(field.getType()).getClass().getName() + "】");
                    System.out.println(beanFactory.get(field.getType())); // com.cj.spring.dao.UserDaoImpl@533ddba 为什么
                    // 正在加载【interface com.cj.spring.dao.UserDao】,实例对象是：com.cj.spring.dao.UserDaoImpl
                    // 因为在工厂中我们设置 key 是接口，value 是实现类，所有通过接口返回了实现类
                    // 他给 userDao 设置了一个对象，就是 UserDaoImpl 的实现类
                    // 相当于初始化的时候  UserDao userDao = new userDaoImpl();
                    field.set(obj, beanFactory.get(field.getType()));
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



