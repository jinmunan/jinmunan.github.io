Index: src/java/javase review/01.随堂复习与企业真题（Java语言概述）.md
===================================================================
diff --git a/src/java/javase review/01.随堂复习与企业真题（Java语言概述）.md b/src/java/javase review/01.随堂复习与企业真题（Java语言概述）.md
deleted file mode 100644
--- a/src/java/javase review/01.随堂复习与企业真题（Java语言概述）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,291 +0,0 @@
----
-order: 1
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（Java 语言概述）
-
-***
-
-## 一、随堂复习
-
-### 1. Java 基础全程的学习内容
-
-```
-第1阶段：Java基本语法
-> Java概述、关键字、标识符、变量、运算符、流程控制（条件判断、选择结构、循环结构）、IDEA、数组
-
-第2阶段：Java面向对象编程
-> 类及类的内部成员
-> 面向对象的三大特征
-> 其它关键字的使用
-
-第3阶段：Java语言的高级应用
-> 异常处理、多线程、IO流、集合框架、反射、网络编程、新特性、其它常用的API等
-```
-
-神书：《Java 核心技术》、《Effective Java》、《Java 编程思想》
-
-### 2. 软件开发相关内容
-
-#### 2.1 计算机的构成
-
-硬件 + 软件 
-
-#### 2.2 软件
-
-软件，即一系列按照`特定顺序组织`的计算机`数据`和`指令`的集合。有**系统软件**和**应用软件**之分。
-
-- 系统软件，即操作系统，windows、Mac os、linux、android、ios
-- 应用软件，即 os 之上的应用程序。
-
-#### 2.3 人机交互方式
-
-- 图形化界面（GUI）
-- 命令行交互方式（CLI）
-  - 熟悉常用的 dos 命令：dir、cd、cd.. 、cd/  cd\ 、md、rd 等
-
-#### 2.4 计算机编程语言
-
-- 语言的分代：
-  - 第 1 代：机器语言
-  - 第 2 代：汇编语言
-  - 第 3 代：高级语言
-    - 面向过程的语言：C
-    - 面向对象的语言：C++、Java、C#、Python、Go、JavaScript
-
-- **没有“最好”的语言**，只有在特定场景下相对来说，最适合的语言而已。
-
-### 3. Java 概述
-
-#### 3.1 Java 发展史
-
-- 几个重要的版本：1996 年，发布 JDK1.0; 里程碑式的版本：JDK5.0、JDK8.0(2014 年发布)
-
-  ​                                JDK11（LTS）、JDK17（LTS）long term support
-
-#### 3.2 Java 之父
-
-詹姆斯·高斯林
-
-#### 3.3 Java 具体的平台划分
-
-J2SE --->JavaSE
-
-J2EE ---->JavaEE
-
-J2ME ---> JavaME
-
-Java 目前主要的应用场景：JavaEE 后台开发、Android 客户端的开发、大数据的开发
-
-### 4. Java 环境的搭建
-
-- JDK、JRE、JVM 三者之间的关系
-- JDK 的下载（官网）
-- JDK 的安装
-  - 安装 jdk8 和 jdk17
-- 环境变量的配置（重要）
-
-### 5. HelloWorld 的编写和常见问题的解决（重点）
-
-- 第 1 个程序
-
-```java
-class HelloChina{
-	public static void main(String[] args){
-		System.out.println("hello,world!! 你好，中国！");
-		System.out.print("hello,world!! 你好，中国！");
-		System.out.println("123abc");
-		System.out.println(123 + 1);
-	}
-}
-```
-
-- 测试程序
-
-```java
-public class HelloJava{
-	public static void main(String[] args){
-		System.out.println("hello");
-		System.out.println(10/0);
-	}
-}
-
-
-class HelloShangHai{
-
-}
-
-class HelloBeijing{
-
-}
-```
-
-- 小结
-
-```
-总结：
-1. Java程序编写和执行的过程：
-步骤1：编写。将Java代码编写在.java结尾的源文件中
-步骤2：编译。针对于.java结尾的源文件进行编译操作。 格式：javac 源文件名.java
-步骤3：运行。针对于编译后生成的字节码文件，进行解释运行。 格式： java 字节码文件名
-
-
-2. 针对于步骤1的编写进行说明。
-
-class HelloChina{
-	public static void main(String[] args){
-		System.out.println("hello,world!!你好，中国！");
-	}
-}
-
-其中，
-① class:关键字，表示"类"，后面跟着类名。
-② main()方法的格式是固定的。务必记住！表示程序的入口
-  public static void main(String[] args)  
-
-如果非要有些变化的话，只能变化String[] args结构。可以写成：方式1：String args[]   方式2：String[] a
-
-args:全程是arguments，简写成args
-
-③ Java程序，是严格区分大小写的。
-
-④ 从控制台输出数据的操作：
-System.out.println() : 输出数据之后，会换行。
-System.out.print() : 输出数据之后，不会换行。
-
-
-⑤ 每一行执行语句必须以;结束。
-
-
-3. 针对于步骤2的编译进行说明。
-
-① 如果编译不通过。可以考虑的问题：
-问题1：查看编译的文件名、文件路径是否书写错误
-问题2：查看代码中是否存在语法问题。如果存在，就可能导致编译不通过。
-
-② 编译以后，会生成1个或多个字节码文件。每一个字节码文件对应一个Java类，并且字节码文件名与类名相同。
-
-
-4. 针对于步骤3运行进行说明。
-
-① 我们是针对于字节码文件对应的Java类进行解释运行的。
-要注意区分大小写！
-
-② 如果运行不通过。可以考虑的问题：
-问题1：查看解释运行的的类名、字节码文件路径是否书写错误
-问题2：可能存在运行时异常。（放到第9章中具体讲解）
-
-
-5. 一个源文件中可以声明多个类，但是最多只能有一个类使用public进行声明。
-且要求声明为public的类的类名与源文件名相同。
-```
-
-### 6. 注释的使用
-
-```java
-/*
-这是多行注释。
-
-我们可以声明多行注释的信息！
-
-
-1. Java 中的注释的种类：
-单行注释、多行注释、文档注释（Java 特有）
-
-2. 单行注释、多行注释的作用：
-① 对程序中的代码进行解释说明
-② 对程序进行调试
-
-3. 注意：
-① 单行注释和多行注释中声明的信息，不参与编译。换句话说，编译以后声明的字节码文件中不包含单行注释和
-多行注释中的信息。
-② 多行注释不能嵌套使用
-
-4. 文档注释:
-文档注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。
-
-*/
-/**
-这是我的第一个 Java 程序。很开森！^_^
-
-@author shkstart
-@version 1.0
-
-*/
-public class CommentTest{
-	/**
-	这是 main() 方法。格式是固定的。(文档注释)
-	*/
-	/*
-	这是 main() 方法。格式是固定的。(多行注释)
-	*/
-	public static void main(String[] args){
-		//这是输出语句
-		System.out.println("hello,world!!");
-		//System.out.println("hello,world!!")
-	}
-}
-```
-
-### 7. API 文档
-
-### 8. 练习
-
-- 练习 1
-
-```java
-class PersonalInfo{
-	public static void main(String[] args) {
-	    System.out.println("姓名：康师傅");
-		System.out.println(); //换行的操作
-		System.out.println("性别：男");
-		System.out.println("家庭住址：北京程序员聚集地：回龙观");
-	}
-}
-```
-
-- 练习 2
-
-```java
-class StarPrintTest {
-	public static void main(String[] args) {
-		System.out.println("*    *");
-		System.out.println("*\t\t*");
-		System.out.println("*\n\n*");
-	}
-}
-```
-
-## 二、企业真题
-
-### 1.一个”.java”源文件中是否可以包括多个类？有什么限制 (明*数据)
-
-是！
-
-一个源文件中可以声明多个类，但是最多只能有一个类使用 public 进行声明。
-且要求声明为 public 的类的类名与源文件名相同。
-
-### 2.Java 的优势（阿**巴）
-
-- 跨平台型
-- 安全性高
-- 简单性
-- 高性能
-- 面向对象性
-- 健壮性
-
-### 3.常用的几个命令行操作都有哪些？(至少 4 个)（北京数字**）
-
-略
-
-### 4.Java 中是否存在内存溢出、内存泄漏？如何解决？举例说明（拼*多）
-
-存在！
-
-不能举例。
-
-### 5. 如何看待 Java 是一门半编译半解释型的语言（携*）
-
-![image-20230426100649850](./assets/image-20230426100649850.png)
Index: src/java/javase review/03.随堂复习与企业真题（流程控制语句）.md
===================================================================
diff --git a/src/java/javase review/03.随堂复习与企业真题（流程控制语句）.md b/src/java/javase review/03.随堂复习与企业真题（流程控制语句）.md
deleted file mode 100644
--- a/src/java/javase review/03.随堂复习与企业真题（流程控制语句）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,1588 +0,0 @@
----
-order: 3
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（流程控制语句）
-
-***
-
-## 一、随堂复习
-
-### 1.1（了解）流程控制结构
-
-- 顺序结构
-- 分支结构
-  - if-else
-  - switch-case
-- 循环结构
-  - for
-  - while
-  - do-while
-
-### 1.2 分支结构之 1：if-else 
-
-- 在程序中，凡是遇到了需要使用分支结构的地方，都可以考虑使用 if-else。
-- if-else 嵌套的练习多关注
-
-#### 基本语法
-
-```JAVA
-/*
-分支结构1：if-else条件判断结构
-
-1. 格式
-格式1：
-if(条件表达式)｛
-  	语句块;
-｝
-
-格式2："二选一"
-if(条件表达式) { 
-  	语句块1;
-}else{
-  	语句块2;
-}
-
-格式3："多选一"
-if (条件表达式1) {
-  	语句块1;
-} else if (条件表达式2) {
-  	语句块2;
-}
-...
-}else if (条件表达式n) {
- 	语句块n;
-} else {
-  	语句块n+1;
-}
-
-
-*/
-class IfElseTest {
-	public static void main(String[] args) {
-		
-		/*
-		案例1：成年人心率的正常范围是每分钟60-100次。体检时，
-		如果心率不在此范围内，则提示需要做进一步的检查。
-		*/
-		int heartBeats = 89;
-		//错误的写法：if(60 <= heartBeats <= 100){
-
-		if(heartBeats < 60 || heartBeats > 100){
-			System.out.println("你需要做进一步的检查");
-		}
-
-		System.out.println("体检结束");
-
-		//**********************************
-		/*
-		案例2：定义一个整数，判定是偶数还是奇数    
-		*/
-		int num = 13;
-		if(num % 2 == 0){
-			System.out.println(num + "是偶数");
-		}else{
-			System.out.println(num + "是奇数");
-		}
-	}
-}
-
-```
-
-
-
-#### 案例
-
-```java
-/*
-岳小鹏参加 Java 考试，他和父亲岳不群达成承诺：
-如果：
-成绩为 100 分时，奖励一辆跑车；
-成绩为 (80，99] 时，奖励一辆山地自行车；
-当成绩为 [60,80] 时，奖励环球影城一日游；
-其它时，胖揍一顿。
-
-说明：默认成绩是在 [0,100] 范围内
-
-结论：
-1. 如果多个条件表达式之间没有交集（理解是互斥关系），则哪个条件表达式声明在上面，哪个声明在下面都可以。
-   如果多个条件表达式之间是包含关系，则需要将范围小的条件表达式声明在范围大的条件表达式的上面。否则，范围小的条件表达式不可能被执行。
-
-
-*/
-class IfElseTest1 {
-	public static void main(String[] args) {
-		
-		int score = 61;
-
-		//方式 1：
-		/*
-		if(score == 100){
-			System.out.println("奖励一辆跑车");
-		}else if(score > 80 && score <= 99){
-			System.out.println("奖励一辆山地自行车");
-		}else if(score >= 60 && score <= 80){
-			System.out.println("奖励环球影城一日游");
-		}else{
-			System.out.println("胖揍一顿");
-		}
-		*/
-		
-		//方式 2：
-		score = 88;
-
-		if(score == 100){
-			System.out.println("奖励一辆跑车");
-		}else if(score > 80){
-			System.out.println("奖励一辆山地自行车");
-		}else if(score >= 60){
-			System.out.println("奖励环球影城一日游");
-		}else{
-			System.out.println("胖揍一顿");
-		}
-
-		//特别的：
-		if(score == 100){
-			System.out.println("奖励一辆跑车");
-		}else if(score > 80){
-			System.out.println("奖励一辆山地自行车");
-		}else if(score >= 60){
-			System.out.println("奖励环球影城一日游");
-		}
-		/*else{
-			System.out.println("胖揍一顿");
-		}
-		*/
-		
-	}
-}
-
-```
-
-```java
-/*
-测试 if-else 的嵌套使用
-
-案例：
-由键盘输入三个整数分别存入变量 num1、num2、num3，对它们进行排序 (使用 if-else if-else)，并且从小到大输出。
-
-拓展：你能实现从大到小顺序的排列吗？
-
-1. 从开发经验上讲，没有写过超过三层的嵌套 if-else 结构。
-2. 如果 if-else 中的执行语句块中只有一行执行语句，则此执行语句所在的一对{}可以省略。但是，不建议省略
-*/
-class IfElseTest2 {
-	public static void main(String[] args) {
-		
-		int num1 = 30;
-		int num2 = 21;
-		int num3 = 44;
-
-		//int num1 = 30,num2 = 21,num3 = 44;
-
-		if(num1 >= num2){
-			if(num3 >= num1)
-				System.out.println(num2 + "," + num1 + "," + num3);
-			else if(num3 <= num2)
-				System.out.println(num3 + "," + num2 + "," + num1);
-			else
-				System.out.println(num2 + "," + num3 + "," + num1);	
-				//System.out.println(num2 + "," + num3 + "," + num1);	
-				
-		}else{ // num1 < num2
-			if(num3 >= num2){
-				System.out.println(num1 + "," + num2 + "," + num3);
-			}else if(num3 <= num1){
-				System.out.println(num3 + "," + num1 + "," + num2);
-			}else{
-				System.out.println(num1 + "," + num3 + "," + num2);
-			}
-		}
-
-	}
-}
-
-```
-
-
-
-### 1.3 分支结构之 2：switch-case
-
-- 在特殊的场景下，分支结构可以考虑使用 switch-case
-  - 指定的数据类型：byte \ short \ char \ int ; 枚举类（jdk5.0）\ String (jdk7.0)
-  - 可以考虑的常量值有限且取值情况不多。
-
-- 特别之处：case 穿透。
-- 在能使用 switch-case 的情况下，推荐使用 switch-case，因为比 if-else 效率稍高
-
-#### 基本语法
-
-```java
-/*
-分支结构之 switch-case 的使用
-
-1. 语法格式
-
-switch(表达式){
-	
-	case 常量 1:
-		//执行语句 1
-		//break;
-	case 常量 2:
-		//执行语句 2
-		//break;
-	...
-	default:
-		//执行语句 2
-		//break;
-}
-
-2.执行过程：
-根据表达式中的值，依次匹配 case 语句。一旦与某一个 case 中的常量相等，那么就执行此 case 中的执行语句。
-执行完此执行语句之后，
-		情况 1：遇到 break，则执行 break 后，跳出当前的 switch-case 结构
-		情况 2：没有遇到 break，则继续执行其后的 case 中的执行语句。 ---> case 穿透
-				...
-			   直到遇到 break 或者执行完所有的 case 及 default 中的语句，退出当前的 switch-case 结构
-
-3. 说明：
-① switch 中的表达式只能是特定的数据类型。如下：byte \ short \ char \ int \ 枚举 (JDK5.0 新增) \ String(JDK7.0 新增)
-② case 后都是跟的常量，使用表达式与这些常量做相等的判断，不能进行范围的判断。
-③ 开发中，使用 switch-case 时，通常 case 匹配的情况都有限。
-④ break:可以使用在 switch-case 中。一旦执行此 break 关键字，就跳出当前的 switch-case 结构
-⑤ default：类似于 if-else 中的 else 结构。
-           default 是可选的，而且位置是灵活的。
-
-4. switch-case 与 if-else 之间的转换
-① 开发中凡是可以使用 switch-case 结构的场景，都可以改写为 if-else。反之，不成立
-② 开发中，如果一个具体问题既可以使用 switch-case，又可以使用 if-else 的时候，推荐使用 switch-case。
-  为什么？switch-case 相较于 if-else 效率稍高。
-
-*/
-class SwitchCaseTest{
-	public static void main(String[] args){
-		
-		int num = 1;
-		switch(num){
-			
-			case 0:
-				System.out.println("zero");
-				break; 
-			case 1:
-				System.out.println("one");
-				break; //结束当前的 switch-case 结构
-			case 2:
-				System.out.println("two");
-				break; 
-			case 3:
-				System.out.println("three");
-				break; 
-			default:
-				System.out.println("other");
-				//break; 
-		}
-
-		//另例：
-		String season = "summer";
-        switch (season) {
-            case "spring":
-                System.out.println("春暖花开");
-                break;
-            case "summer":
-                System.out.println("夏日炎炎");
-                break;
-            case "autumn":
-                System.out.println("秋高气爽");
-                break;
-            case "winter":
-                System.out.println("冬雪皑皑");
-                break;
-            /*default:
-                System.out.println("季节输入有误");
-                break;
-			*/
-        }
-
-		//错误的例子：编译不通过
-		/*
-		int number = 20;
-		switch(number){
-			case number > 0:
-				System.out.println("正数");
-                break;
-			case number < 0:
-				System.out.println("负数");
-                break;
-			default:
-				System.out.println("零");
-                break;
-		}
-		*/
-	}
-}
-```
-
-
-
-#### 案例
-
-```java
-/*
-案例 3：使用 switch-case 实现：对学生成绩大于 60 分的，输出“合格”。低于 60 分的，输出“不合格”。
-
-*/
-class SwitchCaseTest1 {
-	public static void main(String[] args) {
-		//定义一个学生成绩的变量
-		int score = 78;
-
-		//根据需求，进行分支
-		//方式 1：
-		/*
-		switch(score){
-			case 0:
-				System.out.println("不及格");
-				break;
-			case 1:
-				System.out.println("不及格");
-				break;
-			//...
-			
-			case 100:
-				System.out.println("及格");
-				break;
-			default:
-				System.out.println("成绩输入有误");
-				break;
-		
-		}
-		*/
-		//方式 2：体会 case 穿透
-		switch(score / 10){
-			case 0:
-			case 1:
-			case 2:
-			case 3:
-			case 4:
-			case 5:
-				System.out.println("不及格");
-				break;
-			case 6:
-			case 7:
-			case 8:
-			case 9:
-			case 10:
-				System.out.println("及格");
-				break;
-			default:
-				System.out.println("成绩输入有误");
-				break;
-		}
-
-		//方式 3：
-		switch(score / 60){
-			case 0:
-				System.out.println("不及格");
-				break;
-			case 1:
-				System.out.println("及格");
-				break;
-			default:
-				System.out.println("成绩输入有误");
-				break;
-		}
-	}
-}
-
-```
-
-```java
-/*
-案例：编写程序：从键盘上输入 2023 年的“month”和“day”，要求通过程序输出输入的日期为 2023 年的第几天。
-*/
-import java.util.Scanner;
-
-class SwitchCaseTest2 {
-	public static void main(String[] args) {
-		//1.使用 Scanner，从键盘获取 2023 年的 month、day
-		Scanner input = new Scanner(System.in);
-
-		System.out.println("请输入 2023 年的月份：");
-		int month = input.nextInt();//阻塞式方法
-
-		System.out.println("请输入 2023 年的天：");
-		int day = input.nextInt();
-
-		//假设用户输入的数据是合法的。后期我们在开发中，使用正则表达式进行校验。
-
-		//2. 使用 switch-case 实现分支结构
-		int sumDays = 0;//记录总天数
-		//方式 1：不推荐。存在数据的冗余
-		/*
-		switch(month){
-			case 1:
-				sumDays = day;
-				break;
-			case 2:
-				sumDays = 31 + day;
-				break;
-			case 3:
-				sumDays = 31 + 28 + day;
-				break;
-			case 4:
-				sumDays = 31 + 28 + 31 + day;
-				break;
-			//...
-			case 12:
-				sumDays = 31 + 28 + ... + 30 + day;
-				break;
-		
-		}
-		*/
-		//方式 2：
-		switch(month){
-			case 12:
-				sumDays += 30;
-			case 11:
-				sumDays += 31;
-			case 10:
-				sumDays += 30;
-			case 9:
-				sumDays += 31;
-			case 8:
-				sumDays += 31;
-			case 7:
-				sumDays += 30;
-			case 6:
-				sumDays += 31;
-			case 5:
-				sumDays += 30;
-			case 4:
-				sumDays += 31;
-			case 3:
-				sumDays += 28; //28:2 月份的总天数
-			case 2:
-				sumDays += 31; //31:1 月份的总天数
-			case 1:
-				sumDays += day;
-				//break;
-		}
-		
-
-		System.out.println("2023 年" + month + "月" + day + "日是当前的第" + sumDays + "天");
-		
-		
-		input.close();//为了防止内存泄漏
-	}
-}
-
-```
-
-
-
-### 1.4 循环结构之 1：for
-
-- 凡是循环结构，都有 4 个要素：①初始化条件 ②循环条件（是 boolean 类型） ③ 循环体 ④ 迭代条件
-- 应用场景：有明确的遍历的次数。for(int i = 1;i <= 100;i++)
-
-#### 基本语法
-
-```java
-/*
-循环结构之一：for 循环
-
-1. Java 中规范了 3 种循环结构：for、while、do-while
-2. 凡是循环结构，就一定会有 4 个要素：
-① 初始化条件
-② 循环条件 ---> 一定是 boolean 类型的变量或表达式
-③ 循环体
-④ 迭代部分
-
-3. for 循环的格式
-
-for(①;②;④){
-	③
-}
-
-执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②
-
-*/
-class ForTest {
-	public static void main(String[] args) {
-		//需求 1：题目：输出 5 行 HelloWorld
-		/*
-		System.out.println("HelloWorld");
-		System.out.println("HelloWorld");
-		System.out.println("HelloWorld");
-		System.out.println("HelloWorld");
-		System.out.println("HelloWorld");
-		*/
-
-		for(int i = 1;i <= 50;i++){
-			System.out.println("HelloWorld");
-		}
-		
-		//此时编译不通过。因为 i 已经出了其作用域范围。
-		//System.out.println(i);
-
-		//需求 2：
-		int num = 1;
-        for(System.out.print("a");num < 3;System.out.print("c"),num++){
-            System.out.print("b");
-
-        }
-
-		//输出结果：abcbc
-
-		System.out.println();//换行
-
-		//需求 3：遍历 1-100 以内的偶数，并获取偶数的个数，获取所有的偶数的和
-		int count = 0;//记录偶数的个数
-
-		int sum = 0;//记录所有偶数的和
-
-		for(int i = 1;i <= 100;i++){
-
-			if(i % 2 == 0){
-				System.out.println(i);
-				count++;
-				sum += i; //sum = sum + i;
-			}	
-		}
-
-		System.out.println("偶数的个数为：" + count);
-		System.out.println("偶数的总和为：" + sum);
-		
-	}
-}
-
-```
-
-
-
-#### 案例
-
-```java
-/*
-题目：输出所有的水仙花数，所谓水仙花数是指一个 3 位数，其各个位上数字立方和等于其本身。
-例如：153 = 1*1*1 + 3*3*3 + 5*5*5
-*/
-class ForTest1 {
-	public static void main(String[] args) {
-		
-		//遍历所有的 3 位数
-		for(int i = 100;i <= 999;i++){
-			
-			//针对于每一个三位数 i，获取其各个位上数值
-			int ge = i % 10;
-			int shi = i / 10 % 10;  //或 int shi = i % 100 / 10
-			int bai = i / 100;
-
-			//判断是否满足水仙花数的规则
-			if(i == ge * ge * ge + shi * shi * shi + bai * bai * bai){
-				System.out.println(i);
-			}
-
-		}
-	}
-}
-
-```
-
-```java
-/*
-案例：输入两个正整数 m 和 n，求其最大公约数和最小公倍数。
-
-比如：12 和 20 的最大公约数是 4，最小公倍数是 60。
-
-约数：12 为例，约数有 1,2,3,4,6,12
-      20 为例，约数有 1,2,4,5,10,20
-
-倍数：12 为例，倍数有 12,24,36,48,60,72,....
-      20 为例，倍数有 20,40,60,80,....
-
-
-说明：
-1. 我们可以在循环结构中使用 break。一旦执行 break，就跳出（或结束）当前循环结构。
-2. 如何结束一个循环结构？
-	方式 1：循环条件不满足。（即循环条件执行完以后是 false）
-	方式 2：在循环体中执行了 break
-
-*/
-class ForTest2 {
-	public static void main(String[] args) {
-
-		int m = 12;
-		int n = 20;
-
-		//获取 m 和 n 中的较小值
-		int min = (m < n)? m : n;
-
-		//需求 1：最大公约数
-		//方式 1：
-		int result = 1;
-		for(int i = 1;i <= min;i++){
-			if(m % i == 0 && n % i == 0){
-				//System.out.println(i);
-				result = i;
-			}
-
-		}
-
-		System.out.println(result);
-
-		//方式 2：推荐
-		for(int i = min;i >= 1;i--){
-			if(m % i == 0 && n % i == 0){
-				System.out.println("最大公约数为：" + i);
-				break;//一旦执行，就跳出当前循环结构。
-			}
-		}
-
-		//需求 2：最小公倍数
-		int max = (m > n)? m : n;
-		for(int i = max;i <= m * n;i++){
-			if(i % m == 0 && i % n == 0){
-				System.out.println("最小公倍数为：" + i);
-				break;
-			}
-		}
-	}
-}
-
-```
-
-
-
-### 1.5 循环结构之 2：while
-
-- 应用场景：没有明确的遍历次数。
-
-#### 基本语法
-
-```java
-/*
-循环结构之一：while 循环
-
-
-1. 凡是循环结构，就一定会有 4 个要素：
-① 初始化条件
-② 循环条件 ---> 一定是 boolean 类型的变量或表达式
-③ 循环体
-④ 迭代部分
-
-2.while 的格式
-
-①
-while(②){
-	③
-	④
-}
-
-3.执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②
-
-4. for 循环与 while 循环可以相互转换！
-
-5. for 循环和 while 循环的小区别：初始化条件的作用域范围不同。while 循环中的初始化条件在 while 循环结束后，依然有效。
-*/
-class WhileTest {
-	public static void main(String[] args) {
-		
-		//需求 1：遍历 50 次 HelloWorld
-		int i = 1;
-		while(i <= 50){
-			System.out.println("HelloWorld");
-			i++;//一定要小心！不要丢了
-		}
-
-		//需求 2：遍历 1-100 以内的偶数，并获取偶数的个数，获取所有的偶数的和
-		int j = 1;
-
-		int count = 0;//记录偶数的个数
-		int sum = 0;//记录偶数的总和
-		while(j <= 100){
-			if(j % 2 == 0){
-				System.out.println(j);
-				count++;
-				sum += j;
-			}
-			j++;
-		}
-
-		System.out.println("偶数的个数为：" + count);
-		System.out.println("偶数的总和为：" + sum);
-	}
-}
-
-```
-
-
-
-#### 案例
-
-```java
-/*
-随机生成一个 100 以内的数，猜这个随机数是多少？
-
-从键盘输入数，如果大了，提示大了；如果小了，提示小了；如果对了，就不再猜了，并统计一共猜了多少次。
-
-提示：生成一个 [a,b] 范围的随机数的方式：(int)(Math.random() * (b - a + 1) + a)
-*/
-import java.util.Scanner;
-class WhileTest1 {
-	public static void main(String[] args) {
-
-		//1. 生成一个 [1,100] 范围的随机整数
-		int random = (int)(Math.random() * 100) + 1;
-
-		//2. 使用 Scanner，从键盘获取数据
-		Scanner scan = new Scanner(System.in);
-		System.out.print("请输入 1-100 范围的一个整数：");
-		int guess = scan.nextInt();
-
-		//3.声明一个变量，记录猜的次数
-		int guessCount = 1;
-
-		//4. 使用循环结构，进行多次循环的对比和获取数据
-		while(random != guess){
-
-			if(guess > random){
-				System.out.println("你输入的数据大了");
-			}else if(guess < random){
-				System.out.println("你输入的数据小了");
-			}//else{
-			//	break;
-			//}
-			
-			System.out.print("请输入 1-100 范围的一个整数：");
-			guess = scan.nextInt();
-			guessCount++;
-
-		}
-
-		//能结束结束，就意味着 random 和 guess 相等了
-		System.out.println("恭喜你！猜对了！");
-		System.out.println("共猜了" + guessCount + "次");
-		
-		
-		scan.close();
-
-	}
-}
-
-```
-
-```java
-/*
-世界最高山峰是珠穆朗玛峰，它的高度是 8848.86 米，假如我有一张足够大的纸，它的厚度是 0.1 毫米。
-请问，我折叠多少次，可以折成珠穆朗玛峰的高度？
-
-*/
-class WhileTest2 {
-	public static void main(String[] args) {
-		
-		//1. 声明珠峰的高度、纸的默认厚度
-		double paper = 0.1;//单位：毫米
-		double zf = 8848860;//单位：毫米
-		
-
-		//2. 定义一个变量，记录折纸的次数
-		int count = 0;
-
-
-		//3. 通过循环结构，不断调整纸的厚度（当纸的厚度超过珠峰高度时，停止循环）
-		while(paper <= zf){
-			
-			paper *= 2;
-			count++;
-
-		}
-		
-		System.out.println("paper 的高度为：" + (paper / 1000) + ",超过了珠峰的高度" + (zf/1000));
-		System.out.println("共折纸" + count + "次");
-
-
-	}
-}
-
-```
-
-
-
-### 1.6 循环结构之 3：do-while
-
-- 至少会执行一次循环体。
-- 开发中，使用的较少
-
-#### 基本语法
-
-```java
-/*
-循环结构之一：do-while 循环
-
-
-1. 凡是循环结构，就一定会有 4 个要素：
-① 初始化条件
-② 循环条件 ---> 一定是 boolean 类型的变量或表达式
-③ 循环体
-④ 迭代部分
-
-2. do-while 的格式
-
-①
-do{
-	③
-	④
-}while(②);
-
-执行过程：① - ③ - ④ - ② - ③ - ④ - .... - ②
-
-3. 说明：
-1) do-while 循环至少执行一次循环体。
-2) for、while、do-while 循环三者之间是可以相互转换的。
-3) do-while 循环结构，在开发中，相较于 for、while 循环来讲，使用的较少。
-
-*/
-class DoWhileTest {
-	public static void main(String[] args) {
-		
-		//需求：遍历 100 以内的偶数，并输出偶数的个数和总和
-		int i = 1;
-		int count = 0;//记录偶数的个数
-		int sum = 0;//记录偶数的总和
-
-		do{
-			if(i % 2 == 0){
-				System.out.println(i);
-				count++;
-				sum += i;
-			}
-
-			i++;
-
-		}while(i <= 100);
-		
-		System.out.println("偶数的个数为：" + count);
-		System.out.println("偶数的总和为：" + sum);
-
-		//***************************
-		int num1 = 10;
-		while(num1 > 10){
-			System.out.println("while:hello");
-			num1--;
-		}
-
-		int num2 = 10;
-		do{
-			System.out.println("do-while:hello");
-			num2--;
-		}while(num2 > 10);
-	}
-}
-
-```
-
-
-
-#### 案例
-
-```java
-/*
-题目：模拟 ATM 取款
-
-声明变量 balance 并初始化为 0，用以表示银行账户的余额，下面通过 ATM 机程序实现存款，取款等功能。
-
-=========ATM========
-   1、存款
-   2、取款
-   3、显示余额
-   4、退出
-请选择 (1-4)：
-*/
-import java.util.Scanner;
-class DoWhileTest1 {
-	public static void main(String[] args) {
-		
-		//1. 定义 balance 的变量，记录账户余额
-		double balance = 0.0;
-
-		boolean flag = true; //控制循环的结束
-
-		Scanner scan = new Scanner(System.in);//实例化 Scanner
-
-		do{
-			//2. 声明 ATM 取款的界面
-			System.out.println("=========ATM========");
-			System.out.println("   1、存款");
-			System.out.println("   2、取款");
-			System.out.println("   3、显示余额");
-			System.out.println("   4、退出");
-			System.out.print("请选择 (1-4)：");
-
-			//3. 使用 Scanner 获取用户的选择
-			
-			int selection = scan.nextInt();
-			switch(selection){
-				//4. 根据用户的选择，决定执行存款、取款、显示余额、退出的操作
-				case 1:
-					System.out.print("请输入存款的金额：");
-					double money1 = scan.nextDouble();
-					if(money1 > 0){
-						balance += money1;
-					}
-					break;
-				case 2:
-					System.out.print("请输入取款的金额：");
-					double money2 = scan.nextDouble();
-					
-					if(money2 > 0 && money2 <= balance){
-						balance -= money2;
-					}else{
-						System.out.println("输入的数据有误或余额不足");
-					}
-
-
-					break;
-				case 3:
-					System.out.println("账户余额为：" + balance);
-					break;
-				case 4 :
-					flag = false;
-					System.out.println("感谢使用，欢迎下次光临^_^");
-					break;
-				default:
-					System.out.println("输入有误，请重新输入");
-					//break;
-			
-			}
-		
-		
-		}while(flag);
-
-		
-		//关闭资源
-		scan.close();
-
-		
-
-	}
-}
-
-```
-
-
-
-### 1.7“无限”循环
-
-#### 基本语法
-
-```java
-/*
-
-"无限"循环结构的使用
-
-1. 格式：while(true)  或  for(;;)
-
-2.开发中，有时并不确定需要循环多少次，需要根据循环体内部某些条件，来控制循环的结束（使用 break）。
-
-3. 如果此循环结构不能终止，则构成了死循环！开发中要避免出现死循环。
-*/
-class ForWhileTest {
-	public static void main(String[] args) {
-		/*
-		for(;;){//while(true){
-			System.out.println("I love you!");
-		}
-		*/
-		
-		//死循环的后面不能有执行语句。
-		//System.out.println("end");
-
-		
-	}
-}
-
-```
-
-#### 案例
-
-```java
-/*
-案例：从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为 0 时结束程序。
-
-*/
-import java.util.Scanner;
-class ForWhileTest1 {
-	public static void main(String[] args) {
-		
-		Scanner scan = new Scanner(System.in);
-
-		int positiveCount = 0;//记录正数的个数
-		int negativeCount = 0;//记录负数的个数
-		
-		for(;;){//while(true){
-			System.out.print("请输入一个整数 (输入为 0 时结束程序)：");
-			int num = scan.nextInt(); //获取用户输入的整数
-
-			if(num > 0){ //正数
-				positiveCount++;
-			}else if(num < 0){ //负数
-				negativeCount++;
-			}else{ //零
-				System.out.println("程序结束");
-				break;
-			}
-		
-		
-		}
-		
-		System.out.println("正数的个数为：" + positiveCount);
-		System.out.println("负数的个数为：" + negativeCount);
-
-
-		scan.close();
-	}
-}
-
-```
-
-
-
-### 1.8 嵌套循环
-
-#### 基本语法
-
-```java
-/*
-嵌套循环的使用
-
-1. 嵌套循环：是指一个循环结构 A 的循环体是另一个循环结构 B。
-- 外层循环：循环结构 A
-- 内层循环：循环结构 B
-
-2. 说明：
-1）内层循环充当了外层循环的循环体。
-2）对于两层嵌套循环来说，外层循环控制行数，内层循环控制列数。
-3）举例：外层循环执行 m 次，内层循环执行 n 次，则内层循环的循环体共执行 m * n 次
-4）实际开发中，我们不会出现三层以上的循环结构，三层的循环结构都很少见。
-*/
-class ForForTest {
-	public static void main(String[] args) {
-		
-		//******
-		for(int i = 1;i <= 6;i++){
-			System.out.print('*');
-		}
-
-		System.out.println("\n##################");
-		
-		/*
-
-		******
-		******
-		******
-		******
-		******
-
-		*/
-		
-		for(int j = 1;j <= 5;j++){
-
-			for(int i = 1;i <= 6;i++){
-				System.out.print('*');
-			}
-
-			System.out.println();
-		}
-		
-		/*
-						i(第几行)		j(每一行中*的个数)
-		*				1				1
-		**				2				2
-		***				3				3
-		****			4				4
-		*****			5				5
-
-		*/
-		for(int i = 1;i <= 5;i++){
-			
-			for(int j = 1;j <= i;j++){
-				System.out.print("*");
-			}
-			System.out.println();
-		
-		}
-
-		/*
-						i(第几行)		j(每一行中*的个数)		i + j = 7 --> j = 7 - i
-		******			1				6
-		*****			2				5
-		****			3				4
-		***				4				3
-		**				5				2
-		*				6				1
-		
-		*/
-
-		for(int i = 1;i <= 6;i++){
-
-			for(int j = 1;j <= 7 - i;j++){
-				System.out.print("*");
-			}
-			
-			System.out.println();
-		}
-
-	/*
-						i(第几行)	j(每一行中 - 的个数)		k(每一行中*的个数)    2*i + j = 10 --->j = 10 - 2*i
---------*				1				8				1                k = 2 * i - 1
-------* * *				2				6				3
-----* * * * *			3				4				5
---* * * * * * *			4				2				7
-* * * * * * * * *		5				0				9
-
-
-
-  * * * * * * * 
-    * * * * * 
-      * * * 
-        * 
-		
-	*/
-
-	//上半部分
-	for(int i = 1;i <= 5;i++){
-		// -
-		for(int j = 1;j <= 10 - 2*i;j++){
-			System.out.print("-");
-		}
-
-
-		// *
-		for(int k = 1;k <= 2 * i - 1;k++){
-			System.out.print("* ");
-		}
-
-		System.out.println();
-	}
-
-	}
-}
-
-```
-
-#### 案例
-
-```java
-/*
-练习：九九乘法表
-
-*/
-class NineNineTable {
-	public static void main(String[] args) {
-		
-		for(int i = 1;i <= 9;i++){
-			
-			for(int j = 1;j <= i;j++){
-				
-				System.out.print(i + "*" + j + "=" + i * j + "\t");
-			
-			}
-
-			System.out.println();
-		
-		}
-
-	}
-}
-
-```
-
-
-
-### 1.9 关键字 break、continue
-
-- break 在开发中常用；而 continue 较少使用
-- 笔试题：break 和 continue 的区别。
-
-#### 基本语法
-
-```java
-/*
-1. break 和 continue 关键字的使用
-
-				使用范围			在循环结构中的作用					相同点
-break:			switch-case
-				循环结构中			结束（或跳出）当前循环结构			在此关键字的后面不能声明执行语句。
-
-continue:		循环结构中			结束（或跳出）当次循环				在此关键字的后面不能声明执行语句。
-
-		
-2. 了解带标签的 break 和 continue 的使用
-
-3. 开发中，break 的使用频率要远高于 continue。
-*/
-class BreakContinueTest{
-	public static void main(String[] args){
-		
-		for(int i = 1;i <= 10;i++){
-
-			if(i % 4 == 0){
-				//break;
-				continue;
-				
-				//编译不通过
-				//System.out.println("今晚上迪丽热巴要约我！");
-			}
-			
-			System.out.print(i);
-		
-		}
-		
-		System.out.println();
-
-		//*****************************
-		label:for(int j = 1;j <= 4;j++){
-		
-			for(int i = 1;i <= 10;i++){
-
-				if(i % 4 == 0){
-					//break;
-					//continue;	
-
-					//了解
-					//break label;
-					//continue label;
-				}
-				
-				System.out.print(i);			
-			}
-			System.out.println();
-		
-		}
-	
-	}
-}
-```
-
-
-
-### 1.10 项目 1：谷粒记账软件
-
-- 特点 1：代码量更大，逻辑更复杂  ---> 推荐大家一定写一写，而且多写几遍。
-- 特点 2：内部不包含新的知识点。 ---> 不太着急写。
-
-### 1.11 Scanner 类的使用
-
-#### 基本语法
-
-```java
-
-
-/*
-如何从键盘获取不同类型（基本数据类型、String 类型）的变量：使用 Scanner 类。
-
-1. 使用 Scanner 获取不同类型数据的步骤
-步骤 1：导包 import java.util.Scanner;
-步骤 2：提供（或创建）一个 Scanner 类的实例
-步骤 3：调用 Scanner 类中的方法，获取指定类型的变量 (nextXxx())
-步骤 4：关闭资源，调用 Scanner 类的 close()
-
-2. 案例：小明注册某交友网站，要求录入个人相关信息。如下：
-
-请输入你的网名、你的年龄、你的体重、你是否单身、你的性别等情况。
-
-
-3. Scanner 类中提供了获取 byte \ short \ int \ long \float \double \boolean \ String 类型变量的方法。
-   注意，没有提供获取 char 类型变量的方法。需要使用 next().charAt(0)
-*/
-//步骤 1：导包 import java.util.Scanner;
-import java.util.Scanner;
-class ScannerTest {
-	public static void main(String[] args) {
-		
-		//步骤 2：提供（或创建）一个 Scanner 类的实例
-		Scanner scan = new Scanner(System.in);
-		
-		System.out.println("欢迎光临你来我往交友网");
-		System.out.print("请输入你的网名：");
-		//步骤 3：调用 Scanner 类中的方法，获取指定类型的变量
-		String name = scan.next();
-
-		System.out.print("请输入你的年龄：");
-		int age = scan.nextInt();
-
-		System.out.print("请输入你的体重：");	
-		double weight = scan.nextDouble();
-
-
-		System.out.print("你是否单身（单身：true;不单身：false）：");
-		boolean isSingle = scan.nextBoolean();
-
-		System.out.print("请输入你的性别 (男\\女)："); 
-		char gender = scan.next().charAt(0);
-
-		System.out.println("网名：" + name + ",年龄：" + age + ",体重：" + weight + ",是否单身：" + isSingle + 
-			",性别：" + gender);
-
-		System.out.println("注册完成，欢迎继续进入体验！");
-
-		//步骤 4：关闭资源，调用 Scanner 类的 close()
-		scan.close();
-	}
-}
-```
-
-#### 案例
-
-```java
-import java.util.Scanner;
-class ScannerExer {
-	public static void main(String[] args) {
-		Scanner scan = new Scanner(System.in);
-
-		System.out.println("请输入你的身高：(cm)");
-		int height = scan.nextInt();
-
-		System.out.println("请输入你的财富：(以千万为单位)");
-		double wealth = scan.nextDouble();
-
-		//关于是否帅问题，我们使用 String 类型接收
-		System.out.println("帅否？(是/否)");
-		String isHandsome = scan.next();
-		
-		//判断
-		if(height >= 180 && wealth >= 1.0 && isHandsome.equals("是")){  //知识点：判断两个字符串是否相等，使用 String 的 equals()
-			System.out.println("我一定要嫁给他!!!");
-		}else if(height >= 180 || wealth >= 1.0 || isHandsome.equals("是")){
-			System.out.println("嫁吧，比上不足，比下有余。");
-		}else{
-			System.out.println("不嫁");
-		}
-		//关闭资源
-		scan.close();
-	}
-}
-
-```
-
-
-
-### 1.12 获取随机数
-
-```java
-/*
-如何获取一个随机数？
-
-1. 可以使用 Java 提供的 API:Math 类的 random() 
-2. random() 调用以后，会返回一个 [0.0,1.0) 范围的 double 型的随机数
-
-3. 需求 1：获取一个 [0,100] 范围的随机整数？
-   需求 2：获取一个 [1,100] 范围的随机整数？
-
-4. 需求：获取一个 [a,b] 范围的随机整数？
-   (int)(Math.random() * (b - a + 1)) + a
-*/
-class RandomTest {
-	public static void main(String[] args) {
-		
-		double d1 = Math.random();
-
-		System.out.println("d1 = " + d1);
-
-
-		int num1 = (int)(Math.random() * 101);  //[0.0,1.0) --> [0.0,101.0) --->[0,100]
-		System.out.println("num1 = " + num1);
-
-		int num2 = (int)(Math.random() * 100) + 1; //[0.0,1.0) --> [0.0,100.0) --->[0,99] ---> [1,100]
-
-
-	}
-}
-
-```
-
-
-
-### 1.13 体会算法的魅力
-
-- 基本实现
-
-```java
-/*
-如何获取一个随机数？
-
-1. 可以使用 Java 提供的 API:Math 类的 random() 
-2. random() 调用以后，会返回一个 [0.0,1.0) 范围的 double 型的随机数
-
-3. 需求 1：获取一个 [0,100] 范围的随机整数？
-   需求 2：获取一个 [1,100] 范围的随机整数？
-
-4. 需求：获取一个 [a,b] 范围的随机整数？
-   (int)(Math.random() * (b - a + 1)) + a
-*/
-class RandomTest {
-	public static void main(String[] args) {
-		
-		double d1 = Math.random();
-
-		System.out.println("d1 = " + d1);
-
-
-		int num1 = (int)(Math.random() * 101);  //[0.0,1.0) --> [0.0,101.0) --->[0,100]
-		System.out.println("num1 = " + num1);
-
-		int num2 = (int)(Math.random() * 100) + 1; //[0.0,1.0) --> [0.0,100.0) --->[0,99] ---> [1,100]
-
-
-	}
-}
-
-```
-
-- 测试性能：方式 1
-
-```java
-/*
-遍历 100000 以内的所有的质数。体会不同的算法实现，其性能的差别
-
-此 PrimeNumberTest1.java 是实现方式 1
-*/
-class PrimeNumberTest1 {
-	public static void main(String[] args) {
-
-		//获取系统当前的时间：
-		long start = System.currentTimeMillis();
-		
-		boolean isFlag = true;
-
-		int count = 0;//记录质数的个数
-
-		for(int i = 2;i <= 100000;i++){ //遍历 100000 以内的自然数
-			
-			
-			//判定 i 是否是质数
-			for(int j = 2;j < i;j++){
-				
-				if(i % j == 0){
-					isFlag = false;
-				}
-			
-			}
-
-			if(isFlag){
-				count++;
-			}
-			
-			//重置 isFlag
-			isFlag = true;
-		}
-
-		//获取系统当前的时间：
-		long end = System.currentTimeMillis();
-
-		System.out.println("质数的总个数为：" + count); //9592
-		System.out.println("花费的时间为：" + (end - start)); //7209
-
-	}
-}
-
-```
-
-- 测试性能：方式 2
-
-```java
-/*
-遍历 100000 以内的所有的质数。体会不同的算法实现，其性能的差别
-
-此 PrimeNumberTest2.java 是方式 2，针对于 PrimeNumberTest1.java 中算法的优化
-*/
-class PrimeNumberTest2 {
-	public static void main(String[] args) {
-
-		//获取系统当前的时间：
-		long start = System.currentTimeMillis();
-		
-		boolean isFlag = true;
-
-		int count = 0;//记录质数的个数
-
-		for(int i = 2;i <= 100000;i++){ //遍历 100000 以内的自然数
-			
-			
-			//判定 i 是否是质数
-			for(int j = 2;j <= Math.sqrt(i);j++){
-				
-				if(i % j == 0){
-					isFlag = false;
-					break;//针对于非质数有效果。
-				}
-			
-			}
-
-			if(isFlag){
-				count++;
-			}
-			
-			//重置 isFlag
-			isFlag = true;
-		}
-
-		//获取系统当前的时间：
-		long end = System.currentTimeMillis();
-
-		System.out.println("质数的总个数为：" + count); //9592
-		System.out.println("花费的时间为：" + (end - start)); //7209 -->加上 break:659 -->加上 Math.sqrt():6
-
-	}
-}
-```
-
-
-
-## 二、企业真题
-
-### 1. break 和 continue 的作用 (智*图)
-
-略
-
-### 2. if 分支语句和 switch 分支语句的异同之处 (智*图)
-
-- if-else 语句优势
-  - if 语句的条件是一个布尔类型值，if 条件表达式为 true 则进入分支，可以用于范围的判断，也可以用于等值的判断，`使用范围更广`。
-  - switch 语句的条件是一个常量值（byte,short,int,char，枚举，String），只能判断某个变量或表达式的结果是否等于某个常量值，`使用场景较狭窄`。
-- switch 语句优势
-  - 当条件是判断某个变量或表达式是否等于某个固定的常量值时，使用 if 和 switch 都可以，习惯上使用 switch 更多。因为`效率稍高`。当条件是区间范围的判断时，只能使用 if 语句。
-  - 使用 switch 可以利用`穿透性`，同时执行多个分支，而 if...else 没有穿透性。
-
-
-
-### 3. 什么时候用语句 if，什么时候选用语句 switch(灵伴*来科技)
-
-同上
-
-### 4. switch 语句中忘写 break 会发生什么 (北京*蓝)
-
-case 穿透
-
-
-
-### 5. Java 支持哪些类型循环 (上海*睿)
-
-- for;while;do-while
-- 增强 for（或 foreach），放到集合中讲解
-
-
-
-### 6. while 和 do while 循环的区别 (国*科技研究院)
-
-- do-while 至少会执行一次。
-
-
-
-
-
-
-
Index: src/java/javase review/12.随堂复习与企业真题（集合框架）.md
===================================================================
diff --git a/src/java/javase review/12.随堂复习与企业真题（集合框架）.md b/src/java/javase review/12.随堂复习与企业真题（集合框架）.md
deleted file mode 100644
--- a/src/java/javase review/12.随堂复习与企业真题（集合框架）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,473 +0,0 @@
----
-order: 12
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（集合框架）
-
-***
-
-## 一、随堂复习
-
-### 1. 数组存储数据方面的特点和弊端
-
-```
-   数组存储多个数据方面的特点：
-   > 数组一旦初始化，其长度就是确定的。
-   > 数组中的多个元素是依次紧密排列的，有序的，可重复的
-   > (优点) 数组一旦初始化完成，其元素的类型就是确定的。不是此类型的元素，就不能添加到此数组中。
-      int[] arr = new int[10];
-      arr[0] = 1;
-      arr[1] = "AA";//编译报错
-
-      Object[] arr1 = new Object[10];
-      arr1[0] = new String();
-      arr1[1] = new Date();
-   > (优点)元素的类型既可以是基本数据类型，也可以是引用数据类型。
-
-   数组存储多个数据方面的弊端：
-   > 数组一旦初始化，其长度就不可变了。
-   > 数组中存储数据特点的单一性。对于无序的、不可重复的场景的多个数据就无能为力了。
-   > 数组中可用的方法、属性都极少。具体的需求，都需要自己来组织相关的代码逻辑。
-   > 针对于数组中元素的删除、插入操作，性能较差。
-```
-
-### 2. 集合框架概述
-
-```
-java.util.Collection:存储一个一个的数据
-    |-----子接口：List:存储有序的、可重复的数据 ("动态"数组)
-           |---- ArrayList(主要实现类)、LinkedList、Vector
-
-    |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)
-           |---- HashSet(主要实现类)、LinkedHashSet、TreeSet
-
-
-java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --> y=f(x),类似于高中的函数)
-    |---- HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties
-```
-
-```
-学习的程度把握：
-层次1：针对于具体特点的多个数据，知道选择相应的适合的接口的主要实现类，会实例化，会调用常用的方法。
-层次2：区分接口中不同的实现类的区别。
-*****************
-层次3：① 针对于常用的实现类，需要熟悉底层的源码 ② 熟悉常见的数据结构 （第14章讲）
-```
-
-### 3. Collection 的常用方法
-
-#### 3.1 常用方法
-
-```
-add(Object obj)
-addAll(Collection coll)
-clear()
-isEmpty()
-size()
-contains(Object obj)
-containsAll(Collection coll)
-retainAll(Collection coll)
-remove(Object obj)
-removeAll(Collection coll)
-hashCode()
-equals()
-toArray()
-**************
-iterator() ---> 引出了迭代器接口
-```
-
-```
-向Collection中添加元素的要求：
-> 要求元素所属的类一定要重写equals()!
-```
-
-```
-集合与数组的相互转换：
-集合 ---> 数组：toArray()
-数组 ---> 集合：调用Arrays的静态方法asList(Object ... objs)，返回一个List
-```
-
-#### 3.2 迭代器接口
-
-- 设计模式的一种
-- 迭代器不负责数据的存储；负责对集合类的遍历
-
-```java
-1. 如何获取迭代器(Iterator)对象？
-Iterator iterator = coll.iterator();
-
-2. 如何实现遍历(代码实现)
-while(iterator.hasNext()){
-    System.out.println(iterator.next()); //next():①指针下移 ② 将下移以后集合位置上的元素返回
-}
-```
-
-
-
-### 4. Collection 的子接口：List
-
-- 常用方法
-
-```java
-小结：
-    增
-        add(Object obj)
-        addAll(Collection coll)
-    删
-        remove(Object obj)
-        remove(int index)
-    改
-        set(int index, Object ele)
-    查
-        get(int index)
-    插
-        add(int index, Object ele)
-        addAll(int index, Collection eles)
-    长度
-        size()
-    遍历
-        iterator() ：使用迭代器进行遍历
-        增强for循环
-        一般的for循环
-```
-
-```
-List及其实现类特点
-java.util.Collection:存储一个一个的数据
-    |-----子接口：List:存储有序的、可重复的数据 ("动态"数组)
-           |---- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储
-                           在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低
-           |---- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议							使用此类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；
-           |---- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储
-
-[面试题] ArrayList、Vector的区别？  ArrayList、LinkedList的区别？
-```
-
-
-
-### 5. Collection 的子接口：Set
-
-- Set 中的常用的方法都是 Collection 中声明的方法，没有新增的方法
-- 常见的实现类的对比
-
-```
-java.util.Collection:存储一个一个的数据
-    |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)
-           |---- HashSet：主要实现类；底层使用的是HashMap，即使用数组+单向链表+红黑树结构进行存储。（jdk8中）
-                |---- LinkedHashSet：是HashSet的子类；在现有的数组+单向链表+红黑树结构的基础上，又添加了
-                                     一组双向链表，用于记录添加元素的先后顺序。即：我们可以按照添加元素的顺									序实现遍历。便于频繁的查询操作。
-           |---- TreeSet：底层使用红黑树存储。可以按照添加的元素的指定的属性的大小顺序进行遍历。
-```
-
-- 难点：Set 中无序性、不可重复性的理解（以 HashSet 及其子类为例说明）
-
-```
->无序性： != 随机性。
-         添加元素的顺序和遍历元素的顺序不一致,是不是就是无序性呢？ No!
-         到底什么是无序性？与添加的元素的位置有关，不像ArrayList一样是依次紧密排列的。
-         这里是根据添加的元素的哈希值，计算的其在数组中的存储位置。此位置不是依次排列的，表现为无序性。
-
->不可重复性：添加到Set中的元素是不能相同的。
-          比较的标准，需要判断hashCode()得到的哈希值以及equals()得到的boolean型的结果。
-          哈希值相同且equals()返回true，则认为元素是相同的。
-```
-
-```
-添加到HashSet/LinkedHashSet中元素的要求:
->要求元素所在的类要重写两个方法：equals() 和 hashCode()。
->同时，要求equals() 和 hashCode()要保持一致性！我们只需要在IDEA中自动生成两个方法的重写即可，即能保证两个方法的一致性。
-```
-
-- 了解 TreeSet 的使用
-
-### 6. Map 接口
-
-- 常用的方法
-
-```
-增：
-    put(Object key,Object value)
-    putAll(Map m)
-删：
-    Object remove(Object key)
-改：
-    put(Object key,Object value)
-    putAll(Map m)
-查：
-    Object get(Object key)
-长度：
-    size()
-遍历：
-   遍历key集：Set keySet()
-   遍历value集：Collection values()
-   遍历entry集：Set entrySet()
-```
-
-- 常用的实现类
-
-```
-java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --> y=f(x),类似于高中的函数)
-    |---- HashMap:主要实现类;线程不安全的，效率高;可以添加null的key和value值;底层使用数组+单向链表+红黑树结构存储（jdk8）
-        |---- LinkedHashMap:是HashMap的子类；在HashMap使用的数据结构的基础上，增加了一对双向链表，用于记录添加的元素的先后顺序，进而我们在遍历元素时，就可以按照添加的顺序显示。开发中，对于频繁的遍历操作，建议使用此类。
-    |---- TreeMap:底层使用红黑树存储;可以按照添加的key-value中的key元素的指定的属性的大小顺序进行遍历。需要考虑使用①自然排序 ②定制排序。
-    |---- Hashtable:古老实现类;线程安全的，效率低;不可以添加null的key或value值;底层使用数组+单向链表结构存储（jdk8）
-        |---- Properties:其key和value都是String类型。常用来处理属性文件。
-
-
-[面试题] 区别HashMap和Hashtable、区别HashMap和LinkedHashMap、HashMap的底层实现（① new HashMap() ② put(key,value)）
-```
-
-```
-HashMap中元素的特点:
-> HashMap中的所有的key彼此之间是不可重复的、无序的。所有的key就构成一个Set集合。--->key所在的类要重写hashCode()和equals()
-> HashMap中的所有的value彼此之间是可重复的、无序的。所有的value就构成一个Collection集合。--->value所在的类要重写equals()
-> HashMap中的一个key-value,就构成了一个entry。
-> HashMap中的所有的entry彼此之间是不可重复的、无序的。所有的entry就构成了一个Set集合。
-```
-
-- （了解）TreeMap 的使用
-
-- （重要）Properties 的使用
-
-  ```java
-  public class PropertiesTest {
-      @Test
-      public void test() throws IOException { //注意：因为设计到流的操作，为了确保流能关闭，建议使用 try-catch-finally
-          //方式 1：数据和代码耦合度高；如果修改的话，需要重写的编译代码、打包发布，繁琐
-          //数据
-  //        String name = "Tom";
-  //        String password = "abc123";
-  
-          //代码：用于操作 name,password
-          //...
-  
-          //方式 2：将数据封装到具体的配置文件中，在程序中读取配置文件中的信息。实现了
-          //数据和代码的解耦；由于我们没有修改代码，就省去了重新编译和打包的过程。
-          File file = new File("info.properties"); //注意，要提前创建好
-  //        System.out.println(file.getAbsolutePath());
-          FileInputStream fis = new FileInputStream(file);
-  
-          Properties pros = new Properties();
-          pros.load(fis); //加载流中的文件中的数据
-  
-          //读取数据
-          String name = pros.getProperty("name");
-          String pwd = pros.getProperty("password");
-  
-          System.out.println(name + ":" + pwd);
-  
-          fis.close();
-      }
-  
-  }
-  ```
-
-### 7. Collections 工具类的使用
-
-```
-区分Collection 和 Collections
-Collection：集合框架中的用于存储一个一个元素的接口，又分为List和Set等子接口。
-Collections：用于操作集合框架的一个工具类。此时的集合框架包括：Set、List、Map
-```
-
-- 熟悉常用的 Collections 中的方法即可。
-
-
-## 二、企业真题
-
-### 2.1 集合概述
-
-#### 1. List，Set，Map 是否继承自 collection 接口？（北京中\*译咨询、思\*贸易）
-
-Map 不是。
-
-#### 2. 说说 List,Set,Map 三者的区别 (民*银行)
-
-```
-类似问题：
-> Map与Set、List的区别（纬*）
-```
-
-略
-
-#### 3. 写出 list、map、set 接口的实现类，并说出其特点（华**为）
-
-```
-类似问题：
-> 集合有哪些， 各自有哪些特点， 各自的API有哪些？（湖**利软件）
-> List Map Set三个接口在存储元素时个有什么特点（*软）
-```
-
-略
-
-#### 4. 常见集合类的区别和适用场景（饿**）
-
-略
-
-#### 5. 集合的父类是谁？哪些安全的？（北京中**信）
-
-略。不安全：ArrayList、HashMap、HashSet；安全：Vector、Hashtable
-
-#### 6. 集合说一下哪些是线程不安全的（*科软）
-
-略
-
-#### 7. 遍历集合的方式有哪些？（恒*电子）
-
-- 迭代器 Iterator 用来遍历 Collection，不能用来遍历 Map！
-
-- 增强 for
-- 一般的 for：可以用来遍历 List
-
-### 2.2 List 接口
-
-#### 1. List 下面有哪些实现（软**力）
-
-略
-
-#### 2. ArrayList 与 LinkedList 区别？(O\*\*O、滴\*、汇\*天下、拓\*软件、博纳\*\*软件、上海*进天下，北京永生**信息、\*联、在\*途游)
-
-```
-类似问题：
-> ArrayList跟LinkedList的区别详细说出？（阿*校招、*东）
-```
-
-略。补充上第 14 章中的源码（底层的数据结构）
-
-#### 3. ArrayList 与 Vector 区别呢？为什么要用 ArrayList 取代 Vector 呢？(湖**利软件)
-
-Vector 效率低。
-
-#### 4. Java.util.ArrayList 常用的方法有哪些？（华**为）
-
-略
-
-#### 5. Arraylist 是有序还是无序？为什么？（蜜*信息）
-
-有序；底层使用数组：Object[]
-
-### 2.3 Set 接口
-
-#### 1. Set 集合有哪些实现类，分别有什么特点？（拓*软件）
-
-```
-类似问题：
-> Set的实现类有哪些？（博*科技）
-```
-
-略
-
-#### 2. List 集合和 Set 集合的区别？（亚\*科技、\*海*翼科技，\*华电\*系统，达\*贷）
-
-略
-
-#### 3. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用==还是 equals()? 它们有何区别？（鸿*网络）
-
-```
-类似问题：
-> 1.HashSet如何检查重复(创*科技)
-> 3.Set使用哪个区分不能重复的元素的？（北京创**荣信息）
-```
-
-hashCode()  、 equals()
-
-#### 4. TreeSet 两种排序方式在使用的时候怎么起作用？（拓*软件）
-
-在添加新的元素时，需要调用 compareTo() 或 compare()
-
-#### 5. TreeSet 的数据结构（*米）
-
-红黑树
-
-### 2.4 Map 接口
-
-#### 1. 说一下 Java 的集合 Map 有哪些 Map？（奥*医药）
-
-略
-
-#### 2. final 怎么用，修饰 Map 可以继续添加数据吗？（*深蓝）
-
-final HashMap map = new HashMap();
-
-map.put("AA",123);
-
-可以！
-
-#### 3. Set 和 Map 的比较（亚*科技）
-
-HashSet 底层就是 HashMap
-
-LinkedHashSet 底层就是 LinkedHashMap
-
-TreeSet 底层就是 TreeMap
-
-#### 4. HashMap 说一下，线程安全吗？（*米）
-
-```
-类似问题：
-> HashMap为什么线程不安全？（微*银行）
-> HashMap是线程安全的吗？为什么不安全？（*团、*东、顺*）
-```
-
-不安全
-
-#### 5. HashMap 和 Hashbable 的区别？(银\*数据、阿\*\*巴芝麻信用、\*众银行、爱\*信、杭州*智公司)
-
-```
-类似问题：
-> HashMap 和 HashTable 有什么区别，以及如何使用，以及他的一些方法？（阿*校招、*东、*度校招、顺*）
-```
-
-略
-
-#### 6. Hashtable 是怎么实现的，为什么线程安全？（迪*创新）
-
-数组 + 单向链表；底层方法使用 synchronized 修饰
-
-#### 7. HashMap 和 LinkedHashMap 的区别（北京*晨阳光）
-
-略。
-
-#### 8. HashMap 和 TreeMap 的区别（*度，太极**、\*线途游、阿\*校招）
-
-底层的数据结构截然不同。
-
-#### 9. HashMap 里面实际装的是什么？（惠*）
-
-JDK7：HashMap 内部声明了 Entry，实现了 Map 中的 Entry 接口。（key，value 作为 Entry 的两个属性出现）
-
-JDK8：HashMap 内部声明了 Node，实现了 Map 中的 Entry 接口。（key，value 作为 Node 的两个属性出现）
-
-#### 10. HashMap 的 key 存储在哪里？和 value 存储在一起吗？那么 value 存储在哪里？说具体点？（湖**利软件、天\*伟业）
-
-数组 + 链表 + 红黑树。key、value 作为 Node 的属性出现
-
-#### 11. 自定义类型可以作为 Key 么？（阿*）
-
-可以！要重写 hashCode() 和 equals()
-
-### Collections
-
-#### 1. 集合类的工具类是谁？用过工具类哪些方法？（顺*）
-
-Collections。略
-
-#### 2. Collection 和 Collections 的区别？（平*金服、\*软）
-
-略
-
-#### 3. ArrayList 如何实现排序（阿*）
-
-Collections.sort(list) 或 Collections.sort(list,comparator)
-
-#### 4. HashMap 是否线程安全，怎样解决 HashMap 的线程不安全（中*卫星）
-
-```
-类似问题：
-> 怎么实现HashMap线程安全？（*团、*东、顺*）
-```
-
-略
-
Index: src/java/javase review/08.随堂复习与企业真题（面向对象-高级）.md
===================================================================
diff --git a/src/java/javase review/08.随堂复习与企业真题（面向对象-高级）.md b/src/java/javase review/08.随堂复习与企业真题（面向对象-高级）.md
deleted file mode 100644
--- a/src/java/javase review/08.随堂复习与企业真题（面向对象-高级）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,309 +0,0 @@
----
-order: 08
-categories:
-  - Java
----
-
-#  随堂复习与企业真题（面向对象 - 高级）
-
-***
-
-## 一、随堂复习
-
-### 1. 关键字：static
-
-- static：静态的，随着类的加载而加载、执行。
-
-- static 用来修饰：属性、方法、代码块、内部类
-- 熟悉：static 修饰的类变量、类方法与不使用 static 修饰的区别。
-  - 类变量：类的生命周期内，只有一个。被类的多个实例共享。
-- 掌握：我们遇到属性或方法时，需要考虑是否声明为 static 的。
-
-### 2. 单例模式（或单子模式）
-
-- 经典的设计模式有 23 种
-- 解决的问题：在整个软件系统中，只存在当前类的唯一实例。
-- 实现方式：饿汉式、懒汉式、枚举类等
-- 对比饿汉式和懒汉式
-  - 饿汉式：“立即加载”，线程安全的。
-  - 懒汉式："延迟加载"，线程不安全。
-- 需要会手写饿汉式和懒汉式
-
-### 3. 理解 main() 方法
-
-- public static void main(String[] args){}
-- 理解 1：作为程序的入口；普通的静态方法
-- 理解 2：如何使用 main() 与控制台进行数据的交互。
-  - 命令行：java 类名 "Tom" "Jerry" "123"
-
-### 4. 类的成员之四：代码块
-
-- 分类：静态代码块、非静态代码块
-- 使用频率上来讲：用的比较少。
-- 静态代码块：随着类的加载而执行
-- 非静态代码块：随着对象的创建而执行
-
-> 总结：对象的实例变量可以赋值的位置及先后顺序
->
-> ① 默认初始化
-> ② 显式初始化  或 ⑤ 代码块中初始化
-> ③ 构造器中初始化
->
-> ④ 有了对象以后，通过"对象。属性"或"对象。方法"的方法进行赋值
->
-> 执行的先后顺序：
-> ① - ②/⑤ - ③ - ④
-
-
-
-### 5. 关键字：final
-
-- 最终的
-
-- 用来修饰：类、方法、变量（成员变量、局部变量）
-  - 类：不能被继承
-  - 方法：不能被重写
-  - 变量：是一个“常量”，一旦赋值不能修改。
-
-### 6. 关键字：abstract
-
-- 抽象的
-- 用来修饰：类、方法
-  - 类：抽象类：不能实例化。
-  - 方法：抽象方法：没有方法体，必须由子类实现此方法。
-
-### 7. 关键字：interface
-
-- interface：接口，用来定义一组规范、一种标准。
-
-- 掌握：接口中可以声明的结构。
-
-  - 属性：使用 public static final 修饰
-
-  - 方法：jdk8 之前：只能声明抽象方法，使用 public abstract 修饰
-
-    ​            jdk8 中：声明 static 方法、default 方法。
-
-    ​            jdk9 中：声明 private 方法。
-
-- 笔试题：抽象类、接口的对比。
-
-### 8. 类的成员之五：内部类
-
-```
-> 成员内部类的理解
-> 如何创建成员内部类的实例
-> 如何在成员内部类中调用外部类的结构
-> 局部内部类的基本使用（关注：如何在方法内创建匿名局部内部类的对象）
-```
-
-### 9. 枚举类：enum
-
-- 掌握：使用 enum 关键字定义枚举类即可。
-
-### 10. 注解:Annotation
-
-- 框架 = 注解 + 反射 + 设计模式
-- Java 基础阶段：简单。@Override、 @Deprecated、@SuppressWarnings
-- 元注解：对现有的注解进行解释说明。
-  - @Target：表明可以用来修饰的结构
-  - @Retation：表明生命周期
-- 如何自定义注解。
-
-### 11. 包装类的使用
-
-- 掌握：基本数据类型对应的包装类都有哪些？
-- 掌握：基本数据类型、包装类、String 三者之间的转换
-  - 基本数据类型 <-> 包装类：自动装箱、自动拆箱
-  - 基本数据类型、包装类 <-> String
-    - String 的 valueOf(xxx)
-    - 包装类的 parseXxx(String str)
-
-### 12. IDEA:快捷键和 debug
-
-
-
-
-
-## 二、企业真题
-
-### 2.1 static 关键字
-
-#### 1. 静态变量和实例变量的区别？（保\*丰、\*软国际、\*软华*、北京明**信）
-
-```
-类似问题：
-> 说明静态变量和实例变量之间的区别和使用场景（上海*动）
-```
-
-略
-
-#### 2. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？（*度）
-
-```
-类似问题：
-> 在java中，可以重载一个static方法吗？可以覆盖一个static方法吗？（Vi*o）
-```
-
-静态方法不能被重写。不存在多态性。
-
-
-
-#### 3. 是否可以从一个 static 方法内部发出对非 static 方法的调用？（同*顺）
-
-只能通过对象来对非静态方法的调用。
-
-#### 4. 被 static 修饰的成员 (类、方法、成员变量) 能否再使用 private 进行修饰？（联*优势）
-
-完全可以。除了代码块。
-
-
-
-### 2.2 设计模式
-
-#### 1. 知道哪些设计模式？（*通快递、蚂**服）
-
-单例模式、模板方法、享元设计模式
-
-#### 2. 开发中都用到了那些设计模式？用在什么场合？（久*国际物流）
-
-略
-
-### 2.3 main()
-
-#### 1. main() 方法的 public 能不能换成 private，为什么（凡*科技、顺\*）
-
-可以改。但是改完以后就不是程序入口了。
-
-#### 2. main() 方法中是否可以调用非静态方法？（浩*科技）
-
-只能通过对象来对非静态方法的调用。
-
-### 2.4 代码块
-
-#### 1. 类的组成和属性赋值执行顺序？（航*拓普）
-
-```
-类似问题：
-> Java中类的变量初始化的顺序？（*壳）
-```
-
-略。
-
-#### 2. 静态代码块，普通代码块，构造方法，从类加载开始的执行顺序？（恒*电子）
-
-```
-类似问题：
-> 类加载成员变量、静态代码块、构造器的加载顺序（*科软、软**力、同*顺）
-> static代码块(静态代码块)是否在类的构造函数之前被执行（联*优势）
-
-```
-
-静态代码块 --> 普通代码块 --> 构造器
-
-### 2.5 final 关键字
-
-#### 1. 描述一下对 final 理解（华**博普）
-
-略
-
-#### 2. 判断题：使用 final 修饰一个变量时，是引用不能改变，引用指向的对象可以改变？（*米）
-
-引用不能改变。
-
-引用指向的对象实体中的属性，如果没有使用 final 修饰，则可以改变。
-
-#### 3. 判断题：final 不能用于修饰构造方法？（联*优势）
-
-是的。
-
-#### 4. final 或 static final 修饰成员变量，能不能进行++操作？（佳*贸易）
-
-不能。
-
-### 2.6 抽象类与接口
-
-#### 1. 什么是抽象类？如何识别一个抽象类？（易*支付）
-
-使用 abstract 修饰。
-
-#### 2. 为什么不能用 abstract 修饰属性、私有方法、构造器、静态方法、final 的方法？（止**善）
-
-略。为了语言的自洽。
-
-#### 3. 接口与抽象类的区别？（字\*跳动、阿\*校招、\*度校招、\*\*计算机技术及应用研究所、航*拓普、纬\*、招**晟、汇\*云通、数信\*\*科技、北京永\*鼎力、上海\*连科技）
-
-略。
-
-
-
-#### 4. 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？（航\*拓普、\*蝶、深圳德*科技）
-
-```
-类似问题：
-> 接口A可以继承接口B吗?接口A可以实现接口B吗?（久*国际物流）
-```
-
-是；是；是；
-
-#### 5. 接口可以有自己属性吗？（华*中盛）
-
-可以。必须是 public static final 的
-
-#### 6. 访问接口的默认方法如何使用 (上海*思)
-
-使用实现类的对象进行调用。而且实现还可以重写此默认方法。
-
-### 2.7 内部类
-
-#### 1. 内部类有哪几种？（华油**普、来\*科技）
-
-略。
-
-#### 2. 内部类的特点说一下（招通**）
-
-```
-类似问题：
-> 说一下内部类的好处（北京楚*龙）
-> 使用过内部类编程吗，有什么作用（软**力）
-```
-
-
-
-
-
-#### 8.匿名类说一下（阿*校招、上海立\*网络）
-
-略
-
-
-
-### 2.8 枚举类
-
-#### 1. 枚举可以继承吗？（顺*）
-
-使用 enum 定义的，其父类就是 Enum 类，就不要再继承其他的类了。
-
-### 2.9 包装类
-
-#### 1. Java 基本类型与包装类的区别（凡*科技）
-
-略。
-
-### 2.10 综合
-
-#### 1. 谈谈你对面向对象的理解 (君*科技、航\*拓普、...)
-
-- 面向对象的两个要素：类、对象  ---> 面向对象编程。“万事万物皆对象”。
-- 面向对象的三大特征
-- 接口，与类并列的结构，作为一个补充：类可以实现多个接口。
-
-#### 2. 面向对象的特征有哪些方面？（北京楚\*龙、深圳德*科技、直\*科技、米\*奇网络、航\*拓普）
-
-```
-类似问题：
-> 面向对象核心是什么？（平**服）
-```
-
-
-
Index: src/java/javase review/07.随堂复习与企业真题（面向对象-进阶）.md
===================================================================
diff --git a/src/java/javase review/07.随堂复习与企业真题（面向对象-进阶）.md b/src/java/javase review/07.随堂复习与企业真题（面向对象-进阶）.md
deleted file mode 100644
--- a/src/java/javase review/07.随堂复习与企业真题（面向对象-进阶）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,190 +0,0 @@
----
-order: 07
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（面向对象 - 进阶）
-
-***
-
-## 一、随堂复习
-
-### 1. this 关键字的使用
-
-- this 调用的结构：属性、方法；构造器
-
-- this 调用属性或方法时，理解为：当前对象或当前正在创建的对象。
-
-  ```java
-  public void setName(String name){ //当属性名和形参名同名时，必须使用 this 来区分
-  	this.name = name;
-  }
-  
-  public Person(String name){
-      this.name = name;
-  }
-  ```
-
-- this(形参列表) 的方式，表示调用当前类中其他的重载的构造器。
-
-### 2. 面向对象的特征二：继承性
-
-- 继承性的好处
-  - 减少了代码的冗余，提高了复用性；
-  - 提高了扩展性
-  - 为多态的使用，提供了前提。
-- Java 中继承性的特点
-  - 局限性：类的单继承性。后续我们通过类实现接口的方式，解决单继承的局限性。
-  - 支持多层继承，一个父类可以声明多个子类。
-- 基础：class A extends B{}
-- 理解：子类就获取了父类中声明的全部的属性、方法。可能受封装性的影响，不能直接调用。
-
-### 3. 方法的重写（override / overwrite）
-
-- 面试题：方法的重载与重写的区别？
-  - 方法的重载：“两同一不同”
-  - 方法的重写：
-    - 前提：类的继承关系
-    - 子类对父类中同名同参数方法的覆盖、覆写。
-
-### 4. super 关键字的使用
-
-- super 可以调用的结构：属性、方法；构造器
-- super：父类的
-- super 调用父类的属性、方法：
-  - 如果子父类中出现了同名的属性，此时使用 super.的方式，表明调用的是父类中声明的属性。
-  - 子类重写了父类的方法。如果子类的任何一个方法中需要调用父类被重写的方法时，需要使用 super.
-- super 调用构造器：
-  - 在子类的构造器中，首行要么使用了"this(形参列表)"，要么使用了"super(形参列表)"。
-
-### 5. （熟悉）子类对象实例化的全过程
-
-- 结果上来说：体现为继承性
-- 过程上来说：子类调用构造器创建对象时，一定会直接或间接的调用其父类的构造器，以及父类的父类的构造器，...，直到调用到 Object() 的构造器。
-
-### 6. 面向对象的特征三：多态性
-
-- 广义上的理解：子类对象的多态性、方法的重写；方法的重载
-
-  狭义上的理解：子类对象的多态性。
-
-- 格式：Object obj = new String("hello");   父类的引用指向子类的对象。
-- 多态的好处：减少了大量的重载的方法的定义；开闭原则
-  - 举例：public boolean equals(Object obj)
-  - 多态，无处不在！讲了抽象类、接口以后，会有更好的理解。
-- 多态的使用：虚拟方法调用。“编译看左边，运行看右边”。属性，不存在多态性。
-- 多态的逆过程：向下转型，使用强转符 ()。
-  - 为了避免出现强转时的 ClassCastException，建议 () 之前使用 instanceOf 进行判断。
-
-### 7. Object 类的使用
-
-- 根父类
-- equals() 的使用
-  - 重写和不重写的区别
-  - 面试题： == 和 equals()
-- toString() 的使用
-  - Object 中 toString() 调用后，返回当前对象所属的类和地址值。
-  - 开发中常常重写 toString()，用于返回当前对象的属性信息。
-
-### 8. 项目二：拼电商客户管理系统
-
-- 编写两个类：Customer、CustomerList 类（封装了对数组的增删改查操作）
-
-
-
-
-## 二、企业真题
-
-### 2.1 继承性
-
-#### 1. 父类哪些成员可以被继承，属性可以被继承吗？可以或者不可以，请举下例子。（北京明**信）
-
-父类的属性、方法可以被继承。构造器可以被子类调用。
-
-
-
-### 2.2 重写
-
-#### 1. 什么是 Override，与 Overload 的区别（顺\*、软\*\*力、明\*数据、阳\*科技、中*软）
-
-略
-
-#### 2. Overload 的方法是否可以改变返回值的类型？（新*陆）
-
-public void method(int i){}
-
-public int method(int j,int k){}
-
-#### 3. 构造器 Constructor 是否可被 override?（鸿*网络、深圳德**技、航\*\*普）
-
-不能！构造器可以重载
-
-#### 4. 为什么要有重载，我随便命名一个别的函数名不行吗？谈谈你是怎么理解的。（腾*）
-
-见名知意。
-
-### 2.3 super 关键字
-
-#### 1. super 和 this 的区别 (蚂**服)
-
-把两个关键字各自的特点说清楚。
-
-#### 2. this、super 关键字分别代表什么？以及他们各自的使用场景和作用。（北京楚*龙）
-
-略
-
-### 2.4 多态
-
-#### 1. 谈谈你对多态的理解 (三*重工、江\*智能、银\*数据、君\*科技)
-
-```
-类似问法：
-> Java中实现多态的机制是什么(国*电网)
-> 什么是多态？（上*银行）
-> Java中的多态是什么意思？（贝*）
-```
-
-略
-
-
-
-#### 2. 多态 new 出来的对象跟不多态 new 出来的对象区别在哪？（万*智能）
-
-Person p = new Man();  //虚方法调用。屏蔽了子类 Man 类特有的属性和方法。
-
-Man m = new Man(); 
-
-
-
-#### 3. 说说你认为多态在代码中的体现（楚*龙）
-
-无处不在！
-
-略
-
-### 2.5 Object 类
-
-#### 1. ==与 equals 的区别（拓*思）
-
-```
-类似问法：
-> 两个对象A和B，A==B，A.equals(B)有什么区别（华油**普）
-```
-
-略
-
-
-
-#### 2. 重写 equals 方法要注意什么？（安**网络科技）
-
-- 明确判定两个对象实体 equals() 的标准。是否需要所有的属性参与。
-- 对象的属性，又是自定义的类型，此属性也需要重写 equals()
-
-#### 3. Java 中所有类的父类是什么？他都有什么方法？（阿*校招）
-
-```
-相关问题：
-> Object类有哪些方法？（恒*电子）
-```
-
Index: src/java/javase review/16.随堂复习与企业真题（网络编程）.md
===================================================================
diff --git a/src/java/javase review/16.随堂复习与企业真题（网络编程）.md b/src/java/javase review/16.随堂复习与企业真题（网络编程）.md
deleted file mode 100644
--- a/src/java/javase review/16.随堂复习与企业真题（网络编程）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,86 +0,0 @@
----
-order: 16
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（网络编程）
-
-***
-
-## 一、随堂复习
-
-### 1. 网络编程概述
-
-- 计算机网络：略
-- 网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。
-- 需要解决的三个问题：
-  - 问题 1：如何准确地定位网络上一台或多台主机
-  - 问题 2：如何定位主机上的特定的应用
-  - 问题 3：找到主机后，如何可靠、高效地进行数据传输
-
-### 2. 要素 1：IP 地址
-
-- 使用具体的一个 ip 地址对应具体的一个互联网上的主机
-- IP 分类：
-  - 角度一：IPv4、IPv6
-  - 角度二：公网地址、私网地址（或局域网)
-- 使用 InetAddress 类表示 IP 地址
-  - 实例化：getByName(String host) 、getLocalHost()
-  - 常用方法：getHostName() 、getHostAddress()
-
-### 3. 要素 2：端口号
-
-- 用于区分同一台主机上的不同的进程
-- 不同的进程分配不同的端口号
-- 范围：0-65535
-
-### 4. 要素 3：网络通信协议
-
-- 这里有两套参考模型
-  - OSI 参考模型：模型过于理想化，未能在因特网上进行广泛推广
-  - TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。
-- 在传输层中涉及到两个协议：TCP、UDP。二者的对比
-  - TCP：可靠的连接（发送数据前，需要三次握手、四次挥手），进行大数据量的传输，效率低。
-  - UDP：不可靠的连接（发送前，不需要确认对方是否在）、使用数据报传输（限制在 64kb 以内）、效率高。
-- TCP 的三次握手、四次挥手（了解）
-
-### 5. TCP 网络编程
-
-> 例题 1：客户端发送内容给服务端，服务端将内容打印到控制台上。
->
-> 例题 2：客户端发送文件给服务端，服务端将文件保存在本地。
->
-> 例题 3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。
-
-### 6. UDP 网络编程
-
-简单的理解 UDP 的数据传输。
-
-### 7. URL 编程
-
-- Java 后台：将写好的 Java 程序部署在 Tomcat 服务器。启动 Tomcat 服务器。
-
-- 前台：使用浏览器进行访问。需要使用 url。（HTML+CSS+JavaScript）
-- URL 的作用：定位互联网上某一资源的地址。
-- URL 的格式：
-
-```
-http://192.168.21.107:8080/examples/abcd.jpg?name=Tom   ---> "万事万物皆对象"
-应用层协议 ip地址       端口号  资源地址   参数列表
-```
-
-- 使用 URL 实现数据的下载（了解）
-
-
-## 二、企业真题
-
-#### 1. TCP 协议和 UDP 协议的区别（华**为）
-
-略
-
-
-
-#### 2. 简单说说 TCP 协议的三次握手与四次挥手机制（*科软）
-
-略
Index: src/java/javase review/10.随堂复习与企业真题（多线程）.md
===================================================================
diff --git a/src/java/javase review/10.随堂复习与企业真题（多线程）.md b/src/java/javase review/10.随堂复习与企业真题（多线程）.md
deleted file mode 100644
--- a/src/java/javase review/10.随堂复习与企业真题（多线程）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,399 +0,0 @@
----
-order: 10
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（多线程）
-
-***
-
-## 一、随堂复习
-
-### 1. 几个概念
-
-```
-程序(program)：为完成特定任务，用某种语言编写的`一组指令的集合`。即指一段静态的代码。
-
-进程(process)：程序的一次执行过程，或是正在内存中运行的应用程序。程序是静态的，进程是动态的。
-              进程作为操作系统调度和分配资源的最小单位。
-
-线程(thread)：进程可进一步细化为线程，是程序内部的一条执行路径。
-             线程作为CPU调度和执行的最小单位
-```
-
-```
-线程调度策略
-分时调度：所有线程`轮流使用` CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。
-
-抢占式调度：让`优先级高`的线程以`较大的概率`优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。
-```
-
-```
-> 单核CPU与多核CPU
-> 并行与并发
-```
-
-### 2. 如何创建多线程（重点）
-
-- 方式 1：继承 Thread 类
-- 方式 2：实现 Runnable 接口
-- 方式 3：实现 Callable 接口（jdk5.0 新增）
-- 方式 4：使用线程池（jdk5.0 新增）
-
-### 3. Thread 类的常用方法、线程的生命周期
-
-```
-熟悉常用的构造器和方法：
-1. 线程中的构造器
-- public Thread() :分配一个新的线程对象。
-- public Thread(String name) :分配一个指定名字的新的线程对象。
-- public Thread(Runnable target) :指定创建线程的目标对象，它实现了Runnable接口中的run方法
-- public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。
-
-2.线程中的常用方法：
-> start():①启动线程 ②调用线程的run()
-> run():将线程要执行的操作，声明在run()中。
-> currentThread():获取当前执行代码对应的线程
-> getName(): 获取线程名
-> setName(): 设置线程名
-> sleep(long millis):静态方法，调用时，可以使得当前线程睡眠指定的毫秒数
-> yield():静态方法，一旦执行此方法，就释放CPU的执行权
-> join(): 在线程a中通过线程b调用join()，意味着线程a进入阻塞状态，直到线程b执行结束，线程a才结束阻塞状态，继续执行。
-> isAlive():判断当前线程是否存活
-
-3. 线程的优先级：
-getPriority():获取线程的优先级
-setPriority():设置线程的优先级。范围[1,10]
-
-
-Thread类内部声明的三个常量：
-- MAX_PRIORITY（10）：最高优先级
-- MIN _PRIORITY （1）：最低优先级
-- NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。
-```
-
-线程的生命周期：
-
-jdk5.0 之前：
-
-![image-20221203142900528](images/image-20221203142900528.png)
-
-jdk5.0 及之后：Thread 类中定义了一个内部类 State
-
-```java
-public enum State {
-        
-        NEW,
-    
-        RUNNABLE,
-
-        BLOCKED,
-
-        WAITING,
-
-        TIMED_WAITING,
- 
-        TERMINATED;
-}
-```
-
-![image-20221203143046926](images/image-20221203143046926.png)
-
-### 4. 如何解决线程安全问题 (重点、难点)
-
-- 什么是线程的安全问题？多个线程操作共享数据，就有可能出现安全问题。
-
-- 如何解决线程的安全问题？有几种方式？
-
-  - 同步机制：① 同步代码块 ② 同步方法
-
-    - 重点关注两个事：共享数据及操作共享数据的代码；同步监视器（保证唯一性）
-
-    ```
-    在实现 Runnable 接口的方式中，同步监视器可以考虑使用：this。
-    在继承 Thread 类的方式中，同步监视器要慎用 this，可以考虑使用：当前类.class。
-    ```
-
-    ```
-    非静态的同步方法，默认同步监视器是 this
-    静态的同步方法，默认同步监视器是当前类本身。
-    ```
-
-  - jdk5.0 新增：Lock 接口及其实现类。（保证多个线程共用同一个 Lock 的实例）
-
-### 5. 同步机制相关的问题
-
-- 懒汉式的线程安全的写法
-- 同步机制会带来的问题：死锁
-  - 死锁产生的条件及规避方式
-
-### 6. 线程间的通信
-
-- 在同步机制下，考虑线程间的通信
-- wait() 、notify() 、notifyAll() 都需要使用在同步代码块或同步方法中。
-
-- 高频笔试题：wait() / sleep()
-
-
-## 二、企业真题
-
-### 2.1 线程概述
-
-#### 1. 什么是线程 (*云网络)
-
-略
-
-#### 2. 线程和进程有什么区别 (*团、腾\*、\*云网络、神**岳、言\*有物、直\*科技)
-
-进程：对应一个运行中的程序。
-
-线程：运行中的进程的一条或多条执行路径。
-
-#### 3. 多线程使用场景（嘉*医疗）
-
-- 手机 app 应用的图片的下载
-- 迅雷的下载
-- Tomcat 服务器上 web 应用，多个客户端发起请求，Tomcat 针对多个请求开辟多个线程处理
-
-### 2.2 如何实现多线程
-
-#### 1. 如何在 Java 中出实现多线程？(阿\*校招、当\*置业、鸿\*网络、奥\*医药、\*科软、慧\*、上海驿\*软件、海\*科)
-
-```
-类似问题：
-> 创建多线程用Runnable还是Thread(北京中*瑞飞)
-> 多线程有几种实现方法，都是什么？（锐*（上海）企业管理咨询）
-```
-
-四种。
-
-#### 2. Thread 类中的 start() 和 run() 有什么区别？(北京中油\*\*、爱\*信、神\*泰岳、直\*科技，\*软国际，上海\*学网络)
-
-start()：① 开启线程 ② 调用线程的 run()
-
-#### 3. 启动一个线程是用 run() 还是 start()?（*度）
-
-start()
-
-#### 4. Java 中 Runnable 和 Callable 有什么不同？(平\*金服、银\*数据、好\*在、亿\*征信、花儿**网络)
-
-```
-与之前的方式的对比：与Runnable方式的对比的好处
-> call()可以有返回值，更灵活
-> call()可以使用throws的方式处理异常，更灵活
-> Callable使用了泛型参数，可以指明具体的call()的返回值类型，更灵活
-
-有缺点吗？如果在主线程中需要获取分线程call()的返回值，则此时的主线程是阻塞状态的。
-```
-
-#### 5. 什么是线程池，为什么要使用它？(上海明*物联网科技)
-
-```
-此方式的好处：
-> 提高了程序执行的效率。（因为线程已经提前创建好了）
-> 提高了资源的复用率。（因为执行完的线程并未销毁，而是可以继续执行其他的任务）
-> 可以设置相关的参数，对线程池中的线程的使用进行管理
-```
-
-### 2.3 常用方法、生命周期
-
-#### 1. sleep() 和 yield() 区别？(神*泰岳)
-
-sleep()：一旦调用，就进入“阻塞”（或 TIMED_WAITING 状态）
-
-yield():释放 cpu 的执行权，处在 RUNNABLE 的状态
-
-#### 2. 线程创建的中的方法、属性情况？(招通**、数\*互融)
-
-略
-
-#### 3. 线程的生命周期？(中国**电子商务中心、\*科软、慧\*)
-
-略
-
-#### 4. 线程的基本状态以及状态之间的关系？(直*科技)
-
-```
-类似问题：
-> 线程有哪些状态？如何让线程进入阻塞？（华*中*，*兴）
-> 线程有几个状态，就绪和阻塞有什么不同。（美*）
-> Java的线程都有哪几种状态（字*跳动、*东、*手）
-```
-
-略
-
-#### 5. stop() 和 suspend() 方法为何不推荐使用？（上海驿*软件）
-
-stop()：一旦执行，线程就结束了，导致 run() 有未执行结束的代码。stop() 会导致释放同步监视器，导致线程安全问题。
-
-suspend()：与 resume() 搭配使用，导致死锁。
-
-#### 6. Java 线程优先级是怎么定义的？（软*动力）
-
-三个常量。[1,10]
-
-### 2.4 线程安全与同步机制
-
-#### 1. 你如何理解线程安全的？线程安全问题是如何造成的？（*软国际）
-
-```
-类似问题：
-> 线程安全说一下？（奥*医药）
-> 对线程安全的理解（*度校招）
-> 什么是线程安全？(银*数据)
-```
-
-略
-
-#### 2. 多线程共用一个数据变量需要注意什么？（史*夫软件）
-
-线程安全问题
-
-#### 3. 多线程保证线程安全一般有几种方式？（来*科技、北京\*信天\*）
-
-```
-类似问题：
-> 如何解决其线程安全问题，并且说明为什么这样子去解决？（北京联合**）
-> 请说出你所知道的线程同步的方法。（天*伟业）
-> 哪些方法实现线程安全？（阿*）   
-> 同步有几种实现方法，都是什么? （锐*企业管理咨询）
-> 你在实际编码过程中如何避免线程安全问题？（*软国际）
-> 如何让线程同步?（*手）
-> 多线程下有什么同步措施（阿*校招）
-> 同步有几种实现方法，都是什么？（海*科）
-```
-
-- 同步机制
-- Lock 接口
-
-#### 4. 用什么关键字修饰同步方法？（上海驿*软件） 
-
-synchronized
-
-#### 5. synchronized 加在静态方法和普通方法区别（来*科技）
-
-同步监视器不同。静态：当前类本身   非静态：this
-
-#### 6. Java 中 synchronized 和 ReentrantLock 有什么不同 (三*重工)
-
-```
-类似问题：
-> 多线程安全机制中 synchronized和lock的区别（中*国际、*美、鸿*网络）
-> 怎么实现线程安全，各个实现方法有什么区别？（美*、字*跳动）
-> synchronized 和 lock 区别（阿*、*壳）
-```
-
-```
-synchronized不管是同步代码块还是同步方法，都需要在结束一对{}之后，释放对同步监视器的调用。
-Lock是通过两个方法控制需要被同步的代码，更灵活一些。
-Lock作为接口，提供了多种实现类，适合更多更复杂的场景，效率更高。
-```
-
-
-
-#### 7. 当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法？（鸿*网络）
-
-需要看其他方法是否使用 synchronized 修饰，同步监视器的 this 是否是同一个。
-
-只有当使用了 synchronized，且 this 是同一个的情况下，就不能访问了。
-
-
-
-#### 8. 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？（阿*校招、西安\*创佳\*）
-
-同步一定阻塞；阻塞不一定同步。
-
-### 2.5 死锁
-
-#### 1. 什么是死锁，产生死锁的原因及必要条件（腾*、阿\*）
-
-```
-1. 如何看待死锁？
-不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。
-我们编写程序时，要避免出现死锁。
-
-2. 诱发死锁的原因？
-- 互斥条件
-- 占用且等待
-- 不可抢夺（或不可抢占）
-- 循环等待
-
-以上4个条件，同时出现就会触发死锁。
-
-
-3. 如何避免死锁？
-针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。
-针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。
-针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。
-针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。
-```
-
-#### 2. 如何避免死锁？(阿\*、北京\*蓝、*手)
-
-见上。
-
-### 2.6 线程通信
-
-#### 1. Java 中 notify() 和 notifyAll() 有什么区别 (汇*天下)
-
-```
-notify():一旦执行此方法，就会唤醒被wait()的线程中优先级最高的那一个线程。（如果被wait()的多个线程的优先级相同，则
-         随机唤醒一个）。被唤醒的线程从当初被wait的位置继续执行。
-notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。
-```
-
-#### 2. 为什么 wait() 和 notify() 方法要在同步块中调用 (北京*智)
-
-因为调用者必须是同步监视器。
-
-#### 3. 多线程：生产者，消费者代码（同步、wait、notifly 编程）（猫*娱乐）
-
-```
-类似问题：
-> 如何写代码来解决生产者消费者问题(上海明*物联网)
-> 多线程中生产者和消费者如何保证同步（*为）
-> 消费者生产者，写写伪代码（字*）
-```
-
-略
-
-#### 4. wait() 和 sleep() 有什么区别？调用这两个函数后，线程状态分别作何改变？（字\*、*东）
-
-```
-类似问题：
-> 线程中sleep()和wait()有什么区别？（外派*度）
-> Java线程阻塞调用 wait 函数和 sleep 区别和联系（阿*）
-> wait和sleep的区别，他们两个谁会释放锁（软*动力、*创）
-```
-
-```
-相同点：一旦执行，当前线程都会进入阻塞状态
-
-不同点：
-> 声明的位置：wait():声明在Object类中
-            sleep():声明在Thread类中，静态的
-> 使用的场景不同：wait():只能使用在同步代码块或同步方法中
-               sleep():可以在任何需要使用的场景
-> 使用在同步代码块或同步方法中：wait():一旦执行，会释放同步监视器
-                          sleep():一旦执行，不会释放同步监视器
-> 结束阻塞的方式：wait(): 到达指定时间自动结束阻塞 或 通过被notify唤醒，结束阻塞
-               sleep(): 到达指定时间自动结束阻塞
-```
-
-
-
-### 2.7 单例模式（线程安全）
-
-#### 1. 手写一个单例模式 (Singleton)，还要安全的（\*通快递、君*科技）
-
-饿汉式；安全的懒汉式；内部类；
-
-#### 2. 手写一个懒汉式的单例模式&解决其线程安全问题，并且说明为什么这样子去解决（5*）
-
-```
-类似问题：
-> 手写一个懒汉式的单例模式（北京联合**）
-```
-
-同上。
Index: src/java/javase review/13.随堂复习与企业真题（泛型）.md
===================================================================
diff --git a/src/java/javase review/13.随堂复习与企业真题（泛型）.md b/src/java/javase review/13.随堂复习与企业真题（泛型）.md
deleted file mode 100644
--- a/src/java/javase review/13.随堂复习与企业真题（泛型）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,78 +0,0 @@
----
-order: 13
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（泛型）
-
-***
-
-## 一、随堂复习
-
-### 1. 泛型的理解
-
-- <E> ，泛型参数，使用引用数据类型来赋值。
-
-### 2. 泛型在集合、比较器中的使用（重点）
-
-- 集合：ArrayList、HashMap、Iterator
-- 比较器：Comparable、Comparator
-
-### 3. 自定义泛型类/泛型接口、泛型方法（熟悉）
-
-- class Order<T>{ }
-- public <E> 返回值类型 方法名 (形参列表){}
-- 具体的细节，见 IDEA 中的笔记。
-
-### 4. 泛型在继承上的体现
-
-```
-1. 类SuperA是类A的父类，则G<SuperA> 与 G<A>的关系：G<SuperA> 和 G<A>是并列的两个类，没有任何子父类的关系。
-
-比如：ArrayList<Object> 、ArrayList<String>没有关系
-
-2. 类SuperA是类A的父类或接口，SuperA<G> 与 A<G>的关系：SuperA<G> 与A<G> 有继承或实现的关系。
-即A<G>的实例可以赋值给SuperA<G>类型的引用（或变量）
-
-比如：List<String> 与 ArrayList<String>
-```
-
-### 5. 通配符的使用
-
-- ? 的使用（重点）
-  - 以集合为例：可以读取数据、不能写入数据（例外：null）
-- ? extends A
-  - 以集合为例：可以读取数据、不能写入数据（例外：null）
-- ? super A
-  - 以集合为例：可以读取数据、可以写入 A 类型或 A 类型子类的数据（例外：null）
-
-
-
-## 二、企业真题
-
-#### 1. Java 的泛型是什么？有什么好处和优点？JDK 不同版本的泛型有什么区别？（软*动力）
-
-泛型，是程序中出现的不确定的类型。
-
-以集合来举例：把一个集合中的内容限制为一个特定的数据类型，这就是 generic 背后的核心思想。
-
-
-
-jdk7.0 新特性：
-
-```java
-ArrayList<String> list = new ArrayList<>(); //类型推断
-```
-
-后续版本的新特性：
-
-```java
-Comparator<Employee> comparator = new Comparator<>(){} //类型推断
-```
-
-
-
-#### 2. 说说你对泛型的了解（*软国际）
-
-略
Index: src/java/javase review/04.随堂复习与企业真题（IDEA的安装与使用）.md
===================================================================
diff --git a/src/java/javase review/04.随堂复习与企业真题（IDEA的安装与使用）.md b/src/java/javase review/04.随堂复习与企业真题（IDEA的安装与使用）.md
deleted file mode 100644
--- a/src/java/javase review/04.随堂复习与企业真题（IDEA的安装与使用）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,61 +0,0 @@
----
-order: 4
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（IDEA 安装与使用）
-
-***
-
-## 一、随堂复习
-
-### 1. IDEA 的认识
-
-- IDEA(集成功能强大、符合人体工程学（设置人性化）)
-- Eclipse
-
-### 2. IDEA 的下载、安装、卸载
-
-- 卸载：使用控制面板进行卸载，注意删除 c 盘指定目录下的两个文件目录：jetbrains
-- 下载：从官网进行下载：旗舰版（收费版）
-- 安装：傻瓜式的安装-->注册
-
-### 3. 工程等结构
-
-- 工程、模块、包、类等概念。
-- 掌握：如何创建工程、如何创建模块、如何导入其他项目中的模块、如何创建包、如何创建类、如何运行
-- 了解：如何删除模块
-
-### 4. 熟悉 JDK 的结构
-
-![image-20221115165103208](images/image-20221115165103208.png)
-
-![image-20221115165123046](images/image-20221115165123046.png)
-
-![image-20221115165138209](images/image-20221115165138209.png)
-
-### 5. 详细的设置
-
-略
-
-### 6. 代码模板、快捷键、调试程序（debug）
-
-后续讲解。
-
-## 二、企业真题
-
-### 1. 开发中你接触过的开发工具都有哪些？
-
-IDEA
-
-### 2. 谈谈你对 Eclipse 和 IDEA 使用上的感受？
-
-Eclipse 不够人性化。
-
-
-
-
-
-
-
Index: src/java/javase review/17.随堂复习与企业真题（反射机制）.md
===================================================================
diff --git a/src/java/javase review/17.随堂复习与企业真题（反射机制）.md b/src/java/javase review/17.随堂复习与企业真题（反射机制）.md
deleted file mode 100644
--- a/src/java/javase review/17.随堂复习与企业真题（反射机制）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,334 +0,0 @@
----
-order: 17
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（反射机制）
-
-***
-
-## 一、随堂复习
-
-### 1. 反射的概述（熟悉）
-
-- Java 给我们提供了一套 API，使用这套 API 我们可以在运行时动态的获取指定对象所属的类，创建运行时类的对象，调用指定的结构（属性、方法）等。
-- API：
-  - `java.lang.Class`：代表一个类
-  - java.lang.reflect.Method：代表类的方法
-  - java.lang.reflect.Field：代表类的成员变量
-  - java.lang.reflect.Constructor：代表类的构造器
-  - … …
-- 反射的优点和缺点
-  - **优点：**
-    - 提高了 Java 程序的灵活性和扩展性，`降低了耦合性`，提高`自适应`能力
-
-    - 允许程序创建和控制任何类的对象，无需提前`硬编码`目标类
-  - **缺点：**
-    - 反射的`性能较低`。
-      - 反射机制主要应用在对灵活性和扩展性要求很高的系统框架上
-    - 反射会`模糊`程序内部逻辑，`可读性较差`。
-- 反射，平时开发中，我们使用并不多。主要是在框架的底层使用。
-
-### 2. Class:反射的源头
-
-- Class 的理解（掌握）
-
-  ```
-  针对于编写好的.java 源文件进行编译 (使用 javac.exe)，会生成一个或多个.class 字节码文件。接着，我们使用
-  java.exe 命令对指定的.class 文件进行解释运行。这个解释运行的过程中，我们需要将.class 字节码文件加载 (使用类的加载器) 到内存中 (存放在方法区)。加载到内存中的.class 文件对应的结构即为 Class 的一个实例。
-  ```
-
-- 获取 Class 的实例的几种方式（前三种）
-
-  - 类.class
-  - 对象.getClass()
-  - （使用较多）Class 调用静态方法 forName(String className)
-  - (了解) 使用 ClassLoader 的方法 loadClass(String className)
-
-- Class 可以指向哪些结构。
-
-  ```
-  简言之，所有 Java 类型！
-  （1）class：外部类，成员 (成员内部类，静态内部类)，局部内部类，匿名内部类
-  （2）interface：接口
-  （3）[]：数组
-  （4）enum：枚举
-  （5）annotation：注解@interface
-  （6）primitive type：基本数据类型
-  （7）void
-  ```
-
-### 3. 类的加载过程、类的加载器（理解）
-
-- 类的加载过程
-
-  ```
-  过程 1：类的装载 (loading)
-  将类的 class 文件读入内存，并为之创建一个 java.lang.Class 对象。此过程由类加载器完成
-  
-  过程 2：链接 (linking)
-  > 验证 (Verify):确保加载的类信息符合 JVM 规范，例如：以 cafebabe 开头，没有安全方面的问题。
-  > 准备 (Prepare):正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。
-  > 解析 (Resolve):虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。
-  
-  过程 3：初始化 (initialization)
-  执行类构造器<clinit>() 方法的过程。
-  类构造器<clinit>() 方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。
-  ```
-
-- 类的加载器
-
-  ```
-  5.1 作用：负责类的加载，并对应于一个 Class 的实例。
-  
-  5.2 分类（分为两种）：
-  > BootstrapClassLoader:引导类加载器、启动类加载器
-       > 使用C/C++语言编写的，不能通过Java代码获取其实例
-       > 负责加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar 或 sun.boot.class.path 路径下的内容）
-  
-  > 继承于 ClassLoader 的类加载器
-      > ExtensionClassLoader:扩展类加载器
-              > 负责加载从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录下加载类库
-      > SystemClassLoader/ApplicationClassLoader:系统类加载器、应用程序类加载器
-              > 我们自定义的类，默认使用的类的加载器。
-      > 用户自定义类的加载器
-              > 实现应用的隔离（同一个类在一个应用程序中可以加载多份）；数据的加密。
-  ```
-
-### 4. 反射的应用 1：创建运行时类的对象（重点）
-
-```
-Class clazz = Person.class;
-
-//创建Person类的实例
-Person per = (Person) clazz.newInstance();
-
-System.out.println(per);
-```
-
-```
-要想创建对象成功，需要满足：
-条件1：要求运行时类中必须提供一个空参的构造器
-条件2：要求提供的空参的构造器的权限要足够。
-```
-
-### 5. 反射的应用 2：获取运行时类所有的结构
-
-```
-（了解）获取运行时类的内部结构1：所有属性、所有方法、所有构造器
-（熟悉）获取运行时类的内部结构2：父类、接口们、包、带泛型的父类、父类的泛型等
-```
-
-### 6. 反射的应用 3：调用指定的结构（重点）
-
-```
-3.1 调用指定的属性（步骤）
-步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性
-步骤2. setAccessible(true)：确保此属性是可以访问的
-步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作）
-                  或 set(Object obj,Object value) （设置的操作）进行操作。
-
-3.2 调用指定的方法（步骤）
-步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法
-步骤2. setAccessible(true)：确保此方法是可访问的
-步骤3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。
-     invoke()的返回值即为Method对应的方法的返回值
-     特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null
-
-3.3 调用指定的构造器（步骤）
-步骤1.通过Class的实例调用getDeclaredConstructor(Class ... args)，获取指定参数类型的构造器
-步骤2.setAccessible(true)：确保此构造器是可以访问的
-步骤3.通过Constructor实例调用newInstance(Object ... objs),返回一个运行时类的实例。
-```
-
-### 7. 反射的应用 4：注解的使用（了解）
-
-略
-
-### 8. 体会：反射的动态性
-
-```java
-public class ReflectTest {
-
-    //体会：静态性
-    public Person getInstance(){
-        return new Person();
-    }
-
-    //体会：反射的动态性
-    //举例 1：
-    public <T> T getInstance(String className) throws Exception {
-
-        Class clazz = Class.forName(className);
-
-        Constructor con = clazz.getDeclaredConstructor();
-        con.setAccessible(true);
-
-        return (T) con.newInstance();
-
-    }
-
-    @Test
-    public void test1() throws Exception {
-        Person p1 = getInstance();
-        System.out.println(p1);
-
-        String className = "com.atguigu04.other.dynamic.Person";
-        Person per1 = getInstance(className);
-        System.out.println(per1);
-
-        String className1 = "java.util.Date";
-        Date date1 = getInstance(className1);
-        System.out.println(date1);
-    }
-
-    //体会：反射的动态性
-    //举例 2：
-    public Object invoke(String className,String methodName) throws Exception {
-        //1. 创建全类名对应的运行时类的对象
-        Class clazz = Class.forName(className);
-
-        Constructor con = clazz.getDeclaredConstructor();
-        con.setAccessible(true);
-
-        Object obj = con.newInstance();
-
-        //2. 获取运行时类中指定的方法，并调用
-        Method method = clazz.getDeclaredMethod(methodName);
-        method.setAccessible(true);
-        return method.invoke(obj);
-    }
-
-    @Test
-    public void test2() throws Exception {
-        String className = "com.atguigu04.other.dynamic.Person";
-        String methodName = "show";
-
-        Object returnValue = invoke(className,methodName);
-        System.out.println(returnValue);
-    }
-
-}
-```
-
-
-
-## 二、企业真题
-
-### 2.1 反射概述
-
-#### 1. 对反射了解吗？反射有什么好处？为什么需要反射？（微*银行）
-
-```
-类似问题：
-> Java反射的作用是什么？(三*重工、上海*和网络)
-> Java反射机制的作用有什么？(上海明*物联网)
-> 反射的具体用途？（阿***芝*信用项目组）
-```
-
-略
-
-#### 2. 反射的使用场合和作用、及其优缺点（*软国际）
-
-```
-类似问题：
-> 反射机制的优缺点(君*科技)
-> Java反射你怎么用的？（吉*航空）
-```
-
-略
-
-#### 3. 实现 Java 反射的类有什么？(君*科技)
-
-```
-类似问题：
-> Java反射 API 有几类？(北京*蓝)
-```
-
-问 API。
-
-#### 4. 反射是怎么实现的？（上海立*网络）
-
-从 Class 说起。
-
-
-
-### 2.2 Class 的理解
-
-#### 1. Class 类的作用？生成 Class 对象的方法有哪些？(顺*)
-
-反射的源头。主要有三种。
-
-#### 2. Class.forName("全路径") 会调用哪些方法？会调用构造方法吗？加载的类会放在哪？（上*银行外包）
-
-Class.forName() 会执行执行类构造器<clinit>() 方法。
-
-不会调用构造方法
-
-加载的类放在方法区。
-
-### 2.3 类的加载
-
-#### 1. 类加载流程（汇\*\*通、同\*顺、凡*科技）
-
-略
-
-###  2.4 创建对象
-
-#### 1. 说一下创建对象的几种方法？（华油***集团、\*科软、凡\*科技）
-
-```
-类似问题：
-> 除了使用new创建对象之外，还可以用什么方法创建对象？(*云网络)
-```
-
-![image-20221214145240412](images/image-20221214145240412.png)
-
-
-
-#### 2. 如何找到对象实际类的？（*度）
-
-对象.getClass();
-
-```
-Object obj = new Date();
-
-obj.getClass();// 获取到的是Date。
-```
-
-
-
-#### 3. Java 反射创建对象效率高还是通过 new 创建对象的效率高？(三*重工)
-
-new 的方式。
-
-### 2.5 调用属性、方法
-
-#### 1. 如何利用反射机制来访问一个类的方法？（神州**软件）
-
-```
-调用指定的方法（步骤）
-步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法
-步骤2. setAccessible(true)：确保此方法是可访问的
-步骤3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。
-     invoke()的返回值即为Method对应的方法的返回值
-     特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null
-```
-
-
-
-#### 2. 说一下 Java 反射获取私有属性，如何改变值？（阿\*\*\**麻信用项目组）
-
-```
-调用指定的属性（步骤）
-步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性
-步骤2. setAccessible(true)：确保此属性是可以访问的
-步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作）
-                       或 set(Object obj,Object value) （设置的操作）进行操作。
-```
-
-```
-针对于核心源码的api，内部的私有的结构在jdk17中就不可以通过反射调用了。
-```
-
Index: src/java/javase review/09.随堂复习与企业真题（异常处理）.md
===================================================================
diff --git a/src/java/javase review/09.随堂复习与企业真题（异常处理）.md b/src/java/javase review/09.随堂复习与企业真题（异常处理）.md
deleted file mode 100644
--- a/src/java/javase review/09.随堂复习与企业真题（异常处理）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,293 +0,0 @@
----
-order: 09
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（异常处理）
-
-***
-
-## 一、随堂复习
-
-### 1. 异常的概述
-
-```
-1. 什么是异常？
-指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。
-
-2. 异常的抛出机制
-Java中把不同的异常用不同的类表示，一旦发生某种异常，就`创建该异常类型的对象`，并且抛出（throw）。
-然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常
-对象将会导致程序终止。
-
-3. 如何对待异常
- 对于程序出现的异常，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是程序员在编写程序时，
- 就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、
- 以及`异常的处理`，保证代码的`健壮性`。
-```
-
-### 2. 异常的体系结构及常见的异常
-
-```
-java.lang.Throwable:异常体系的根父类
-    |---java.lang.Error:错误。Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。
-                         一般不编写针对性的代码进行处理。
-               |---- StackOverflowError、OutOfMemoryError
-
-    |---java.lang.Exception:异常。我们可以编写针对性的代码进行处理。
-               |----编译时异常：(受检异常)在执行javac.exe命令时，出现的异常。
-                    |----- ClassNotFoundException
-                    |----- FileNotFoundException
-                    |----- IOException
-               |----运行时异常：(非受检异常)在执行java.exe命令时，出现的异常。
-                    |---- ArrayIndexOutOfBoundsException
-                    |---- NullPointerException
-                    |---- ClassCastException
-                    |---- NumberFormatException
-                    |---- InputMismatchException
-                    |---- ArithmeticException
-```
-
-```
-【面试题】说说你在开发中常见的异常都有哪些？
-
-开发1-2年：
-|----编译时异常：(受检异常)在执行javac.exe命令时，出现的异常。
-    |----- ClassNotFoundException
-    |----- FileNotFoundException
-    |----- IOException
-|----运行时异常：(非受检异常)在执行java.exe命令时，出现的异常。
-    |---- ArrayIndexOutOfBoundsException
-    |---- NullPointerException
-    |---- ClassCastException
-    |---- NumberFormatException
-    |---- InputMismatchException
-    |---- ArithmeticException
-
-开发3年以上：
-OOM。
-```
-
-### 3. 异常处理的方式
-
-```
-过程1：“抛”
- >"自动抛" ： 程序在执行的过程当中，一旦出现异常，就会在出现异常的代码处，自动生成对应异常类的对象，并将此对象抛出。
-
- >"手动抛" ：程序在执行的过程当中，不满足指定条件的情况下，我们主动的使用"throw + 异常类的对象"方式抛出异常对象。
-
-
-过程2：“抓”
-    狭义上讲：try-catch的方式捕获异常，并处理。
-    广义上讲：把“抓”理解为“处理”。则此时对应着异常处理的两种方式：① try-catch-finally ② throws
-```
-
-#### 3.1 try-catch-finally
-
-```
-1. 基本结构：
-try{
-   ...... //可能产生异常的代码
-}
-catch( 异常类型1 e ){
-   ...... //当产生异常类型1型异常时的处置措施
-}
-catch( 异常类型2 e ){
-   ......     //当产生异常类型2型异常时的处置措施
-}
-finally{
-   ...... //无论是否发生异常，都无条件执行的语句
-}
-
-2. 使用细节：
-> 将可能出现异常的代码声明在try语句中。一旦代码出现异常，就会自动生成一个对应异常类的对象。并将此对象抛出。
-> 针对于try中抛出的异常类的对象，使用之后的catch语句进行匹配。一旦匹配上，就进入catch语句块进行处理。
-  一旦处理接触，代码就可继续向下执行。
-> 如果声明了多个catch结构，不同的异常类型在不存在子父类关系的情况下，谁声明在上面，谁声明在下面都可以。
-  如果多个异常类型满足子父类的关系，则必须将子类声明在父类结构的上面。否则，报错。
-> catch中异常处理的方式：
-   ① 自己编写输出的语句。
-   ② printStackTrace()：打印异常的详细信息。 （推荐）
-   ③ getMessage()：获取发生异常的原因。
-> try中声明的变量，出了try结构之后，就不可以进行调用了。
-> try-catch结构是可以嵌套使用的。
-```
-
-```
-3. finally的使用说明：
-3.1 finally的理解
-> 我们将一定要被执行的代码声明在finally结构中。
-> 更深刻的理解：无论try中或catch中是否存在仍未被处理的异常，无论try中或catch中是否存在return语句等，finally
-  中声明的语句都一定要被执行。
-
-> finally语句和catch语句是可选的，但finally不能单独使用。
-
-3.2 什么样的代码我们一定要声明在finally中呢？
-> 我们在开发中，有一些资源（比如：输入流、输出流，数据库连接、Socket连接等资源），在使用完以后，必须显式的进行
-关闭操作，否则，GC不会自动的回收这些资源。进而导致内存的泄漏。
-  为了保证这些资源在使用完以后，不管是否出现了未被处理的异常的情况下，这些资源能被关闭。我们必须将这些操作声明
-在finally中！
-```
-
-#### 3.2 throws
-
-```
-1. 格式：在方法的声明除，使用"throws 异常类型1,异常类型2,..."
-
-2. 举例：
-
-public void test() throws 异常类型1,异常类型2,.. {
-    //可能存在编译时异常
-}
-
-
-3. 是否真正处理了异常？
-> 从编译是否能通过的角度看，看成是给出了异常万一要是出现时候的解决方案。此方案就是，继续向上抛出(throws)。
-> 但是，此throws的方式，仅是将可能出现的异常抛给了此方法的调用者。此调用者仍然需要考虑如何处理相关异常。
-  从这个角度来看，throws的方式不算是真正意义上处理了异常。
-
-
-4. 方法的重写的要求：(针对于编译时异常来说的)
-子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出的异常类型的子类。
-```
-
-开发中的经验之谈：
-
-```
-开发中，如何选择异常处理的两种方式？(重要、经验之谈)
-- 如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，
-  保证不出现内存泄漏。
-- 如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catch-finally
-  进行处理，不能throws。
-- 开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常，
-  我们通常选择使用throws，而方法a中通常选择使用try-catch-finally。
-```
-
-### 4. 手动 throw 异常对象
-
-```
-在方法内部，满足指定条件的情况下，使用"throw 异常类的对象"的方式抛出。
-```
-
-### 5. 如何自定义异常类
-
-```
-① 继承于现有的异常体系。通常继承于RuntimeException \ Exception
-② 通常提供几个重载的构造器
-③ 提供一个全局常量，声明为：static final long serialVersionUID;
-```
-
-```
-为什么需要自定义异常类？
-我们其实更关心的是，通过异常的名称就能直接判断此异常出现的原因。既然如此，我们就有必要在实际开发场景中，
-不满足我们指定的条件时，指明我们自己特有的异常类。通过此异常类的名称，就能判断出具体出现的问题。
-```
-
-## 二、企业真题
-
-### 2.1 异常概述
-
-#### 1. Java 的异常体系简单介绍下（网*）
-
-```
-包含问题：
-> 4.异常的顶级接口是什么（软**力）
-> 异常类的继承关系,exception下都有哪些类？（上海*冉信息）
-```
-
-略
-
-#### 2. Java 异常处理机制（*科软）
-
-两种处理方案：try-catch-finally；throws
-
-#### 3. 异常的两种类型，Error 和 Exception 的区别 (上海冠*新创、北京中\*\*译、\*度)
-
-略
-
-#### 4. 运行时异常与一般异常有何异同？（华*思为）
-
-运行时异常：RuntimeException
-
-- 编译可以通过。在运行时可能抛出。出现的概率高一些；一般针对于运行时异常，都不处理。
-
-一般异常：Exception
-
-- 编译不能通过。要求必须在编译之前，考虑异常的处理。不处理编译不通过。
-
-#### 5. 说几个你常见到的异常（华油**普）
-
-```
-类似问题：
-> 请列出Java中常见的几种异常？（百*园）
-> 给我一个你最常见到的runtime exception。（*蝶）
-```
-
-略
-
-###  2.2 try-catch-finally
-
-#### 1. 说说 final、finally、finalize 的区别（北京中\*\*译、艾\*软件、拓*思、\*科软）
-
-```
-类似问题：
-> 1. finally和final的区别（*科软）
-```
-
-略。
-
-#### 2. 如果不使用 try-catch，程序出现异常会如何？(上海冠*新创科技)
-
-对于当前方法来讲，如果不使用 try-catch，则在出现异常对象以后会抛出此对象。如果没有处理方案，就会终止程序的执行。
-
-#### 3. try ... catch 捕捉的是什么异常？（北京亿*东方）
-
-Exception。非 Error
-
-#### 4. 如果执行 finally 代码块之前方法返回了结果或者 jvm 退出了，这时 finally 块中的代码还会执行吗？(恒*电子)
-
-特别的：System.exit(0);
-
-#### 5. 在 try 语句中有 return 语句，最后写 finally 语句，finally 语句中的 code 会不会执行？何时执行？如果执行是在 return 前还是后（拓*思、华**为）
-
-略
-
-#### 6. 捕获异常在 catch 块里一定会进入 finally 吗？catch 里能 return 吗？catch 里 return 还会进 finally 吗？在 try 里 return 是什么情况？（*蓝）
-
-略
-
-### 2.3 throw 与 throws
-
-#### 1. throw 和 throws 的区别？（北京亿**方、北京新\*阳光）
-
-角度 1："形"，即使用的格式
-
-```
-throw:使用在方法内部，“throw 异常类的对象”
-throws:使用在方法的声明处，"throws 异常类1,异常类2,..."
-```
-
-角度 2："角色"或作用不同。
-
-```
-上游排污，下游治污。
-
-过程1：“抛”
-	>throw
-过程2：“抓”
-    > try-catch ; throws
-```
-
-
-
-#### 2. 子类重写父类抛出异常的方法，能否抛出比父类更高级别的异常类（顺*）
-
-不能！
-
-### 2.4 自定义异常
-
-#### 1. 如何自定义一个异常？（*软国际）
-
-略
-
Index: src/java/javase review/11.随堂复习与企业真题（常用类与基础API）.md
===================================================================
diff --git a/src/java/javase review/11.随堂复习与企业真题（常用类与基础API）.md b/src/java/javase review/11.随堂复习与企业真题（常用类与基础API）.md
deleted file mode 100644
--- a/src/java/javase review/11.随堂复习与企业真题（常用类与基础API）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,159 +0,0 @@
----
-order: 12
-categories:
-  - Java
----
-
-
-
-# 第 11 章：随堂复习与企业真题（常用类与基础 API）
-
-***
-
-## 一、随堂复习
-
-### 1. String 类
-
-- String 的声明：final 修饰、实现了 Comparable 接口
-- String 的不可变性
-- String 的两种定义方式：① 字面量的定义方式 String s = "hello" ② new 的方式：String s = new String("hello");
-  - String 的内存解析：字符串常量池、堆内存的使用
-  - String s = new String("hello");在内存中创建的对象的个数。
-- String 的连接操作：+
-  - 常量 + 常量、变量 + 常量、变量 + 变量、concat(String otherString)
-  - String intern()
-- 熟悉 String 的构造器、与其他结构之间的转换、常用方法
-  - 编码和解码
-    - 编码：字符、字符串 --> 字节、字节数组。对应着编码集
-    - 解码：字节、字节数组 --> 字符、字符串。对应着解码集
-    - 规则：解码集必须使用当初编码时使用的编码集。只要不一致，就可能出现乱码！
-- String 相关的算法问题。
-
-### 2. StringBuffer、StringBuilder 类
-
-- [面试题]String、StringBuffer、StringBuilder 的区别
-- 知道什么场景下使用 StringBuffer、StringBuilder
-
-### 3. jdk8 之前的日期、时间 API
-
-- System 的 currentTimeMillis()
-- 两个 Date 的使用
-- SimpleDateFormat 用于格式化、解析
-- Calendar 日历类的使用
-
-### 4. jdk8 中新的日期、时间 API
-
-- LocalDate、LocalTime、LocalDateTime -->类似于 Calendar
-- Instant  -->类似于 Date
-- DateTimeFormatter --->类似于 SimpleDateFormat
-
-### 5. 比较器 (重点)
-
-- 自然排序涉及到 Comparable
-  - compareTo(Object obj)
-- 定制排序涉及到 Comparator
-  - compare(Object obj1,Object obj2)
-
-### 6. 其它 API
-
-了解
-
-
-
-## 二、企业真题
-
-### 2.1 String
-
-#### 1. 以下两种方式创建的 String 对象有什么不同？（*团）
-
-```java
-String str = new String("test");
-
-String str = "test";
-```
-
-略
-
-#### 2. String s = new String("xyz");创建了几个 String Object? （新*陆）
-
-两个
-
-#### 3. String a="abc" String b="a"+"bc" 问 a==b?（网*邮箱）
-
-是！
-
-#### 4. String 中“+”怎样实现？（阿*）
-
-常量 + 常量：略
-
-变量 + 常量、变量 + 变量：创建一个 StringBuilder 的实例，通过 append() 添加字符串，最后调用 toString() 返回一个字符串。（toString() 内部 new 一个 String 的实例）
-
-
-
-#### 5. Java 中 String 是不是 final 的？（凡*科技）
-
-```
-类似问题：
-> String被哪些类继承？（网*邮箱）
-> 是否可以继承String类?（湖南*利软件）
-> String 是否可以继承?（阿*）
-```
-
-是
-
-#### 6. String 为啥不可变，在内存中的具体形态？（阿*）
-
-规定不可变。
-
-String：提供字符串常量池。
-
-#### 7. String 可以在 switch 中使用吗？(上海*睿)
-
-可以。从 jdk7 开始可以使用
-
-#### 8. String 中有哪些方法？列举几个（闪*购）
-
-。。。
-
-#### 9. subString() 到底做了什么？(银*数据)
-
-String str = "hello";
-
-String subStr = str.subString(1,3);  //底层是 new 的方式返回一个 subStr，实体内容是"el"
-
-### 2.2 String, StringBuffer, StringBuilder
-
-#### 1. Java 中操作字符串有哪些类？他们之间有什么区别。（南*电网）
-
-```
-类似问题：
-> String 和 StringBuffer区别？(亿*国际、天*隆、*团)
-> StringBuilder和StrignBuffer的区别？（平*金服）
-> StringBuilder和StringBuffer的区别以及实现？（*为）
-```
-
-```
-> String:不可变的字符序列;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）
-> StringBuffer:可变的字符序列;JDK1.0声明，线程安全的，效率低;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）
-> StringBuilder:可变的字符序列;JDK5.0声明，线程不安全的,效率高;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）
-```
-
-#### 2. String 的线程安全问题（闪*购）
-
-线程不安全的
-
-#### 3. StringBuilder 和 StringBuffer 的线程安全问题（润*软件）
-
-略
-
-
-
-###  2.3 Comparator 与 Comparable
-
-#### 1. 简单说说 Comparable 和 Comparator 的区别和场景？（软**力）
-
-略
-
-#### 2. Comparable 接口和 Comparator 接口实现比较（阿*）
-
-略
Index: src/java/javase review/02.随堂复习与企业真题（变量与运算符）.md
===================================================================
diff --git a/src/java/javase review/02.随堂复习与企业真题（变量与运算符）.md b/src/java/javase review/02.随堂复习与企业真题（变量与运算符）.md
deleted file mode 100644
--- a/src/java/javase review/02.随堂复习与企业真题（变量与运算符）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,1277 +0,0 @@
----
-order: 2
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（变量与运算符）
-
-***
-
-## 一、随堂复习
-
-### 1.1 关键字、保留字
-
-- 关键字：被 Java 赋予特殊含义的字符串。
-  - 官方规范中有 50 个关键字
-  - true、false、null 虽然不是关键字，但是可以当做关键字来看待。
-
-- 保留字：goto、const
-
-### 1.2 标识符
-
-- 标识符：凡是可以自己命名的地方，都是标识符。
-  - 比如：类名、变量名、方法名、接口名、包名、常量名等
-- 记住：标识符命名的规则（必须要遵守的，否则编译不通过）
-
-```
-> 由26个英文字母大小写，0-9 ，_或 $ 组成
-> 数字不可以开头。
-> 不可以使用关键字和保留字，但能包含关键字和保留字。
-> Java中严格区分大小写，长度无限制。
-> 标识符不能包含空格。
-```
-
-- 记住：标识符命名的规范（建议遵守。如果不遵守，编译和运行都能正常执行。只是容易被人鄙视）
-
-```
-> 包名：多单词组成时所有字母都小写：xxxyyyzzz。
-  例如：java.lang、com.atguigu.bean
-  
-> 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz
-  例如：HelloWorld，String，System等
-  
-> 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz
-  例如：age,name,bookName,main,binarySearch,getName
-  
-> 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ
-  例如：MAX_VALUE,PI,DEFAULT_CAPACITY
-```
-
-- “见名知意”
-
-```java
-class IdentifierTest{
-	public static void main(String[] args){
-		
-		int abc = 12;
-		int age = 12; //age :标识符
-
-
-		char gender = '男';
-
-		char c1 = '女';
-		
-		//不推荐的写法
-		//int myage = 12;
-
-		//System.out.println(myage);
-
-		int myAge = 12;
-		
-	}
-
-	public static void main1(String[] args){
-		
-	}
-}
-
-
-class _a$bc{
-}
-
-/*
-class 1abc{
-}
-*/
-
-class Public{
-}
-
-class publicstatic{
-}
-
-class BiaoShiFuTest{
-}
-```
-
-
-
-### 1.3 变量的基本使用（重点）
-
-1. 变量的理解：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化
-2. 变量的构成包含三个要素：数据类型、变量名、存储的值
-3. Java 中变量声明的格式：数据类型 变量名 = 变量值
-
-```java
-class VariableTest {
-	public static void main(String[] args) {
-		
-		
-		//定义变量的方式 1：
-		char gender; //过程 1：变量的声明
-		gender = '男'; //过程 2：变量的赋值（或初始化）
-
-		gender = '女';
-		
-		//定义变量的方式 2：声明与初始化合并
-		int age = 10;
-
-
-		System.out.println(age);
-		System.out.println("age = " + age);
-		System.out.println("gender = " + gender);
-
-		//在同一个作用域内，不能声明两个同名的变量
-		//char gender = '女';
-
-		gender = '男';
-		
-		//由于 number 前没有声明类型，即当前 number 变量没有提前定义。所以编译不通过。
-		//number = 10;
-
-		byte b1 = 127;
-		//b1 超出了 byte 的范围，编译不通过。
-		//b1 = 128;
-
-	}
-
-	public static void main123(String[] args) {
-		//System.out.println("gender = " + gender);
-
-		char gender = '女';
-		
-	}
-}
-```
-
-说明：
-
-1. 定义变量时，变量名要遵循标识符命名的规则和规范。
-2. 说明：
-   ① 变量都有其作用域。变量只在作用域内是有效的，出了作用域就失效了。
-   ② 在同一个作用域内，不能声明两个同名的变量
-   ③ 定义好变量以后，就可以通过变量名的方式对变量进行调用和运算。
-   ④ 变量值在赋值时，必须满足变量的数据类型，并且在数据类型有效的范围内变化。
-
-### 1.4 基本数据类型变量的使用（重点）
-
-1、Java 中的变量按照数据类型来分类：
-
-```
-
-	基本数据类型（8种）:
-		整型：byte \ short \ int \ long 
-		浮点型：float \ double 
-		字符型：char
-		布尔型：boolean
-
-	引用数据类型：
-		类(class)
-		数组(array)
-		接口(interface)
-
-		枚举(enum)
-		注解(annotation)
-		记录(record)
-```
-
-测试整型和浮点型：
-
-```java
-/*
-测试整型和浮点型变量的使用
-
-
-*/
-class VariableTest1 {
-	public static void main(String[] args) {
-		
-		//1.测试整型变量的使用
-		// byte(1 字节=8bit) \ short(2 字节) \ int(4 字节) \ long(8 字节) 
-
-		byte b1 = 12;
-		byte b2 = 127;
-		//编译不通过。因为超出了 byte 的存储范围
-		//byte b3 = 128;
-
-		short s1 = 1234;
-
-		int i1 = 123234123;
-		//① 声明 long 类型变量时，需要提供后缀。后缀为'l'或'L'
-		long l1 = 123123123L;
-
-		//② 开发中，大家定义整型变量时，没有特殊情况的话，通常都声明为 int 类型。
-
-		//2.测试浮点类型变量的使用
-		//float \ double
-		double d1 = 12.3;
-		//① 声明 long 类型变量时，需要提供后缀。后缀为'f'或'F'
-		float f1 = 12.3f;
-		System.out.println("f1 = " + f1);
-
-		//② 开发中，大家定义浮点型变量时，没有特殊情况的话，通常都声明为 double 类型，因为精度更高。
-
-		//③ float 类型表数范围要大于 long 类型的表数范围。但是精度不高。
-
-		//测试浮点型变量的精度
-		//结论：通过测试发现浮点型变量的精度不高。如果在开发中，需要极高的精度，需要使用 BigDecimal 类替换浮点型变量。
-		//测试 1
-		System.out.println(0.1 + 0.2);
-
-		//测试 2:
-		float ff1 = 123123123f;
-		float ff2 = ff1 + 1;
-		System.out.println(ff1);
-		System.out.println(ff2);
-		System.out.println(ff1 == ff2);
-		
-	}
-}
-```
-
-测试字符型和布尔型：
-
-```java
-/*
-测试字符类型和布尔类型的使用
-
-
-*/
-class VariableTest2 {
-	public static void main(String[] args) {
-		
-		//1.字符类型：char(2 字节)
-
-		//表示形式 1：使用一对''表示，内部有且仅有一个字符
-		char c1 = 'a';
-		char c2 = '中';
-		char c3 = '1';
-		char c4 = '%';
-		char c5 = 'γ';
-		
-		//编译不通过
-		//char c6 = '';
-		//char c7 = 'ab';
-
-		//表示形式 2：直接使用 Unicode 值来表示字符型常量。
-		char c8 = '\u0036';
-		System.out.println(c8);
-
-		//表示形式 3：使用转义字符
-		char c9 = '\n';
-		char c10 = '\t';
-		System.out.println("hello" + c10 + "world");
-
-		//表示形式 4：使用具体字符对应的数值（比如 ASCII 码）
-		char c11 = 97;
-		System.out.println(c11);//a
-
-		char c12 = '1';
-		char c13 = 1;
-
-		//2. 布尔类型：boolean
-		//① 只有两个取值：true、false
-		boolean bo1 = true;
-		boolean bo2 = false;
-		
-		//编译不通过
-		//boolean bo3 = 0;
-		//② 常使用在流程控制语句中。比如：条件判断、循环结构等
-		boolean isMarried = true;
-		if(isMarried){
-			System.out.println("很遗憾，不能参加单身派对了");
-		}else{
-			System.out.println("可以多谈几个女朋友或男朋友");
-		}
-		//③ 了解：我们不谈 boolean 类型占用的空间大小。但是，真正在内存中分配的话，使用的是 4 个字节。
-	}
-}
-
-```
-
-
-
-### 1.5 基本数据类型变量间的运算规则（重点）
-
-#### 1.5.1 自动类型提升
-
-```java
-/*
-测试基本数据类型变量间的运算规则。
-
-1. 这里提到可以做运算的基本数据类型有 7 种，不包含 boolean 类型。
-2. 运算规则包括：
-		① 自动类型提升
-		② 强制类型转换
-
-3. 此 VariableTest3.java 用来测试自动类型提升
-
-规则：当容量小的变量与容量大的变量做运算时，结果自动转换为容量大的数据类型。
-
-    byte 、short 、char ---> int  --->  long  ---> float ---> double
-
-	特别的：byte、short、char 类型的变量之间做运算，结果为 int 类型。
-
-说明：此时的容量小或大，并非指占用的内存空间的大小，而是指表示数据的范围的大小。
-     long(8 字节) 、float(4 字节)
-
-*/
-class VariableTest3 {
-	public static void main(String[] args) {
-		
-		int i1 = 10;
-		int i2 = i1;
-
-		long l1 = i1;
-
-		float f1 = l1;
-
-
-		byte b1 = 12;
-		int i3 = b1 + i1;
-
-		//编译不通过
-		//byte b2 = b1 + i1;
-		
-		//**********************************************
-		//特殊的情况 1：byte、short 之间做运算
-		byte b3 = 12;
-		short s1 = 10;
-		//编译不通过
-		//short s2 = b3 + s1;
-		i3 = b3 + s1;
-
-		byte b4 = 10;
-		//编译不通过
-		//byte b5 = b3 + b4;
-
-		//特殊的情况 2：char
-		char c1 = 'a';
-		//编译不通过
-		//char c2 = c1 + b3;
-		int i4 = c1 + b3;
-
-
-		//**********************************************
-		//练习 1：
-		long l2 = 123L;
-		long l3 = 123; //理解为：自动类型提升（int--->long）
-
-		//long l4 = 123123123123; //123123123123 理解为 int 类型，因为超出了 int 范围，所以报错。
-		long l5 = 123123123123L;//此时的 123123123123L 就是使用 8 个字节存储的 long 类型的值
-		
-		//练习 2：
-		float f2 = 12.3F;
-		//编译不通过
-		//float f3 = 12.3; //不满足自动类型提升的规则（double --> float）。所以报错
-
-		//练习 3：
-		//规定 1：整型常量，规定是 int 类型。
-		byte b5 = 10;
-		//byte b6 = b5 + 1;
-		int ii1 = b5 + 1;
-		//规定 2：浮点型常量，规定是 double 类型。
-		double dd1 = b5 + 12.3;
-
-		//练习 4：说明为什么不允许变量名是数字开头的。为了“自洽”
-		/*
-		int 123L = 12;
-		long l6 = 123L;
-		*/
-	}
-}
-```
-
-
-
-#### 1.5.2 强制类型转换
-
-```java
-/*
-此 VariableTest4.java 用来测试强制类型转换
-
-规则：
-1. 如果需要将容量大的变量的类型转换为容量小的变量的类型，需要使用强制类型转换
-2. 强制类型转换需要使用强转符：()。在 () 内指明要转换为的数据类型。
-3. 强制类型转换过程中，可能导致精度损失。
-*/
-class VariableTest4 {
-	public static void main(String[] args) {
-		
-		double d1 = 12;//自动类型提升
-		
-		//编译失败
-		//int i1 = d1;
-
-		int i2 = (int)d1;
-		System.out.println(i2);
-
-
-		long l1 = 123;
-		//编译失败
-		//short s1 = l1;
-		short s2 = (short)l1;
-		System.out.println(s2);
-
-
-		//练习
-		int i3 = 12;
-		float f1 = i3;//自动类型提升
-		System.out.println(f1); //12.0
-
-		float f2 = (float)i3; //编译可以通过。只不过可以省略 () 而已。
-		
-		//精度损失的例子 1：
-		double d2 = 12.9;
-		int i4 = (int)d2;
-		System.out.println(i4);
-
-		//精度损失的例子 2：
-		int i5 = 128;
-		byte b1 = (byte)i5;
-		System.out.println(b1); //-128
-
-
-		//实际开发举例：
-		byte b2 = 12;
-		method(b2);
-
-		long l2 = 12L;
-		//编译不通过
-		//method(l2);
-		method((int)l2);
-	}
-
-	public static void method(int num){   //int num = b2;自动类型提升
-		System.out.println("num = " + num);
-	}
-}
-```
-
-
-
-### 1.6 String 类的使用、与基本数据类型变量间的运算（重点）
-
-- String 的认识：字符串。使用一对""表示，内部包含 0 个、1 个或多个字符。
-- String 与 8 种基本数据类型变量间的运算：+。运算的结果是 String 类型。
-
-```java
-/*
-
-基本数据类型与 String 的运算
-
-一、关于 String 的理解
-1. String 类，属于引用数据类型，俗称字符串。
-2. String 类型的变量，可以使用一对""的方式进行赋值。
-3. String 声明的字符串内部，可以包含 0 个，1 个或多个字符。
-
-二、String 与基本数据类型变量间的运算
-1. 这里的基本数据类型包括 boolean 在内的 8 种。
-2. String 与基本数据类型变量间只能做连接运算，使用"+"表示。
-3. 运算的结果是 String 类型。
-
-*/
-class StringTest {
-	public static void main(String[] args) {
-		String str1 = "Hello World!";
-		System.out.println("str1");
-		System.out.println(str1);
-
-
-		String str2 = ""; 
-		String str3 = "a";//char c1 = 'a';
-
-
-		//测试连接运算
-		int num1 = 10;
-		boolean b1 = true;
-		String str4 = "hello";
-
-		System.out.println(str4 + b1);
-
-		String str5 = str4 + b1;
-		String str6 = str4 + b1 + num1;
-		System.out.println(str6);//hellotrue10
-		
-		//思考：如下的声明编译能通过吗？不能
-		//String str7 = b1 + num1 + str4;
-
-		//如何将 String 类型的变量转换为基本数据类型？
-		String str8 = "abc";//不能考虑转换为基本数据类型的。
-
-		int num2 = 10;
-		String str9 = num2 + ""; //"10"
-		//编译不通过
-		//int num3 = (int)str9;
-
-		//如何实现呢？使用 Integer 类。暂时大家了解。
-		int num3 = Integer.parseInt(str9);
-		System.out.println(num3 + 1);
-		
-	}
-}
-```
-
-- 练习 1
-
-```java
-/*
-要求填写自己的姓名、年龄、性别、体重、婚姻状况（已婚用 true 表示，单身用 false 表示）、联系方式等等。
-*/
-class StringExer {
-	public static void main(String[] args) {
-		
-		String name = "李进";
-		int age = 24;
-		char gender = '男';
-		double weight = 130.5;
-		boolean isMarried = false;
-		String phoneNumber = "13012341234";
-
-		String info = "name = " + name + ",age = " + age + ",gender = " + gender + ",weight = " + 
-			weight + ",isMarried = " + isMarried + ",phoneNumber = " + phoneNumber;
-
-		System.out.println(info);
-	}
-}
-
-```
-
-- 练习 2
-
-```java
-class StringExer1 {
-	public static void main(String[] args) {
-		
-		//练习 1：
-		//String str1 = 4;                       //判断对错：no
-		String str2 = 3.5f + "";               //判断 str2 对错：yes
-		System.out.println(str2);              //输出：3.5
-		System.out .println(3+4+"Hello!");     //输出：7Hello!
-		System.out.println("Hello!"+3+4);      //输出：Hello!34
-		System.out.println('a'+1+"Hello!");    //输出：98Hello!
-		System.out.println("Hello"+'a'+1);     //输出：Helloa1
-
-		//练习 2：
-		System.out.println("*    *");				//输出：*    *
-		System.out.println("*\t*");					//输出：*	*
-		System.out.println("*" + "\t" + "*");		//输出：*	*
-		System.out.println('*' + "\t" + "*");		//输出：*	*
-		System.out.println('*' + '\t' + "*");		//输出：51*
-		System.out.println('*' + "\t" + '*');		//输出：*	*
-		System.out.println("*" + '\t' + '*');		//输出：*	*
-		System.out.println('*' + '\t' + '*');		//输出：93
-
-	}
-}
-
-```
-
-
-
-### 1.7 常识：进制的认识
-
-- 熟悉：二进制（以 0B、0b 开头）、十进制、八进制（以 0 开头）、十六进制（以 0x 或 0X 开头）的声明方式。
-- 二进制的理解
-  - 正数：原码、反码、补码三码合一。
-  - 负数：原码、反码、补码不相同。了解三者之间的关系。
-  - 计算机的底层是以`补码`的方式存储数据的。
-- 熟悉：二进制与十进制之间的转换
-- 了解：二进制与八进制、十六进制间的转换
-
-### 1.8 运算符（较常用的是重点）
-
-#### 1.8.1 算术运算符
-
-```java
-/*
-测试运算符的使用 1：算术运算符的使用
-
-
-1. +  -  +  -  *  /  %  (前)++  (后)++  (前)--  (后)--  +
-
-
-*/
-class AriTest {
-	public static void main(String[] args) {
-		//*******************************
-		//除法： /
-		int m1 = 12;
-		int n1 = 5;
-		int k1 = m1 / n1;
-		System.out.println(k1);//2
-
-		System.out.println(m1 / n1 * n1);//10
-		
-		//*******************************
-		//取模（或取余）： %
-		int i1 = 12;
-		int j1 = 5;
-		System.out.println(i1 % j1); //2
-
-		//开发中，经常用来判断某个数 num1 能整除另外一个数 num2。num1 % num2 == 0
-		//比如：判断 num1 是否是偶数：num1 % 2 == 0
-		
-		//结论：取模以后，结果与被模数的符号相同
-		int i2 = -12;
-		int j2 = 5;
-		System.out.println(i2 % j2); //-2
-
-		int i3 = 12;
-		int j3 = -5;
-		System.out.println(i3 % j3); //2
-
-		int i4 = -12;
-		int j4 = -5;
-		System.out.println(i4 % j4); //-2
-		
-
-		//*******************************
-		//(前)++ :先自增 1，再运算
-		//(后)++ :先运算，后自增 1
-		int a1 = 10;
-		int b1 = ++a1;
-		System.out.println("a1 = " + a1 + ",b1 = " + b1); //a1 = 11,b1 = 11
-
-		int a2 = 10;
-		int b2 = a2++;
-		System.out.println("a2 = " + a2 + ",b2 = " + b2); //a2 = 11,b2 = 10
-
-		//练习 1：
-		int i = 10;
-		//i++;
-		++i;
-		System.out.println("i = " + i);//11
-
-		//练习 2：
-		short s1 = 10;
-		//方式 1：
-
-		//编译不通过
-		//s1 = s1 + 1;
-
-		//s1 = (short)(s1 + 1);
-		//System.out.println(s1);
-
-		//方式 2：
-		s1++;
-		System.out.println(s1);
-
-		//*******************************
-		//(前)-- :先自减 1，再运算
-		//(后)-- :先运算，再自减 1
-		//略
-		
-		//结论：++ 或 -- 运算，不会改变变量的数据类型！
-
-		//+ :连接符，只适用于 String 与其他类型的变量间的运算，而且运算的结果也是 String 类型。
-
-	}
-}
-
-```
-
-练习 1：
-
-```java
-/*
-随意给出一个三位的整数，打印显示它的个位数，十位数，百位数的值。
-格式如下：
-数字 xxx 的情况如下：
-个位数：
-十位数：
-百位数：
-
-例如：
-数字 153 的情况如下：
-个位数：3
-十位数：5
-百位数：1
-
-*/
-class AriExer {
-	public static void main(String[] args) {
-		
-		int num = 153;
-		int ge = num % 10; //个位
-		int shi = num / 10 % 10; //十位。或者 int shi = num % 100 / 10
-		int bai = num / 100;
-
-		System.out.println("个位是：" + ge);
-		System.out.println("十位是：" + shi);
-		System.out.println("百位是：" + bai);
-
-	}
-}
-
-```
-
-练习 2：
-
-```java
-/*
-
-案例 2：为抵抗洪水，战士连续作战 89 小时，编程计算共多少天零多少小时？
-*/
-class AriExer1 {
-	public static void main(String[] args) {
-
-		int hours = 89;
-
-		int day = hours / 24;
-		int hour = hours % 24;
-
-		System.out.println("共奋战了" + day + "天零" + hour + "小时");
-
-
-		//额外的练习 1：
-		System.out.println("5+5=" + 5 + 5);
-		System.out.println("5+5=" + (5 + 5));
-
-		//额外的练习 2：
-		byte bb1 = 127;
-		bb1++;
-		System.out.println("bb1 = " + bb1);
-
-		//额外的练习 3：
-		//int i = 1;
-		//int j = i++ + ++i * i++;
-
-		//System.out.println("j = " + j);//10
-
-		//额外的练习 4：
-		int i = 2;
-		int j = i++;
-		System.out.println(j); //2
-
-
-		int k = 2;
-		int z = ++k;
-		System.out.println(z);//3
-
-		int m = 2;
-		m = m++;
-		System.out.println(m); //2
-
-	}
-}
-
-```
-
-
-
-#### 1.8.2 赋值运算符
-
-```java
-/*
-测试运算符的使用 2：赋值运算符
-
-1. =   +=、 -=、*=、 /=、%=  
-
-2. 说明：
-① 当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。
-② 支持连续赋值。
-③ +=、 -=、*=、 /=、%=  操作，不会改变变量本身的数据类型。
-*/
-class SetValueTest {
-	public static void main(String[] args) {
-
-		//***********************************
-		int i = 5;
-
-		long l = 10; //自动类型提升
-
-		byte b = (byte)i; //强制类型转换
-
-		
-		//操作方式 1：
-		int a1 = 10;
-		int b1 = 10;
-
-		//操作方式 2：连续赋值
-		int a2;
-		int b2;
-		//或合并：int a2,b2;
-		a2 = b2 = 10;
-
-		System.out.println(a2 + "," + b2);
-
-		//操作方式 3：
-		//int a3 = 10;
-		//int b3 = 20;
-
-		int a3 = 10,b3 = 20;
-		System.out.println(a3 + "," + b3);
-
-		//***********************************
-		//说明 += 的使用
-		int m1 = 10;
-		m1 += 5; //类似于 m1 = m1 + 5;
-		System.out.println(m1);
-
-		byte by1 = 10;
-		by1 += 5; //by1 = by1 + 5 操作会编译报错。应该写为：by1 = (byte)(by1 + 5);
-		System.out.println(by1);
-
-
-		int m2 = 1;
-		m2 *= 0.1; // m2 = (int)(m2 * 0.1)
-		System.out.println(m2);
-
-		//练习 1：如何实现变量的值增加 2。
-		//方式 1：
-		int n1 = 10;
-		n1 = n1 + 2;
-		
-
-		//方式 2：推荐
-		int n2 = 10;
-		n2 += 2;
-
-		//错误的写法：
-		//int n3 = 10;
-		//n3++++;
-
-		//练习 2：如何实现变量的值增加 1。
-		//方式 1：
-		int i1 = 10;
-		i1 = i1 + 1;
-		
-
-		//方式 2：
-		int i2 = 10;
-		i2 += 1;
-
-		//方式 3：推荐
-		int i3 = 10;
-		i3++; //++i3;
-
-	}
-}
-
-```
-
-
-
-#### 1.8.3 比较运算符
-
-```java
-/*
-测试运算符的使用 3：比较运算符
-
-1.  ==  !=  >   <   >=   <=  instanceof
-
-2. 说明
-① instanceof 在面向对象的多态性的位置讲解。
-② ==  !=  >   <   >=   <= 适用于基本数据类型。(细节：>   <   >=   <=不适用于 boolean 类型)
-  运算的结果为 boolean 类型。
-③ 了解： ==  !=  可以适用于引用数据类型
-④ 区分：== 与 = 
-
-*/
-class CompareTest {
-	public static void main(String[] args) {
-		int m1 = 10;
-		int m2 = 20;
-		boolean compare1 = m1 > m2;
-		System.out.println(compare1);
-
-		int n1 = 10;
-		int n2 = 20;
-		System.out.println(n1 == n2);//false
-		System.out.println(n1 = n2);//20
-
-		boolean b1 = false;
-		boolean b2 = true;
-		System.out.println(b1 == b2);//false
-		System.out.println(b1 = b2);//true
-
-	}
-}
-
-```
-
-
-
-#### 1.8.4 逻辑运算符
-
-```java
-/*
-测试运算符的使用 4：逻辑运算符
-
-1.  & &&  |  ||  ! ^
-2. 说明：
-① 逻辑运算符针对的都是 boolean 类型的变量进行的操作
-② 逻辑运算符运算的结果也是 boolean 类型。
-③ 逻辑运算符常使用条件判断结构、循环结构中
-
-
-*/
-class LogicTest {
-	public static void main(String[] args) {
-				
-		/*
-		区分：& 和 &&
-		
-		1、相同点：两个符号表达的都是"且"的关系。只有当符号左右两边的类型值均为 true 时，结果才为 true。
-
-		2、执行过程：
-			1）如果符号左边是 true，则& 、&& 都会执行符号右边的操作
-			2）如果符号左边是 false，则 & 会继续执行符号右边的操作
-			                           && 不会执行符号右边的操作
-		3、开发中，我们推荐使用&& 
-		*/
-		boolean b1 = true;
-		b1 = false;
-
-		int num1 = 10;
-
-		if(b1 & (num1++ > 0)){
-			System.out.println("床前明月光");
-		}else{
-			System.out.println("我叫郭德纲");
-		}
-		
-		System.out.println("num1 = " + num1);
-
-		//
-
-		boolean b2 = true;
-		b2 = false;
-
-		int num2 = 10;
-
-		if(b2 && (num2++ > 0)){
-			System.out.println("床前明月光");
-		}else{
-			System.out.println("我叫郭德纲");
-		}
-		
-		System.out.println("num2 = " + num2);
-
-		//********************************************
-		/*
-		区分：| 和 ||
-		
-		1、相同点：两个符号表达的都是"或"的关系。只要符号两边存在 true 的情况，结果就为 true.
-
-		2、执行过程：
-			1）如果符号左边是 false，则 | 、|| 都会执行符号右边的操作
-			2）如果符号左边是 true，则 | 会继续执行符号右边的操作
-			                          || 不会执行符号右边的操作
-		3、开发中，我们推荐使用||
-		*/
-		boolean b3 = false;
-		b3 = true;
-
-		int num3 = 10;
-
-		if(b3 | (num3++ > 0)){
-			System.out.println("床前明月光");
-		}else{
-			System.out.println("我叫郭德纲");
-		}
-		
-		System.out.println("num3 = " + num3);
-
-		//
-
-		boolean b4 = false;
-		b4 = true;
-
-		int num4 = 10;
-
-		if(b4 || (num4++ > 0)){
-			System.out.println("床前明月光");
-		}else{
-			System.out.println("我叫郭德纲");
-		}
-		
-		System.out.println("num4 = " + num4);
-	}
-}
-
-```
-
-练习：
-
-```java
-/*
-1. 定义类 LogicExer
-2. 定义 main 方法
-3. 定义一个 int 类型变量 a，变量 b，都赋值为 20
-4. 定义 boolean 类型变量 bo1 , 判断++a 是否被 3 整除，并且 a++ 是否被 7 整除，将结果赋值给 bo1
-5. 输出 a 的值，bo1 的值
-6. 定义 boolean 类型变量 bo2 , 判断 b++ 是否被 3 整除，并且++b 是否被 7 整除，将结果赋值给 bo2
-7. 输出 b 的值，bo2 的值
-
-*/
-class LogicExer {
-	public static void main(String[] args) {
-		int a,b;
-		a = b = 20;
-		
-		boolean bo1 = (++a % 3 == 0) && (a++ % 7 == 0);
-
-		System.out.println("a = " + a + ",bo1 = " + bo1);
-
-		
-		boolean bo2 = (b++ % 3 == 0) && (++b % 7 == 0);
-		
-		System.out.println("b = " + b + ",bo2 = " + bo2);
-		
-
-	}
-}
-
-```
-
-
-
-#### 1.8.5 位运算符 (了解)
-
-```java
-/*
-测试运算符的使用 5：位运算符
-
-1. <<   >>   >>>   &  |  ^  ~
-
-2. 说明：
-
-① <<   >>   >>>   &  |  ^  ~ ：针对数值类型的变量或常量进行运算，运算的结果也是数值
-② 
-<< : 在一定范围内，每向左移动一位，结果就在原有的基础上 * 2。（对于正数、负数都适用）
->> : 在一定范围内，每向右移动一位，结果就在原有的基础上 / 2。（对于正数、负数都适用）
-
-3. 面试题：高效的方式计算 2 * 8？ 
-
-2 << 3 或 8 << 1
-
-*/
-class BitTest {
-	public static void main(String[] args) {
-		int num1 = 7;
-		System.out.println("num1 << 1 : " + (num1 << 1));
-		System.out.println("num1 << 2 : " + (num1 << 2));
-		System.out.println("num1 << 3 : " + (num1 << 3));
-		System.out.println("num1 << 28 : " + (num1 << 28));
-		System.out.println("num1 << 29 : " + (num1 << 29));//过犹不及
-
-		int num2 = -7;
-		System.out.println("num2 << 1 : " + (num2 << 1));
-		System.out.println("num2 << 2 : " + (num2 << 2));
-		System.out.println("num2 << 3 : " + (num2 << 3));
-
-		System.out.println(~9);
-		System.out.println(~-10);
-
-		
-		
-
-	}
-}
-
-```
-
-练习：
-
-```java
-/*
-案例 2：如何交换两个 int 型变量的值？String 呢？
-
-*/
-class BitExer {
-	public static void main(String[] args) {
-		
-		int m = 10;
-		int n = 20;
-
-		System.out.println("m = " + m + ",n = " + n);
-
-		//交换两个变量的值
-		//方式 1：声明一个临时变量。（推荐）
-		//int temp = m;
-		//m = n;
-		//n = temp;
-
-		//方式 2：优点：不需要定义临时变量。缺点：难、适用性差（不适用于非数值类型）、可能超出 int 的范围
-		//m = m + n; //30 = 10 + 20;
-		//n = m - n; //10 = 30 - 20;
-		//m = m - n; //20 = 30 - 10;
-
-		//方式 3：优点：不需要定义临时变量。缺点：真难、适用性差（不适用于非数值类型）
-		m = m ^ n;
-		n = m ^ n;//(m ^ n) ^ n ---> m
-		m = m ^ n;
-
-
-		System.out.println("m = " + m + ",n = " + n);
-		
-
-	}
-}
-
-```
-
-
-
-#### 1.8.6 条件运算符
-
-```java
-/*
-测试运算符的使用 6：条件运算符
-
-1. (条件表达式)? 表达式 1 : 表达式 2
-
-2. 说明：
-① 条件表达式的结果是 boolean 类型。
-② 如果条件表达式的结果是 true，则执行表达式 1。否则，执行表达式 2。
-③ 表达式 1 和 表达式 2 需要是相同的类型或能兼容的类型。
-
-④ 开发中，凡是可以使用条件运算符的位置，都可以改写为 if-else。
-          反之，能使用 if-else 结构，不一定能改写为条件运算符。
-  
-  建议，在二者都能使用的情况下，推荐使用条件运算符。因为执行效率稍高。
-
-*/
-class ConditionTest {
-	public static void main(String[] args) {
-		
-		String info = (2 > 10)? "表达式 1" : "表达式 2";
-		System.out.println(info);
-
-		double result = (2 > 1)? 1 : 2.0;
-		System.out.println(result);
-
-		//练习 1：获取两个整数的较大值
-		int m = 10;
-		int n = 20;
-
-		int max = (m > n)? m : n;
-		System.out.println("较大值为：" + max);
-
-		//练习 2：获取三个整数的最大值
-		int i = 20;
-		int j = 30;
-		int k = 23;
-
-		int tempMax = (i > j)? i : j;
-		int finalMax = (tempMax > k)? tempMax : k;
-		System.out.println(finalMax);
-
-		//合并以后的写法：不推荐
-		int finalMax1 = (((i > j)? i : j) > k)? ((i > j)? i : j) : k;
-		System.out.println(finalMax1);
-	}
-}
-
-```
-
-#### 1.8.7 运算符的优先级
-
-- 如果想体现优先级比较高，使用 ()
-- 我们在编写一行执行语句时，不要出现太多的运算符。
-
-## 二、企业真题
-
-### 1. 高效的方式计算 2 * 8 的值 (文\*\*辉、轮*科技)
-
-使用 << 
-
-### 2. &和&&的区别？(恒\*电子、\*度)
-
-略
-
-### 3. Java 中的基本类型有哪些？String 是最基本的数据类型吗？(恒*电子)
-
-8 种基本数据类型。（略）
-
-String 不是，属于引用数据类型。
-
-### 4. Java 中的基本数据类型包括哪些？（*米）
-
-```
-类似问题：
-> Java的基础数据类型有哪些？String是吗？（贝壳）
-```
-
-略
-
-### 5. Java 开发中计算金额时使用什么数据类型？（5*到家）
-
-不能使用 float 或 double，因为精度不高。
-
-使用 BigDecimal 类替换，可以实现任意精度的数据的运算。
-
-### 6. char 型变量中能不能存储一个中文汉字，为什么？(*通快递)
-
-可以的。char c1 = '中';
-
-char c2 = 'a'.
-
-因为 char 使用的是 unicode 字符集，包含了世界范围的所有的字符。
-
-### 7. 代码分析 (君\*科技、新\*陆)
-
-```java
-short s1=1; 
-s1=s1+1;  //有什么错？  =右边是 int 类型。需要强转
-```
-
-```java
-short s1=1;
-s1+=1; //有什么错？没错
-```
-
-
-
-### 8. int i=0; i=i++执行这两句化后变量 i 的值为（*软）
-
-0。
-
-### 9. 如何将两个变量的值互换（北京\*彩、中外\*译咨询）
-
-```java
-String s1 = "abc";
-String s2 = "123";
-
-String temp = s1;
-s1 = s2;
-s2 = temp;
-```
-
-
-
-### 10. boolean 占几个字节（阿**巴）
-
-```
-编译时不谈占几个字节。
-
-但是JVM在给boolean类型分配内存空间时，boolean类型的变量占据一个槽位(slot，等于4个字节)。
-细节：true:1  false:0
-
->拓展：在内存中，byte\short\char\boolean\int\float : 占用1个slot
-              double\long :占用2个slot
-```
-
-
-
-### 11. 为什么 Java 中 0.1 + 0.2 结果不是 0.3？（字*跳动）
-
-在代码中测试 0.1 + 0.2，你会惊讶的发现，结果不是 0.3，而是 0.3000……4。这是为什么？
-
-几乎所有现代的编程语言都会遇到上述问题，包括 JavaScript、Ruby、Python、Swift 和 Go 等。引发这个问题的原因是，它们都采用了`IEEE 754标准`。
-
-> IEEE 是指“电气与电子工程师协会”，其在 1985 年发布了一个 IEEE 754 计算标准，根据这个标准，小数的二进制表达能够有最大的精度上限提升。但无论如何，物理边界是突破不了的，它仍然`不能实现“每一个十进制小数，都对应一个二进制小数”`。正因如此，产生了 0.1 + 0.2 不等于 0.3 的问题。
-
-具体的：
-
-**整数变为二进制，能够做到“每个十进制整数都有对应的二进制数”**，比如数字 3，二进制就是 11；再比如，数字 43 就是二进制 101011，这个毫无争议。
-
-**对于小数，并不能做到“每个小数都有对应的二进制数字”**。举例来说，二进制小数 0.0001 表示十进制数 0.0625（至于它是如何计算的，不用深究）；二进制小数 0.0010 表示十进制数 0.125；二进制小数 0.0011 表示十进制数 0.1875。看，对于四位的二进制小数，二进制小数虽然是连贯的，但是十进制小数却不是连贯的。比如，你无法用四位二进制小数的形式表示 0.125 ~ 0.1875 之间的十进制小数。
-
-所以在编程中，遇见小数判断相等情况，比如开发银行、交易等系统，可以采用`四舍五入`或者“`同乘同除`”等方式进行验证，避免上述问题。
-
-
-
Index: src/java/javase review/06.随堂复习与企业真题（面向对象-基础）.md
===================================================================
diff --git a/src/java/javase review/06.随堂复习与企业真题（面向对象-基础）.md b/src/java/javase review/06.随堂复习与企业真题（面向对象-基础）.md
deleted file mode 100644
--- a/src/java/javase review/06.随堂复习与企业真题（面向对象-基础）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,218 +0,0 @@
----
-order: 06
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（面向对象 - 基础）
-
-***
-
-## 一、随堂复习
-
-### 1. （了解）面向过程 vs 面向对象
-
-- 不管是面向过程、面向对象，都是程序设计的思路。
-- 面向过程：以函数为基本单位，适合解决简单问题。比如：开车
-- 面向对象：以类为基本单位，适合解决复杂问题。比如：造车
-
-### 2. 类、对象
-
-- 类：抽象的，概念上的定义
-- 对象：具体的，类的一个一个的实例。
-- 面向对象完成具体功能的操作的三步流程（非常重要）
-
-```
-步骤1：创建类，并设计类的内部成员（属性、方法）
-步骤2：创建类的对象。比如：Phone p1 = new Phone();
-步骤3：通过对象，调用其内部声明的属性或方法，完成相关的功能
-```
-
-- 对象的内存解析
-  - 创建类的一个对象；创建类的多个对象；方法的调用的内存解析
-- Java 中内存结构的划分
-  - Java 中内存结构划分为：`虚拟机栈、堆、方法区`；程序计数器、本地方法栈
-  - 虚拟机栈：以栈帧为基本单位，有入栈和出栈操作；每个栈帧入栈操作对应一个方法的执行；方法内的局部变量会存储在栈帧中。
-  - 堆空间：new 出来的结构（数组、对象）：① 数组，数组的元素在堆中 ② 对象的成员变量在堆中。
-  - 方法区：加载的类的模板结构。
-
-### 3. 类的成员之一：属性（或成员变量）
-
-- 属性 vs 局部变量
-  - 声明的位置
-  - 内存中存放的位置
-  - 作用域
-  - 权限修饰符
-  - 初始化值
-  - 生命周期
-- 属性 <=> 成员变量 <=>field <=> 字段、域
-
-### 4. 类的成员之二：方法
-
-- 方法的声明：权限修饰符 返回值类型 方法名 (形参列表){ // 方法体}
-  - 重点：返回值类型、形参列表
-- return 关键字的使用
-
-### 5. 再谈方法
-
-#### 5.1 方法的重载 (overload)
-
-- 方法的重载的要求：“两同一不同”
-- 调用方法时，如何确定调用的是某个指定的方法呢？① 方法名 ② 形参列表
-
-#### 5.2 可变个数形参的方法
-
-- 格式：(int ... args)
-
-#### 5.3 方法的参数传递机制：值传递 (重点、难点)
-
-```
-> 如果形参是基本数据类型的变量，则将实参保存的数据值赋给形参。
-> 如果形参是引用数据类型的变量，则将实参保存的地址值赋给形参。
-```
-
-#### 5.4 递归方法
-
-- 递归方法构成了隐式的循环
-- 对比：相较于循环结构，递归方法效率稍低，内存占用偏高。
-
-### 6. 对象数组
-
-- String[] ；Person[] ; Customer[] 
-
-### 7. package、import 关键字的使用
-
-- package：指明声明的类所属的包。
-- import：当前类中，如果使用其它包下的类（除 java.lang 包），原则上就需要导入。
-
-### 8. oop 的特征之一：封装性
-
-```
-Java规定了4种权限修饰，分别是：private、缺省、protected、public。
-我们可以使用4种权限修饰来修饰类及类的内部成员。当这些成员被调用时，体现可见性的大小。
-```
-
-举例：
-
-```
-> 场景1：私有化(private)类的属性，提供公共(public)的get和set方法，对此属性进行获取或修改
-> 场景2：将类中不需要对外暴露的方法，设置为private
-> 场景3：单例模式中构造器private的了，避免在类的外部创建实例。（放到static关键字后讲）
-```
-
-上理论：程序设计的原则之一
-
-```
-理论上：
-  -`高内聚`：类的内部数据操作细节自己完成，不允许外部干涉；
-    （Java程序通常以类的形态呈现，相关的功能封装到方法中。）
-  -`低耦合`：仅暴露少量的方法给外部使用，尽量方便外部调用。
-    （给相关的类、方法设置权限，把该隐藏的隐藏起来，该暴露的暴露出去）
-```
-
-### 9. 类的成员之三：构造器
-
-- 如何定义：权限修饰符 类名 (形参列表){}
-- 构造器的作用：① 搭配上 new，用来创建对象 ② 初始化对象的成员变量
-
-### 10. 三个小知识
-
-#### 10.1 类的实例变量的赋值过程（重要）
-
-```
-1. 在类的属性中，可以有哪些位置给属性赋值？
-① 默认初始化；
-② 显式初始化；
-③ 构造器中初始化；
-**********************************
-④ 通过"对象.方法"的方式赋值；
-⑤ 通过"对象.属性"的方式赋值；
-
-2. 这些位置执行的先后顺序是怎样？
-① - ② - ③ - ④/⑤
-```
-
-#### 10.2 JavaBean
-
-```
-所谓JavaBean，是指符合如下标准的Java类：
-
-- 类是公共的
-- 有一个无参的公共的构造器
-- 有属性，且有对应的get、set方法
-```
-
-#### 10.3 UML 类图
-
-熟悉。
-
-## 二、企业真题
-
-### 2.1 类与对象
-
-#### 1. 面向对象，面向过程的理解？（平*金服、英**达）
-
-略。
-
-#### 2. Java 的引用类型有哪几种（阿*校招）
-
-类、数组、接口；枚举、注解、记录
-
-#### 3. 类和对象的区别（凡*科技、上\*银行）
-
-略。
-
-#### 4. 面向对象，你解释一下，项目中哪些地方用到面向对象？（燕*金融）
-
-“万事万物皆对象”。
-
-### 2.2 Java 内存结构
-
-#### 1. Java 虚拟机中内存划分为哪些区域，详细介绍一下（神**岳、数\*互融）
-
-略。
-
-#### 2. 对象存在 Java 内存的哪块区域里面？（阿*）
-
-堆空间。
-
-### 2.3 权限修饰符（封装性）
-
-#### 1. private、缺省、protected、public 的表格化作用区域（爱*信、拓\*思、中\*瑞飞）
-
-略
-
-#### 2. main 方法的 public 能不能换成 private？为什么？（凡*科技、顺\*）
-
-能。但是改以后就不能作为程序的入口了，就只是一个普通的方法。
-
-### 2.4 构造器
-
-#### 1. 构造方法和普通方法的区别（凡\*科技、软\*动力、中*软）
-
-编写代码的角度：没有共同点。声明格式、作用都不同。
-
-字节码文件的角度：构造器会以`<init>()方法`的形态呈现，用以初始化对象。
-
-#### 2. 构造器 Constructor 是否可被 overload?（鸿*网络）
-
-可以。
-
-#### 3. 无参构造器和有参构造器的的作用和应用（北京楚*龙）
-
-略
-
-### 2.5 属性及属性赋值顺序
-
-#### 1. 成员变量与局部变量的区别（艾*软件）
-
-6 个点。
-
-#### 2. 变量赋值和构造方法加载的优先级问题（凡*科技、博\*软件）
-
-变量显式赋值先于构造器中的赋值。
-
-如何证明？我看的字节码文件。
-
-
-
Index: src/java/javase review/05.随堂复习与企业真题（数组）.md
===================================================================
diff --git a/src/java/javase review/05.随堂复习与企业真题（数组）.md b/src/java/javase review/05.随堂复习与企业真题（数组）.md
deleted file mode 100644
--- a/src/java/javase review/05.随堂复习与企业真题（数组）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,160 +0,0 @@
----
-order: 5
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（数组）
-
-***
-
-## 一、随堂复习
-
-### 1. 数组的概述
-
-- 数组，就可以理解为多个数据的组合。
-- 是程序中的容器：数组、集合框架（第 12 章，List、Set、Map）
-- 数组存储的数据的特点：依次紧密排列的、有序的、可以重复的
-- 此时的数组、集合框架都是在内存中对多个数据的存储。
-- 数组的其它特点：一旦初始化，其长度就是确定的、不可更改的
-
-### 2. 一维数组的使用（重要）
-
-```
-> 数组的声明和初始化
-	int[] arr = new int[10];
-	String[] arr1 = new String[]{"Tom","Jerry"};
-> 调用数组的指定元素:使用角标、索引、index
-	>index从0开始！
-> 数组的属性：length,表示数组的长度
-> 数组的遍历
-> 数组元素的默认初始化值
-> 一维数组的内存解析（难）
-	前提：在main()中声明变量：int[] arr = new int[]{1,2,3};
-	> 虚拟机栈：main()作为一个栈帧，压入栈空间中。在main()栈帧中，存储着arr变量。arr记录着数组实体的首地址值。
-	> 堆：数组实体存储在堆空间中。
-```
-
-### 3. 二维数组的使用（难点）
-
-- 二维数组：一维数组的元素，又是一个唯一数组，则构成了二维数组。
-
-```
-> 数组的声明和初始化
-> 调用数组的指定元素
-> 数组的属性：length,表示数组的长度
-> 数组的遍历
-> 数组元素的默认初始化值
-> 二维数组的内存解析（难）
-```
-
-### 4. 数组的常用算法（重要）
-
-- 数值型数组的特征值的计算：最大值、最小值、总和、平均值等
-- 数组元素的赋值。比如：杨辉三角；彩票随机生成数（6 位；1-30；不能重复）；回形数
-- 数组的复制、赋值
-- 数组的反转
-- 数组的扩容、缩容
-- 数组的查找
-  - 线性查找
-  - 二分法查找（前提：数组有序）
-- 数组的排序
-  - 冒泡排序：最简单
-  - 快速排序：最常用
-
-### 5. Arrays 工具类的使用
-
-- 熟悉一下内部的常用的方法
-  - toString() / sort() / binarySearch()
-
-### 6. 数组中的常见异常
-
-- ArrayIndexOutOfBoundsException
-- NullPointerException
-
-
-
-## 二、企业真题
-
-### 1. 数组有没有 length() 这个方法？String 有没有 length() 这个方法？（*蓝）
-
-数组没有 length()，是 length 属性。
-
-String 有 length()
-
-### 2. 有数组 int[] arr，用 Java 代码将数组元素顺序颠倒（闪*购）
-
-略
-
-### 3. 为什么数组要从 0 开始编号，而不是 1(中*支付)
-
-数组的索引，表示了数组元素距离首地址的偏离量。因为第 1 个元素的地址与首地址相同，所以偏移量就是 0。所以从 0 开始。
-
-### 4. 数组有什么排序的方式，手写一下（平*保险）
-
-冒泡。
-
-快排。（讲完递归方法以后，大家就可以练习一下）
-
-### 5. 常见排序算法，说下快排过程，时间复杂度？（5*到家）
-
-见课件。
-
-快排：O(nlogn)
-
-### 6. 二分算法实现数组的查找（神舟*天软件）
-
-略
-
-### 7. 怎么求数组的最大子序列和（携*）
-
-```java
-/*
- * 输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。
- * 求所有子数组的和的最大值。要求时间复杂度为 O(n)。
- 例如：输入的数组为 1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为 3, 10, -4, 7, 2，
- 因此输出为该子数组的和 18。
- * @author 尚硅谷 - 宋红康
- */
-public class ArrDemo {
-	public static void main(String[] args) {
-		int[] arr = new int[]{1, -2, 3, 10, -4, 7, 2, -5};
-		int i = getGreatestSum(arr);
-		System.out.println(i);
-	}
-	
-	public static int getGreatestSum(int[] arr){
-		int greatestSum = 0;
-		if(arr == null || arr.length == 0){
-			return 0;
-		}
-		int temp = greatestSum;
-		for(int i = 0;i < arr.length;i++){
-			temp += arr[i];
-			
-			if(temp < 0){
-				temp = 0;
-			}
-			
-			if(temp > greatestSum){
-				greatestSum = temp;
-			}
-		}
-		if(greatestSum == 0){
-			greatestSum = arr[0];
-			for(int i = 1;i < arr.length;i++){
-				if(greatestSum < arr[i]){
-					greatestSum = arr[i];
-				}
-			}
-		}
-		return greatestSum;
-	}
-}
-```
-
-
-
-### 8. Arrays 类的排序方法是什么？如何实现排序的？（阿\*、阿*校招）
-
-略
Index: src/java/javase review/18.随堂复习与企业真题（JDK8-17新特性）.md
===================================================================
diff --git a/src/java/javase review/18.随堂复习与企业真题（JDK8-17新特性）.md b/src/java/javase review/18.随堂复习与企业真题（JDK8-17新特性）.md
deleted file mode 100644
--- a/src/java/javase review/18.随堂复习与企业真题（JDK8-17新特性）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,158 +0,0 @@
----
-order: 18
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（JDK8-17 新特性）
-
-***
-
-## 一、随堂复习
-
-### 1. JDK 新特性的概述
-
-- 几个重要的版本
-  - jdk 5.0 / jdk 8.0：里程碑式的版本
-  - jdk9.0 开始每 6 个月发布一个新的版本
-  - LTS : jdk8 、 jdk 11 、 jdk 17
-
-- 如何学习新特性
-
-```
-> 角度1：新的语法规则 （多关注）
-  自动装箱、自动拆箱、注解、enum、Lambda表达式、方法引用、switch表达式、try-catch变化、record等
-
-> 角度2：增加、过时、删除API
-  StringBuilder、ArrayList、新的日期时间的API、Optional等
-
-> 角度3：底层的优化、JVM参数的调整、GC的变化、内存结构（永久代--->元空间）
-```
-
-### 2. JDK8:lambda 表达式
-
-#### 2.1 什么情况下可以使用 lambda 表达式
-
-- 在给函数式接口提供实例时，都可以考虑使用 lambda 表达式。
-- 基本语法的使用（重要）
-
-#### 2.2 函数式接口
-
-- 常见的函数式接口。Comparator \ Runnable \ java.util.function 下定义的丰富的函数式接口
-
-  ```
-  消费型接口：Consumer<T>     void accept(T t)
-  供给型接口：Supplier<T>     T get()
-  函数型接口：Function<T,R>   R apply(T t)
-  判断型接口：Predicate<T>    boolean test(T t)
-  ```
-
-#### 2.3 方法引用、构造器引用、数组引用
-
-- 方法引用、构造器引用、数组引用：看做是 lambda 表达式的进一步刻画、表达。
-
-- （掌握）方法引用、构造器引用、数组引用的使用场景。
-
-### 3. JDK8:Stream API 的使用
-
-- Stream 关注于内存中的多个数据的运算。
-- 使用步骤：① Stream 的实例化 ② 一系列的中间操作 ③ 终止操作
-
-### 4. JDK8 之后的新特性：语法层面
-
-- jShell 工具
-- try-catch 结构的变化。try(...){ }
-- 局部变量的类型推断：var
-- instanceof 的模式匹配
-- switch 表达式、switch 的模式匹配
-- 文本块的使用："""文本块"""
-- 新的引用数据类型：record (记录)
-- 密封类：sealed class
-
-### 5. JDK8 之后的新特性：其它
-
-- Optional 类的使用
-- 其他：了解
-
-
-
-## 二、企业真题
-
-### 2.1 JDK8 新特性
-
-#### 1. 谈谈 java8 新特性 (京*旗下、时代\*宇，信必\*、招\*信诺，中\*外包，金\*软件、阿\*\*巴)
-
-```
-类似问题
-> JDK1.8相较于JDK1.7有什么不一样？（惠*）
-> JDK1.8的新特性有哪些？Stream API + Lambda表达式，还有吗？（久*国际物流）
-```
-
-- lambda 表达式、Stream API
-- jdk7 的对比：元空间、HashMap、新的日期时间 API、接口变化等。
-
-#### 2. JDK1.8 在数据结构上发生了哪些变化？（银*数据）
-
-- 使用元空间替代永久代。  （方法区：jvm 规范中提到的结构。  
-  - HotSpot 来讲，jdk7：方法区的落地体现：永久代。jdk8：方法区的落地体现：元空间。
-- HashMap 底层结构
-
-#### 3. 你说的了解 Java 的新特性，你说说 JDK8 改进的地方？（银*科技）
-
-略
-
-#### 4. JDK1.8 用的是哪个垃圾回收器？（O**O）
-
-Parallel GC --> jdk9：默认使用 G1GC  --> ZGC（低延迟）
-
-### 2.2 Lambda 表达式
-
-#### 1. Lambda 表达式有了解吗，说说如何使用的（O**O）
-
-```
-类似问题：
-> Lambda的理解（国*）
-```
-
-略
-
-#### 2. 什么是函数式接口？有几种函数式接口（阿**巴）
-
-略。
-
-java.util.function 包下定义了丰富的好函数式接口。有 4 类基础的函数式接口：
-
-消费型接口：Consumer<T>     void accept(T t)
-供给型接口：Supplier<T>     T get()
-函数型接口：Function<T,R>   R apply(T t)
-判断型接口：Predicate<T>    boolean test(T t)
-
-### 2.3 Stream API
-
-#### 1. 创建 Stream 的方式（阿**巴）
-
-三种。
-
-#### 2. 你讲讲 stream 表达式是咋用的，干啥的？（中*国际，上海**网络）
-
-```
-> Stream API 关注的是多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU的。
-  集合关注的数据的存储，面向内存的。
-> Stream API 之于集合，类似于SQL之于数据表的查询。
-```
-
-#### 3. 集合用 Stream 流怎么实现过滤？（润*软件）
-
-filter(Predicate predicate)
-
-#### 4. 用 Stream 怎么选出 List 里想要的数据？（惠*）
-
-略
-
-
-
-### 2.4 其它版本新特性
-
-#### 1. 说说 JDK15、JDK16、JDK17 中的新特性都有什么？(银*数据)
-
-略
Index: src/java/javase review/15.随堂复习与企业真题（File类与IO流）.md
===================================================================
diff --git a/src/java/javase review/15.随堂复习与企业真题（File类与IO流）.md b/src/java/javase review/15.随堂复习与企业真题（File类与IO流）.md
deleted file mode 100644
--- a/src/java/javase review/15.随堂复习与企业真题（File类与IO流）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,116 +0,0 @@
----
-order: 15
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（File 类与 IO 流）
-
-***
-
-## 一、随堂复习
-
-### 1. File 类的使用
-
-- File 类的一个实例对应着磁盘上的一个文件或文件目录。  ----> “万事万物皆对象”
-- （熟悉）File 的实例化、常用的方法
-- File 类中只有新建、删除、获取路径等方法，不包含读写文件的方法。此时需要使用 IO 流
-
-### 2. IO 流的概述
-
-- IO 流的分类
-  - 流向：输入流、输出流
-  - 处理数据单位：字节流、字符流
-  - 流的角色：节点流、处理流
-- IO 的 4 个抽象基类：InputStream \ OutputStream \ Reader \ Writer
-
-### 3. 节点流之：文件流
-
-- FileInputStream \ FileOutputStream \ FileReader \ FileWriter
-- （掌握）读写数据的过程。
-  - 步骤 1：创建 File 类的对象，作为读取或写出数据的端点
-  - 步骤 2：创建相关的流的对象
-  - 步骤 3：读取、写出数据的过程
-  - 步骤 4：关闭流资源
-
-### 4. 处理流之一：缓冲流
-
-- BufferedInputStream \ BufferedOutputStream \ BufferedReader \ BufferedWriter
-- 作用：实现更高效的读写数据的操作
-
-### 5. 处理流之二：转换流
-
-- 层次 1：熟悉转换流的使用
-  - InputStreamReader、OutputStreamWriter
-- 层次 2：（掌握）字符的编码和解码的过程、常用的字符集
-  - 解决相关的问题：读写字符出现乱码！本质问题：使用的解码集与编码集不一致。
-
-### 6. 处理流之三：对象流
-
-- 层次 1：熟悉对象流的使用
-  - ObjectInputStream:反序列化时需要使用的 api
-  - ObjectOutputStream:序列化时需要使用的 api
-- 层次 2：对象的序列化机制
-  - 使用场景：不同的进程之间通信、客户端（或浏览器端）与服务器端传输数据
-  - 自定义类要想实现序列化机制需要满足的要求及注意点。
-
-### 7. 其它流的使用
-
-- 了解：数据流：DataInputStream、DataOutputStream
-- 了解：标准的输入流、标准的输出流：System.in、System.out
-- 了解：打印流：PrintStream、PrintWriter
-
-## 二、企业真题
-
-### 2.1 IO 流概述
-
-#### 1. 谈谈 Java IO 里面的常用类，字节流，字符流 (银*数据)
-
-略
-
-#### 2. Java 中有几种类型的流？JDK 为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？（上海*厦\*联网、极\*科技）
-
-InputStream \ OutputStream \ Reader \ Writer
-
-#### 3. 流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？(银*数据)
-
-需要。close()
-
-处理流在关闭过程中，也会关闭内部的流。
-
-#### 4. OutputStream 里面的 write() 是什么意思？(君*科技)
-
-数据写出的意思。
-
-### 2.2 缓冲流
-
-#### 1. BufferedReader 属于哪种流？他主要是用来做什么的？(国*电网)
-
-略
-
-#### 2. 什么是缓冲区？有什么作用？(北京中油**)
-
-内部提供了一个数组，将读取或要写出的数据，现在此数组中缓存。达到一定程度时，集中性的写出。
-
-作用：减少与磁盘的交互，进而提升读写效率。
-
-### 2.3 转换流
-
-#### 1. 字节流和字符流是什么？怎么转换？(北京蓝\*、\*海*供应链管理）
-
-![image-20221212161251100](images/image-20221212161251100.png)
-
-
-
-### 2.4 序列化
-
-#### 1. 什么是 Java 序列化，如何实现 (君*科技、上海\*厦物联网)
-
-```
-对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，
-或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。
-```
-
-#### 2. Java 有些类中为什么需要实现 Serializable 接口？（阿*校招）
-
-便于此类的对象实现序列化操作。
Index: src/java/javase review/14.随堂复习与企业真题（数据结构与集合源码）.md
===================================================================
diff --git a/src/java/javase review/14.随堂复习与企业真题（数据结构与集合源码）.md b/src/java/javase review/14.随堂复习与企业真题（数据结构与集合源码）.md
deleted file mode 100644
--- a/src/java/javase review/14.随堂复习与企业真题（数据结构与集合源码）.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ /dev/null	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
@@ -1,244 +0,0 @@
----
-order: 14
-categories:
-  - Java
----
-
-# 随堂复习与企业真题（数据结构与集合源码）
-
-***
-
-## 一、随堂复习
-
-### 1. 数据结构
-
-- 数据结构的研究对象：
-  - ① 数据间的逻辑关系（集合关系、一对一、一对多、多对多）
-  - ② 数据的存储结构（或物理结构）
-    - 角度一：顺序结构、链式结构、索引结构、哈希结构
-    - 角度二：线性表（一维数组、链表、栈、队列）、树（二叉树、B+树）、图（多对多）、哈希表（HashMap、HashSet)
-  - ③ 相关运算
-
-- 树（了解）
-- 相关数据结构的核心 Node 的设计（单向链表、双向链表、二叉树、栈、队列）（理解）
-
-### 2. List 接口下的实现类的源码剖析
-
-【面试题】ArrayList、Vector、LinkedList 的三者的对比？
-
-- 层次 1：
-
-```
-|-----子接口：List:存储有序的、可重复的数据 ("动态"数组)
-       |---- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储
-                       在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低
-       |---- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议使用此                         类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；
-       |---- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储
-```
-
-- 层次 2：查看相关 api 的源码
-
-（见笔记，略）
-
-### 3. Map 接口下的实现类的源码剖析
-
-- **（掌握）HashMap 的底层源码的剖析**
-- （熟悉）LinkedHashMap 的底层源码的剖析
-- （了解）HashSet、LinkedHashSet 的底层源码的剖析
-
-
-
-## 二、企业真题
-
-### 2.1 数据结构相关
-
-#### 1. 链表和数组有什么区别？（腾*）
-
-第 14 章课件里：《`【拓展】尚硅谷_宋红康_数据结构概述-Java版.xmind`》
-
-#### 2. 栈是如何运行的？(西*信息技术)
-
-先进后出。属于 ADT(abstract data type)，可以使用数组、链表实现栈结构
-
-
-
-### 2.2 List 集合源码相关
-
-#### 1. ArrayList 的默认大小是多少，以及扩容机制（顺*、凡\*科技）
-
-```
-类似问题：
-> 说说ArrayList的扩容机制吧(国*电网)
-> 讲一下ArrayList的扩容机制（*实在）
-> ArrayList的扩容机制，为什么是10，为什么是1.5倍（*软国际）
-```
-
-略
-
-
-
-#### 2. ArrayList 的底层是怎么实现的？（腾*）
-
-```
-类似问题：
-集合类的ArrayList底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）
-（湖**利软件、汇*云通、猎*、苏州***动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐）
-```
-
-略。
-
-建议：ArrayList(int capacity){}
-
-
-
-#### 3. 在 ArrayList 中 remove 后面几个元素该怎么做？（惠*、中\*亿达）
-
-前移。
-
-#### 4. ArrayList1.7 和 1.8 的区别（拓*思）
-
-类似于饿汉式、懒汉式
-
-#### 5. 数组和 ArrayList 的区别（阿*、\*科软）
-
- ArrayList 看做是对数组的常见操作的封装。
-
-#### 6. 什么是线程安全的 List？(平*金服) 
-
-Vector：线程安全的。
-
-ArrayList：线程不安全。----> 使用同步机制处理。
-
-```
-HashMap:线程不安全。 ----> 使用同步机制处理。
-                   -----> JUC:ConcurrentHashMap
-```
-
-### 2.3 HashMap 集合源码相关
-
-#### 1. 说说 HahMap 底层实现 (新*股份、顺\*、猫\*娱乐)
-
-```
-类似问题：
-> HashMap的实现讲一下？（腾*，上海**网络）
-> 说说HashMap的底层执行原理？（滴*，纬*软件，上海*想，*昂，*蝶**云，宇*科技，*东数科，猎*网）
-> 详细说一下 HashMap 的 put 过程（*度）
-> Java中的HashMap的工作原理是什么？（北京中**译咨询）
-> 集合类的HashMap底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）（湖**利软件）
-> HashMap 的存储过程（爱*信、杭州*智）
-> Hashmap底层实现及构造（汇**通、猎*、苏州博*讯动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐）
-> HashMap的实现原理（腾*、阿*）
-> HaspMap底层讲一讲（*米）
-> 说一下HashMap的实现，扩容机制？（*节）
-> 讲一下 HashMap 中 put 方法过程？（阿*）
-```
-
-略。建议以 JDK8 为主说明。
-
-#### 2. HashMap 初始值 16，临界值 12 是怎么算的（软**力）
-
-16 从底层源码的构造器中看到的。
-
-12：threshold，使用数组的长度*加载因子 (loadFactor)
-
-#### 3. HashMap 长度为什么是 2 的幂次方 (国*时代)
-
-为了方便计算要添加的元素的底层的索引 i。
-
-#### 4. HashMap 怎么计算哈希值和索引？扩容机制？怎么解决 hash 冲突？（*软国际、中软\*腾）
-
-```
-类似问题：
-> HashMap key的哈希冲突了怎么做（新*股份）
-> HashMap的默认大小是多少，以及扩容机制（顺*、凡*科技）
-> 讲一下HashMap的扩容机制？（好实*）
-```
-
-略
-
-#### 5. HashMap 底层是数组 + 链表，有数组很快了，为什么加链表？（润*软件）
-
-因为产生了哈希冲突。解决方案，使用链表的方式。保证要添加的元素仍然在索引 i 的位置上。
-
-#### 6. HashMap 为什么长度达到一定的长度要转化为红黑树（*度）
-
-```
-类似问题：
-> HashMap为什么用红黑树（*软国际）
-```
-
-红黑树的常用操作的时间复杂度 O(logn)，比单向链表的 O(n) 效率高。
-
-#### 7. HashMap 什么时候扩充为红黑树，什么时候又返回到链表？（汉*）
-
-```
-类似问题：
-> HashMap什么时候转换为红黑树（杭州*智公司）
-> 当HashMap中相同hashcode值的数据超过多少时会转变成红黑树？（百*云创）
-> 什么时候是数据+链表，什么时候是红黑树（*软国际）
-```
-
-索引 i 的位置的链表长度超过 8 且数组长度达到 64，需要索引 i 位置要变成红黑树。
-
-当索引 i 的位置元素的个数低于 6 时，要红黑树结构转为单向链表。为什么？节省空间。
-
-#### 8. 在 JDK1.8 中，HashMap 的数据结构与 1.7 相比有什么变化，这些变化的好处在哪里？（海*科）
-
-```
-① 在jdk8中，当我们创建了HashMap实例以后，底层并没有初始化table数组。当首次添加(key,value)时，进行判断，
-如果发现table尚未初始化，则对数组进行初始化。
-② 在jdk8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类。意味着，我们创建的数组是Node[]
-③ 在jdk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中。如果此时角标i位置上有
-   元素。在jdk7中是将新的(key,value)指向已有的旧的元素（头插法），而在jdk8中是旧的元素指向新的
-   (key,value)元素（尾插法）。 "七上八下"
-④ jdk7:数组+单向链表
-   jk8:数组+单向链表 + 红黑树
-   什么时候会使用单向链表变为红黑树：如果数组索引i位置上的元素的个数达到8，并且数组的长度达到64时，我们就将此索引i位置上
-                               的多个元素改为使用红黑树的结构进行存储。（为什么修改呢？红黑树进行put()/get()/remove()
-                               操作的时间复杂度为O(logn)，比单向链表的时间复杂度O(n)的好。性能更高。
-   什么时候会使用红黑树变为单向链表：当使用红黑树的索引i位置上的元素的个数低于6的时候，就会将红黑树结构退化为单向链表。
-```
-
-#### 9. HashMap 的 get() 方法的原理？（顺*）
-
-参考 put()
-
-
-
-###  2.4 hashCode 和 equals
-
-#### 1. hashcode 和 equals 区别？（海*供应链管理）
-
-略
-
-#### 2. hashCode() 与 equals() 生成算法、方法怎么重写？（阿*校招）
-
-进行 equals() 判断使用的属性，通常也都会参与到 hashCode() 的计算中。
-
-尽量保证 hashCode() 的一致性。（使用 IDEA 自动生成，hashCode() 自动使用相关的算法。
-
-#### 3. 说一下 equals 和==的区别，然后问 equals 相等 hash 值一定相等吗？hash 值相等 equals 一定相等吗？（南*电网、上海\*智网络）
-
-equals 相等 hash 值一定相等吗？是
-
-hash 值相等 equals 一定相等吗？不一定
-
-### 2.5 Set 集合源码相关
-
-#### 1. HashSet 存放数据的方式？（拓*软件）
-
-底层使用 HashMap。说一下 HashMap
-
-#### 2. Set 是如何实现元素的唯一性？（湖**利软件）
-
-略
-
-#### 3. 用哪两种方式来实现集合的排序（凡*科技）
-
-```
-类似问题：
-> 集合怎么排序？（北京中**信科技）
-```
-
-自然排序、定制排序。
-
Index: src/java/JUC/13.ReentrantLock、ReentrantReadWriteLock、StampedLock 讲解.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: ReentrantLock、ReentrantReadWriteLock、StampedLock 讲解\r\ndate: 2023-04-17 20:22:13\r\npermalink: /pages/8ef94b/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n# ReentrantLock、ReentrantReadWriteLock、StampedLock 讲解\r\n\r\n### 读写锁\r\n\r\n#### ReentrantReadWriteLock\r\n\r\n悲观锁\r\n\r\n读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。\r\n\r\n- 读读可以共享，多线程并发可以访问，大面积的可以容许多个线程来读取读多写少的时候，读写锁优先。\r\n- 读写、写写互斥\r\n\r\nreadLock()\r\n\r\nwriteLock()\r\n\r\n缺点：\r\n\r\n- 写饥饿\r\n\r\n- 锁降级\r\n\r\n   写锁降级为读锁\r\n\r\n  - 如果同一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁。这就是写锁的降级，降级成为了读锁。\r\n  - 规则惯例，先获取写锁，然后获取读锁，再释放写锁的次序。\r\n  - 如果释放了写锁，那么就完全转换为读锁。\r\n\r\n![img](./assets/images_20221024093400.png)\r\n\r\n```\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\r\n        ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();\r\n        ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();\r\n\r\n        writeLock.lock();\r\n        System.out.println(\"----wirte\");\r\n        \r\n        readLock.lock();\r\n        System.out.println(\"----read\");\r\n\r\n        writeLock.unlock();\r\n        readLock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n**锁降级设计思想**\r\n\r\n```\r\n//锁降级设计思想，保证数据可见性。写锁降级为读锁，本质相当于重入，这种机制专门为缓存设计的。\r\nObject data;\r\nvolatile boolean cacheValid;\r\nfinal ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\r\nvoid processCachedData() {\r\n    rwl.readLock().lock();\r\n    if (!cacheValid) {\r\n        // Must release read lock before acquiring write lock\r\n        rwl.readLock().unlock();\r\n        rwl.writeLock().lock();\r\n        try {\r\n        \t// Recheck state because another thread might have\r\n        \t// acquired write lock and changed state before we did.\r\n        \tif (!cacheValid) {\r\n        \t\tdata = ...\r\n        \t\tcacheValid = true;\r\n        \t}\r\n        \t// Downgrade by acquiring read lock before releasing write lock\r\n        \trwl.readLock().lock();\r\n        } finally {\r\n        \trwl.writeLock().unlock(); // Unlock write, still hold read\r\n        }\r\n    }\r\n    try {\r\n    \tuse(data);\r\n    } finally {\r\n        rwl.readLock().unlock();\r\n    }\r\n}\r\n```\r\n\r\n#### StampedLock\r\n\r\n是一种乐观锁\r\n\r\n**解决锁饥饿问题**\r\n\r\n- 公平锁，牺牲吞吐量\r\n- 乐观读锁（读的过程允许写的介入）\r\n\r\n**缺点**\r\n\r\n- 不支持重入\r\n- 不支持条件变量Condition\r\n- 不要调用中断\r\n\r\n```\r\npublic class JucTest {\r\n    static int nuumber = 17;\r\n    static StampedLock stampedLock = new StampedLock();\r\n    public void write() {\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"wirte thread prepare to wirte\");\r\n        long stamp = stampedLock.writeLock();\r\n        try {\r\n            nuumber = nuumber + 13;\r\n        } finally {\r\n            stampedLock.unlockWrite(stamp);\r\n        }\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"wirte thread end to wirte\");\r\n    }\r\n    //悲观读\r\n    public void read() {\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"wirte thread prepare to read\");\r\n        long stamp = stampedLock.readLock();\r\n        for (int i = 0; i < 4; i++) {\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n                System.out.println(\"reading...\");\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        try {\r\n            int result = nuumber;\r\n            System.out.println(\"read: \" + result);\r\n        } finally {\r\n            stampedLock.unlockRead(stamp);\r\n        }\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"wirte thread end to read\");\r\n    }\r\n    //乐观读\r\n    public void tryOptimisticRead() {\r\n        long stamp = stampedLock.tryOptimisticRead();\r\n        int result = nuumber;\r\n        System.out.println(\"判断是否有修改\" + \"\\t\" + stampedLock.validate(stamp));\r\n        for (int i = 0; i < 4; i++) {\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n                System.out.println(\"reading stampedLockValidate: \" + stampedLock.validate(stamp));\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        if (!stampedLock.validate(stamp)) {\r\n            System.out.println(\"value modified by someone\");\r\n            stamp = stampedLock.readLock();\r\n            try {\r\n                System.out.println(\"乐观读升级为悲观读\");\r\n                result = nuumber;\r\n                System.out.println(\"悲观读后: \" + result);\r\n            } finally {\r\n                stampedLock.unlockRead(stamp);\r\n            }\r\n        }\r\n        System.out.println(\"finally value: \" + result);\r\n    }\r\n    public static void main(String[] args) {\r\n        JucTest jucTest = new JucTest();\r\n        new Thread(() -> {\r\n            jucTest.tryOptimisticRead();\r\n        }, \"readThread\").start();\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        new Thread(() -> {\r\n            jucTest.write();\r\n        }, \"writeThread\").start();\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + nuumber);\r\n    }\r\n}\r\n```\r\n\r\n### \r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/13.ReentrantLock、ReentrantReadWriteLock、StampedLock 讲解.md b/src/java/JUC/13.ReentrantLock、ReentrantReadWriteLock、StampedLock 讲解.md
--- a/src/java/JUC/13.ReentrantLock、ReentrantReadWriteLock、StampedLock 讲解.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/13.ReentrantLock、ReentrantReadWriteLock、StampedLock 讲解.md	(date 1682513033069)
@@ -1,12 +1,5 @@
 ---
-title: ReentrantLock、ReentrantReadWriteLock、StampedLock 讲解
-date: 2023-04-17 20:22:13
-permalink: /pages/8ef94b/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 # ReentrantLock、ReentrantReadWriteLock、StampedLock 讲解
 
Index: src/java/JUC/12.AbstractQueuedSynchronizer 之 AQS.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: AbstractQueuedSynchronizer 之 AQS\r\ndate: 2023-04-17 20:22:01\r\npermalink: /pages/89cbfe/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n# AbstractQueuedSynchronizer 之 AQS\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n###  AQS\r\n\r\nAbstractQueuedSynchronizer简称为AQS，抽象的对列同步器。\r\n\r\n是用来实现锁或者其它同步器组件的公共基础部分的抽象实现，是**重量级基础框架及整个JUC体系的基石**，主要用于解决锁分配给\"谁\"的问题。\r\n\r\n整体就是一个抽象的FIFO队列（双向循环列表）来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态。\r\n\r\n![img](./assets/images_20221023162015.png)\r\n\r\nAbstractQueuedSynchronizer类内部类Node，属性state为同步状态。\r\n\r\n### \r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/12.AbstractQueuedSynchronizer 之 AQS.md b/src/java/JUC/12.AbstractQueuedSynchronizer 之 AQS.md
--- a/src/java/JUC/12.AbstractQueuedSynchronizer 之 AQS.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/12.AbstractQueuedSynchronizer 之 AQS.md	(date 1682513031398)
@@ -1,12 +1,5 @@
 ---
-title: AbstractQueuedSynchronizer 之 AQS
-date: 2023-04-17 20:22:01
-permalink: /pages/89cbfe/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 # AbstractQueuedSynchronizer 之 AQS
 
Index: src/java/JUC/09.Java 对象内存布局和对象头.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Java 对象内存布局和对象头\r\ndate: 2023-04-17 20:21:27\r\npermalink: /pages/4e3bb0/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n\r\n### 对象内存布局\r\n\r\n在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头(Header) 、实例数据(Instance Data)和对齐填充(Padding)。\r\n\r\n#### 对象头\r\n\r\n![img](./assets/images_20221020200008-1681833073755-353.png)\r\n\r\n**组成：**\r\n\r\n- 对象标记Mark Word\r\n\r\n  默认存储对象的HashCode、 分代年龄和锁标志位等信息。 这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化时变化。\r\n\r\n- 类元信息（类型指针）\r\n\r\n  对象指向它的类元数据的指针（方法区），虚拟机通过这个指针来确定这个对象是哪个类的实例。\r\n\r\n  默认启用压缩指针。\r\n\r\n#### 对象中的实际数据\r\n\r\n存放类的属性(Field)数据信息，包括父类的属性信息\r\n\r\n#### 对齐填充\r\n\r\n虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐。\r\n\r\n#### JOL工具\r\n\r\n分析对象在JVM虚拟机的大小和布局\r\n\r\n```java\r\n<!-- JOL工具 -->\r\n<dependency>\r\n\t<groupId>org.openjdk.jol</groupId>\r\n\t<artifactId>jol-core</artifactId>\r\n\t<version>0.9</version>\r\n</dependency>\r\nclass Customer {\r\n    int id;\r\n    boolean flag = false;\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Object o = new Object();//16 bytes\r\n        //System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n        //1. Customer 只有对象头没有任何Field 16 bytes\r\n        //2. int+boolean 默认满足对齐填充24\r\n        Customer c1 = new Customer();\r\n        System.out.println(ClassLayout.parseInstance(c1).toPrintable());\r\n    }\r\n}\r\n```\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/09.Java 对象内存布局和对象头.md b/src/java/JUC/09.Java 对象内存布局和对象头.md
--- a/src/java/JUC/09.Java 对象内存布局和对象头.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/09.Java 对象内存布局和对象头.md	(date 1682513024725)
@@ -1,12 +1,5 @@
 ---
-title: Java 对象内存布局和对象头
-date: 2023-04-17 20:21:27
-permalink: /pages/4e3bb0/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 
 ### 对象内存布局
Index: src/java/JUC/08.原子操作类.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 原子操作类\r\ndate: 2023-04-17 20:21:15\r\npermalink: /pages/0eaccd/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n\r\n###  原子类\r\n\r\n#### AtomicInteger\r\n\r\nCountDownLatch用法\r\n\r\n countDown()\r\n\r\n await()\r\n\r\n#### AtomicIntegerArray\r\n\r\n#### 引用类型原子类\r\n\r\nAtomicStampedReference，version号，+1；\r\n\r\nAtomicMarkableReference，一次，解决一次性问题（动没动过）\r\n\r\n#### 对象的属性修改原子类\r\n\r\n使用目的：以一种线程安全的方式操作非线程安全对象内的某些字段\r\n\r\n使用要求：更新的对象属性必须使用public volatile修饰符。因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。\r\n\r\nAtomicIntegerFieldUpdater\r\n\r\n```\r\nclass BankAccount {\r\n    String bankName = \"CCB\";\r\n    public volatile int money = 0;\r\n//    public void add() {\r\n//        money++;\r\n//    }\r\n    AtomicIntegerFieldUpdater<BankAccount> fieldUpdater =\r\n            AtomicIntegerFieldUpdater.newUpdater(BankAccount.class, \"money\");\r\n    public void transMoney() {\r\n        fieldUpdater.getAndIncrement(this);\r\n    }\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        BankAccount bankAccount = new BankAccount();\r\n        CountDownLatch countDownLatch = new CountDownLatch(10);\r\n        for (int i = 0; i < 10; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    for (int j = 0; j < 1000; j++) {\r\n                        bankAccount.transMoney();\r\n                    }\r\n                }finally {\r\n                    countDownLatch.countDown();\r\n                }\r\n            }).start();\r\n        }\r\n        try {\r\n            countDownLatch.await();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(bankAccount.money);\r\n    }\r\n}\r\n```\r\n\r\nAtomicReferenceFieldUpdater\r\n\r\n```\r\nclass MyCar {\r\n    public volatile Boolean isInit = Boolean.FALSE;\r\n    AtomicReferenceFieldUpdater<MyCar, Boolean> referenceFieldUpdater =\r\n            AtomicReferenceFieldUpdater.newUpdater(MyCar.class, Boolean.class, \"isInit\");\r\n    public void init() {\r\n        if (referenceFieldUpdater.compareAndSet(this, Boolean.FALSE, Boolean.TRUE)) {\r\n            System.out.println(\"success init\");\r\n        } else {\r\n            System.out.println(\"had been inited by other thread\");\r\n        }\r\n    }\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        MyCar myCar = new MyCar();\r\n        for (int i = 0; i < 5; i++) {\r\n            new Thread(() -> {\r\n                myCar.init();\r\n            }).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 原子操作增强类\r\n\r\nLongAdder() 只能计算加法，且从0开始，比AtomicLong（底层为CAS，空轮询造成性能降低，但能保证精度）性能好。\r\n\r\nLongAccumulator() 功能更强大\r\n\r\nLongAdder底层原理：\r\n\r\nStripend64类\r\n\r\ntransient volatile cell[] cells;\r\n\r\ntransient volatile long base;\r\n\r\n**为什么快：**\r\n\r\nLongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。 sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong个value的更新压力分散到多个value中去，从而降级更新热点。（sum不能保证精度，只能保证最终一致性）\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/08.原子操作类.md b/src/java/JUC/08.原子操作类.md
--- a/src/java/JUC/08.原子操作类.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/08.原子操作类.md	(date 1682513023385)
@@ -1,12 +1,5 @@
 ---
-title: 原子操作类
-date: 2023-04-17 20:21:15
-permalink: /pages/0eaccd/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 
 ###  原子类
Index: src/java/JUC/11.Synchronized 与锁升级.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Synchronized 与锁升级\r\ndate: 2023-04-17 20:21:52\r\npermalink: /pages/a18760/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n\r\n##  Synchronized与锁升级\r\n\r\n锁的升级过程\r\n\r\n无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁\r\n\r\n![img](./assets/images_20221020200008.png)\r\n\r\n#### 锁指向\r\n\r\n偏向锁：MarkWord存储的是偏向的线程ID。 轻量锁：MarkWord存储的是指向线程栈中LockRecord的指针。 重量锁：MarkWord存储的是指向堆中的monitor对象的指针。\r\n\r\n#### Monitor\r\n\r\nMonitor可以理解为一种同步工具，也可理解为一种同步机制， 常常被描述为一个Java对 象。Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。\r\n\r\n#### Mutex Lock\r\n\r\nMonitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所synchronized是Java语言中的一个重量级操作。\r\n\r\nMonitor与java对象以及线程是如何关联? 1.如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址 2.Monitor的Owner字段会存放拥有相关联对象锁的线程id\r\n\r\nsynchronized用的锁是存在Java对象头里的Mark Word中锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位\r\n\r\n#### 偏向锁\r\n\r\n**单线程竞争**\r\n\r\n当线程A第一次竞争到锁时，通过操作修改Mark Word中的偏向线程ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程将永远不需要进行同步\r\n\r\nHotspot的作者经过研究发现，大多数情况下: 多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一个线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。\r\n\r\n偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也即偏向锁在资源没有竞争情况下消除了同步语句，懒的连CAS操作都不做了，直接提高程序性能。\r\n\r\n**偏向锁的持有**\r\n\r\n一个synchronized方法被一个线程抢到 了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word中去判断一下是否有偏向锁指向本身的ID，无需再进入Monitor去竞争对象了。\r\n\r\n偏向锁，不主动释放锁，偏向指向的ID，如果是当前指向线程ID，当前线程就会直接进入临界区，无需加锁操作，无需沟通内核。\r\n\r\n**偏向锁撤销**\r\n\r\n竞争激烈，其他线程CAS操作替换线程ID，原持有偏向锁的线程未执行完毕，则升级轻量级锁\r\n\r\nJava15后废弃\r\n\r\n#### 轻量级锁\r\n\r\n假如线程A已经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁已经被线程A拿到，当前该锁已是偏向锁了。而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，那线程B就会进行CAS操作希望能获得锁。 **此时线程B操作中有两种情况:**\r\n\r\n如果锁获取成功，直接替换Mark Word中的线程ID为B自己的ID(A→B)，重新偏向于其他线程(即将偏向锁交给其他线程，相当于当前线程\"被\"释放了锁)，该锁会保持偏向锁状态，A线程Over，B线程上位;\r\n\r\n如果锁获取失败，则偏向锁升级为轻量级锁(设置偏向锁标识为0并设置锁标志位为00)，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。\r\n\r\n**轻量级锁的加锁**\r\n\r\nJVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，官方成为Displaced Mark Word。若一个线程获得锁时发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。\r\n\r\n**轻量级锁的释放**\r\n\r\n在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。\r\n\r\n#### 重量级锁\r\n\r\n自旋达到一定次数（自适应调节次数）时，升级锁。\r\n\r\n**自适应：**线程如果自旋成功了，那下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么这一次也很大概率会成功。\r\n\r\nJava中synchronized的重量级锁，是基于进入和退出Monitor对象实现的。在编译时会将同步块的开始位置插入monitor enter指令，在结束位置插入monitor exit指令。 当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即获取到了锁，会在Monitor的owner中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor。\r\n\r\n升级为轻量级锁时，JVM会在当前线程的栈帧中创建个锁记录(**Lock Record**)空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含identity hash code，所以轻量级锁可以和identity hash code共存，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。\r\n\r\n一个对象计算过hash code时无法进入偏向锁，直接进入轻量级锁\r\n\r\n#### JIT\r\n\r\nJIT即时编译器会优化无效的锁（**锁消除**）\r\n\r\nJIT会融合一些锁（**锁粗化**）\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/11.Synchronized 与锁升级.md b/src/java/JUC/11.Synchronized 与锁升级.md
--- a/src/java/JUC/11.Synchronized 与锁升级.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/11.Synchronized 与锁升级.md	(date 1682513027503)
@@ -1,12 +1,5 @@
 ---
-title: Synchronized 与锁升级
-date: 2023-04-17 20:21:52
-permalink: /pages/a18760/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 
 ##  Synchronized与锁升级
Index: src/java/JUC/10.ThreadLocal.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: ThreadLocal\r\ndate: 2023-04-17 20:21:40\r\npermalink: /pages/b77f88/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n\r\n#  ThreadLocal\r\n\r\n实现每一个线程都有自己专属的本地变量副本(自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份)，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题，比如我们之前讲解的8锁案例，资源类是使用同一部手机，多个线程抢夺同一部手机使用，假如人手一份是不是天下太平?\r\n\r\n必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally 块进行回收。\r\n\r\n```\r\nclass House {\r\n    int saleCount = 0;\r\n    public synchronized void saleHouse() {\r\n        ++saleCount;\r\n    }\r\n//    ThreadLocal<Integer> saleVolume = new ThreadLocal<Integer>() {\r\n//        @Override\r\n//        protected Integer initialValue() {\r\n//            return 0;\r\n//        }\r\n//    };\r\n    ThreadLocal<Integer> saleVolume = ThreadLocal.withInitial(() -> 0);\r\n    public void saleVolumeByThreadLocal() {\r\n        saleVolume.set(1 + saleVolume.get());\r\n    }\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        House house = new House();\r\n        for (int i = 0; i < 5; i++) {\r\n            new Thread(() -> {\r\n                int size = new Random().nextInt(5) + 1;\r\n                try {\r\n                    for (int j = 1; j<= size; j++) {\r\n                        house.saleHouse();\r\n                        house.saleVolumeByThreadLocal();\r\n                    }\r\n                    System.out.println(Thread.currentThread().getName() + \"\\t\" + \"号销售卖出:\" + house.saleVolume.get());\r\n                } finally {\r\n                    //必须回收\r\n                    house.saleVolume.remove();\r\n                }\r\n            }, String.valueOf(i)).start();\r\n        }\r\n        //暂停亳秒\r\n        try {\r\n            TimeUnit.MILLISECONDS. sleep(300);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(Thread.currentThread( ).getName() + \"\\t\" + \"共计卖出多少套: \" + house.saleCount);\r\n    }\r\n}\r\n```\r\n\r\nThread调用了ThreadLocal.ThreadLocalMap；ThreadLocal包含了静态内部类ThreadLocalMap\r\n\r\nthreadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。\r\n\r\nJVM内部维护了一个线程版的Map<ThreadLocal，Value>(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中)，每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。\r\n\r\n#### 强引用\r\n\r\nOOM都不会被回收\r\n\r\n#### 软引用\r\n\r\n当内存不够了，软引用才会被自动回收\r\n\r\n```\r\nclass MyObject {\r\n    public MyObject(){}\r\n    @Override\r\n    protected void finalize() throws Throwable {\r\n        super.finalize();\r\n        System.out.println(\"-----该对象被gc了\");\r\n    }\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        //当内存不够了，软引用才会被自动回收\r\n        //-Xms10m -Xmx10m 最大内存为10m\r\n        SoftReference<MyObject> softReference = new SoftReference<>(new MyObject());\r\n        System.gc();\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"内存够用: \" + softReference.get());\r\n        try {\r\n            byte[] bytes = new byte[1024 * 1024 * 20];\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            System.out.println(\"------gc after内存不够用: \" + softReference.get());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 弱引用\r\n\r\n弱引用会被gc回收，不管内存空间是否充足\r\n\r\n```\r\nclass MyObject {\r\n    public MyObject(){}\r\n    @Override\r\n    protected void finalize() throws Throwable {\r\n        super.finalize();\r\n        System.out.println(\"-----该对象被gc了\");\r\n    }\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        //弱引用会被回收，不管内存空间是否充足\r\n        //-Xms10m -Xmx10m 最大内存为10m\r\n        WeakReference<MyObject> weakReference = new WeakReference<>(new MyObject());\r\n        System.out.println(\"内存够用: \" + weakReference.get());\r\n        System.gc();\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 虚引用\r\n\r\n- 虚引用必须和引用队列(ReferenceQueue)联合使用 虚引用需要java.lang.ref.PhantomReference类来实现，顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队(ReferenceQueue)联合使用。\r\n- PhantomReference的get方法总是返回null 虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事情的通知机制。PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。\r\n- 处理监控通知使用 换句话说，设置虚引用关联对象的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理，用来实现比finalize机制更灵活的回收操作\r\n\r\n#### 为什么用弱引用\r\n\r\n强引用（new的），弱引用（ThreadLocalMap key指向）都指向ThreadLocal对象，强引用销毁了，弱引用就会被gc回收。\r\n\r\n#### 清除脏的Entry\r\n\r\n<null, value>\r\n\r\nset()，get()，remove()方法被调用时，key为null的会被清除。\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/10.ThreadLocal.md b/src/java/JUC/10.ThreadLocal.md
--- a/src/java/JUC/10.ThreadLocal.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/10.ThreadLocal.md	(date 1682513026117)
@@ -1,12 +1,5 @@
 ---
-title: ThreadLocal
-date: 2023-04-17 20:21:40
-permalink: /pages/b77f88/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 
 #  ThreadLocal
Index: src/java/javaweb/03.Servlet.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Servlet\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/2f2b28/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# Servlet\r\n\r\n## Servlet 概念\r\n\r\n- Servlet 是一组接口，定义动态资源 (java class 文件) 能够`被浏览器访问`且能够`被tomcat识别`的功能\r\n- `url:localhost:8080/项目名称/资源名称`\r\n\r\n![image-20230417151601697](./assets/image-20230417151601697.png)\r\n\r\n## Servlet 原理\r\n\r\n1. 访问资源\r\n2. 通过 url-pattern 找到全类名\r\n3. 通过反射技术创建对象执行方法\r\n\r\n![image-20230417151604958](./assets/image-20230417151604958.png)\r\n\r\n## Servlet 生命周期\r\n\r\n- 初始化方法，只会执行一次\r\n\r\n```\r\n第一次执行时被创建 <load-on-startup>-1</load-on-startup>\r\n服务器启动时被创建 <load-on-startup>1</load-on-startup>\r\n```\r\n\r\n- 服务方法，执行多次\r\n- 销毁方法，只会执行一次\r\n\r\n```java\r\npublic void init(ServletConfig servletConfig) throws ServletException {\r\n    System.out.println(\"Servlet 被初始化\");\r\n}\r\n\r\n@Override\r\npublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\r\n    System.out.println(\"hello world\");\r\n\r\n}\r\n\r\n@Override\r\npublic void destroy() {\r\n    System.out.println(\"Servlet 被销毁\");\r\n}\r\n```\r\n\r\n## Servletxml 配置\r\n\r\n```xml\r\n<!--配置servlet被tomcat识别-->\r\n<servlet>\r\n    <servlet-name>demo</servlet-name>\r\n    <servlet-class>servlet.MyServlet</servlet-class>\r\n</servlet>\r\n<!--配置servlet被浏览器访问-->\r\n<servlet-mapping>\r\n    <servlet-name>demo</servlet-name>\r\n    <url-pattern>/demo</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n## Servlet 注解配置\r\n\r\n```\r\n@WebServlet(urlPatterns = \"/anno\")\r\n@WebServlet(\"/anno\") `value=urlPatterns value可以省略`\r\n```\r\n\r\n- 静态资源放在 WEB-INF 是不能被访问到的\r\n\r\n## Servlet 体系\r\n\r\n![image-20220328094908008](./assets/image-20230417151609657.png) \r\n\r\n- GenericServlet(只需要实现 serivce 方法)\r\n- HttpServlet (对请求协议的判断进行了封装)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/03.Servlet.md b/src/java/javaweb/03.Servlet.md
--- a/src/java/javaweb/03.Servlet.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/03.Servlet.md	(date 1682512975127)
@@ -1,12 +1,5 @@
 ---
-title: Servlet
-date: 2023-03-07 14:59:21
-permalink: /pages/2f2b28/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # Servlet
 
Index: src/java/javaweb/02.xml 标记语言.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: xml 标记语言\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/692564/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# xml 标记语言\r\n\r\n## 入门\r\n\r\n- xml 可拓展标记语言\r\n- 作用：存储数据，作为配置文件，html 是用来展示数据\r\n- 区分大小写\r\n\r\n## 组成部分\r\n\r\n1. 文档声明 `<?xml version=\"1.0\" encoding=\"UTF-8\"?>`\r\n2. 指令：了解 引入 css 样式\r\n3. 标签：自定义标签\r\n4. 属性：id 属性唯一\r\n5. 文本：CDATA 区原样展示数据 `<![CDATA[展示的数据]]>`\r\n\r\n## 约束\r\n\r\n![image-20230417151533346](./assets/image-20230417151533346.png)\r\n\r\n## 约束分类\r\n\r\n### dtd\r\n\r\n```\r\n内部dtd\r\n外部本地dtd\r\n外部网络did\r\n```\r\n\r\n### schema\r\n\r\n- 填写 xml 文档的根元素\r\n- `<beans></beans>`\r\n\r\n- 引入 xsi 前缀\r\n- `xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"`\r\n\r\n- 引入 xsd 文件命名空间\r\n- `xsi:schemaLocation=\"`\r\n  `http://www.springframework.org/schema/beans`\r\n  `http://www.springframework.org/schema/beans/spring-beans.xsd`\r\n  `http://www.springframework.org/schema/context` \r\n  `http://www.springframework.org/schema/context/spring-context.xsd`\r\n\r\n- 为每一个 xsd 约束声明一个前缀作为标识\r\n- `xmlns:context=\"http://www.springframework.org/schema/context\"`\r\n\r\n## 解析\r\n\r\n1. DOM\r\n2. SAX\r\n\r\n## Jsoup\r\n\r\n> 解析 xml 文件的工具类\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/02.xml 标记语言.md b/src/java/javaweb/02.xml 标记语言.md
--- a/src/java/javaweb/02.xml 标记语言.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/02.xml 标记语言.md	(date 1682512972920)
@@ -1,12 +1,5 @@
 ---
-title: xml 标记语言
-date: 2023-03-07 14:59:21
-permalink: /pages/692564/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # xml 标记语言
 
Index: src/java/javaweb/05.Cookie.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Cookie\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/f20476/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# Cookie\r\n\r\n## Cookie 概念\r\n\r\n> 会话技术：服务器和浏览器建立连接，共享数据，直到一方断开为止，称为一次会话\r\n\r\n- 客户端 (浏览器) 会话技术：Cookie\r\n- 服务端 (服务器) 会话技术：Session\r\n\r\n| 创建 Cookie 对象 | new Cookie(String name, String value) |\r\n| -------------- | ------------------------------------- |\r\n| 发送 Cookie 对象 | response.addCookie(Cookie cookie)     |\r\n| 获取 Cookie 对象 | Cookie[]  request.getCookies()        |\r\n\r\n## Cookie 原理\r\n\r\n>发送 Cookie 对象 是将信息设置到响应头里面\r\n>\r\n>获取 Cookie 对象 是把消息从响应头中取出来\r\n\r\n![image-20230417151703786](./assets/image-20230417151703786.png)\r\n\r\n## Cookie 细节\r\n\r\n- 可以一次发送多个 cookie 对象，多次调用 response.addCookie(Cookie cookie) 方法\r\n\r\n- 默认情况下浏览器关闭 cookie 信息就销毁\r\n\r\n- 可以设置 cookie 持久化存储\r\n\r\n  | setMaxAge(int seconds) |                                 |\r\n  | ---------------------- | ------------------------------- |\r\n  | 正数                   | 将 cookie 信息写入硬盘，持久化存储 |\r\n  | 负数                   | 存在内存中，默认浏览器关闭就销毁 |\r\n  | 零                     | 删除 cookie 信息                  |\r\n\r\n- Tomcat8 之后 cookie 可以使用中文\r\n\r\n- cookie 共享问题:cooike 默认当前项目使用\r\n\r\n  | cookie.setPath(\"/\")    | 在服务器下共享 cookie                            |\r\n  | ---------------------- | ----------------------------------------------- |\r\n  | setDomain(String path) | 如果一级域名相同，则多个服务器之间 cookie 可以共享 |\r\n\r\n## Cookie 特点\r\n\r\n1. cookie 数据存储在客户端浏览器中，不安全\r\n2. cookie 对单个 cookie 的大小限制 4kb，对同一个域名下的 cookie 持久化最多设置 20 个左右\r\n3. cookie 的作用是存储少量不重要的数据到浏览器\r\n4. URLEncoder 编码\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/05.Cookie.md b/src/java/javaweb/05.Cookie.md
--- a/src/java/javaweb/05.Cookie.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/05.Cookie.md	(date 1682512979364)
@@ -1,12 +1,5 @@
 ---
-title: Cookie
-date: 2023-03-07 14:59:21
-permalink: /pages/f20476/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # Cookie
 
Index: src/java/javaweb/04.HTTP.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: HTTP\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/8976c3/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# HTTP\r\n\r\n## HTTP 概念\r\n\r\n> 定义客户端和服务端通信时发送数据的格式\r\n\r\n- 基于TCP/IP的高级协议\r\n- 默认端口 80\r\n- 基于请求/响应模型\r\n- 无状态\r\n\r\n## 请求方式\r\n\r\n* GET\r\n   \t1. 请求参数在请求行中，在 url 后\r\n         \t\t2. 请求的 url 长度有限制的\r\n               \t3. 不太安全\r\n* POST\r\n  1. 请求参数在请求体中\r\n  2. 请求的 url 长度没有限制的\r\n  3. 相对安全\r\n\r\n## Request 请求格式\r\n\r\n- 请求行\r\n  - `请求方式 请求url 请求协议/版本` \r\n  - `GET /login.html\tHTTP/1.1`\r\n- 请求头：客户端浏览器告诉服务器一些信息\r\n  - 请求头名称：请求头值\r\n- 请求空行\r\n  - 空行，就是用于分割 POST 请求的请求头，和请求体的\r\n- 请求体 (正文)\r\n  \t* 封装 POST 请求消息的请求参数的\r\n\r\n```\r\n//请求头\r\nPOST /login.html\tHTTP/1.1\r\n//服务器主机\r\nHost: localhost\r\n//浏览器兼容\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0\r\n//支持\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\r\nAccept-Encoding: gzip, deflate\r\n//告诉服务器当前请求从哪里来,1.防盗链 2.统计数据\r\nReferer: http://localhost/login.html\r\n//连接\r\nConnection: keep-alive\r\n//升级信息\r\nUpgrade-Insecure-Requests: 1\r\n//请求空行\r\n\r\n//请求体  只有post请求有请求体,get请求没有请求体\r\nusername=zhangsan\r\n```\r\n\r\n## 盗链\r\n\r\n![image-20230417151628825](./assets/image-20230417151628825.png)\r\n\r\n## Request 对象\r\n\r\n1. Tomcat 解析 url 路径，创建 servlet 对象\r\n2. Tomcat 创建 res 和 req 对象，并封装 req 对象，传递给 servlet 对象中的 service 方法\r\n3. 通过 req 对象获取消息，通过 res 对象设置响应消息\r\n\r\n![image-20230417151631694](./assets/image-20230417151631694.png)\r\n\r\n### Request 对象继承体系\r\n\r\n```\r\nServletRequest\r\n\t  继承\r\nHttpServletRequest\r\n\t  实现\r\nRequestFacade\r\n```\r\n\r\n![image-20230417151636230](./assets/image-20230417151636230.png)\r\n\r\n理解\r\n\r\n> 对 `protected void doGet(HttpServletRequest request,...)` 的理解，request 就是 RequestFacade 对象\r\n\r\n![image-20230417151638783](./assets/image-20230417151638783.png)\r\n\r\n### Request 对象方法\r\n\r\n### 对 Request 请求获取方法\r\n\r\n1. **获取请求行数据**\r\n\r\n   | **☆获取项目名称**         | **String getContextPath()**                                                                                                              |\r\n   | ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |\r\n   | **☆获取请求 URI**          | **String getRequestURI()  /demo/login.html [共和国]<br/>StringBuffer getRequestURL() http://localhost/demo/login.html [中华人民共和国]** |\r\n   | 获取请求方式[get,post...] | String getMethod()                                                                                                                       |\r\n   | 获取 Servlet 路径           | String getServletPath()                                                                                                                  |\r\n   | 获取 get 方式请求参数       | String getQueryString()                                                                                                                  |\r\n   | 获取协议及版本            | String getProtocol()                                                                                                                     |\r\n   | 获取客户机的 IP 地址        | String getRemoteAddr()                                                                                                                   |\r\n   | 获取请求头数据            | String getHeader(String name):通过请求头的名称获取请求头的值 Enumeration<String> getHeaderNames():获取所有的请求头名称                    |\r\n\r\n2. **获取请求头数据**\r\n\r\n   | 获取请求头的名称获取请求头的值 | String getHeader(String name)        |\r\n   | ------------------------------ | ------------------------------------ |\r\n   | 获取所有请求头的名称           | Enumeration<String> getHeaderNames() |\r\n\r\n3. **获取请求体数据**\r\n\r\n   >只有 POST 请求方式，在请求体中封装了 POST 请求的请求参数\r\n\r\n   | 获取字符输入流，只能操作字符数据     | BufferedReader getReader()          |\r\n   | ------------------------------------ | ----------------------------------- |\r\n   | 获取字节输入流，可以操作所有类型数据 | ServletInputStream getInputStream() |\r\n\r\n### Request 通用方法\r\n\r\n1. **获取请求参数**\r\n\r\n   >中文乱码问题\r\n   >\r\n   >get 方式：Tomcat8 已经将 get 方式乱码问题解决了\r\n   >\r\n   >post 方式：会乱码，设置 request 的编码☆request.setCharacterEncoding(\"utf-8\");\r\n\r\n   | ☆根据参数名称获取参数值      | String getParameter(String name)         |\r\n   | ---------------------------- | ---------------------------------------- |\r\n   | 根据参数名称获取参数值的数组 | String[] getParameterValues(String name) |\r\n   | 获取所有请求的参数名称       | Enumeration<String> getParameterNames()  |\r\n   | ☆获取所有参数的 map 集合       | Map<String,String[]> getParameterMap()   |\r\n\r\n2. **请求转发**\r\n\r\n   >1.浏览器[**地址栏路径不发生变化**\r\n   >\r\n   >2.只能转发到当前 [**服务器内部资源**]中\r\n   >\r\n   >3.转发是[**一次请求**]\r\n\r\n   | ☆通过 request 对象获取请求转发器对象   | RequestDispatcher getRequestDispatcher(String path)       |\r\n   | ------------------------------------ | --------------------------------------------------------- |\r\n   | ☆使用 RequestDispatcher 对象来进行转发 | forward(ServletRequest request, ServletResponse response) |\r\n\r\n3. **共享数据**\r\n\r\n   > 域对象：一个有作用范围的对象，可以在范围内共享数据\r\n   >\r\n   > request 域：代表一次请求的范围，一般用于请求转发的多个 selevet 中共享数据\r\n\r\n   | 存储数据         | void setAttribute(String name,Object obj) |\r\n   | ---------------- | ----------------------------------------- |\r\n   | 通过键获取值     | Object getAttitude(String name)           |\r\n   | 通过键移除键值对 | void removeAttribute(String name)         |\r\n\r\n4. **获取 servletContext**\r\n\r\n   | 动态获取项目路径，简化修改 | ServletContext getServletContext() |\r\n   | ------------------------- | ---------------------------------- |\r\n\r\n## 用户登录案例\r\n\r\n![image-20230417151646194](./assets/image-20230417151646194.png)\r\n\r\n## BeanUtils 工具类\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>commons-beanutils</groupId>\r\n    <artifactId>commons-beanutils</artifactId>\r\n    <version>1.9.4</version>\r\n</dependency>\r\n```\r\n\r\n```\r\nBeanUtils.populate(loginUser,map); //将map封装到对象中\r\n```\r\n\r\n## Response 响应格式\r\n\r\n- 响应行\r\n\r\n  - `请求协议/版本 响应状态码` \r\n  - `HTTP/1.1 200 OK`\r\n\r\n- 响应头：服务器对客户端发送的响应消息\r\n\r\n  Content-Type: 响应体数据格式以及编码格式\r\n\r\n  Content-disposition: 以什么格式打开响应体数据\r\n\r\n  * in-line: 默认值，在当前页面内打开\r\n  * attachment;filename=xxx: 以附件形式打开响应体，文件下载\r\n\r\n- 响应空行\r\n\r\n  - 空行\r\n\r\n- 响应体 (正文)\r\n\r\n```html\r\n//响应行\r\nHTTP/1.1 200 OK\r\n//响应头\r\nAccept-Ranges: bytes\r\nETag: W/\"335-1648612784418\"\r\nLast-Modified: Wed, 30 Mar 2022 03:59:44 GMT\r\nContent-Type: text/html\r\nContent-Length: 335\r\nDate: Wed, 30 Mar 2022 05:32:19 GMT\r\nKeep-Alive: timeout=20\r\nConnection: keep-alive\r\n//响应空行\r\n\r\n//响应体\r\n<html>\r\n    <head>\r\n        <title>$Title$</title>\r\n    </head>\r\n    <body>\r\n        $END$\r\n    </body>\r\n</html>\r\n```\r\n\r\n## 响应状态码\r\n\r\n| 1xx | 服务端接收消息但没有接收完全，等待一段时间后发送 1xx 状态码       |\r\n| --- | -------------------------------------------------------------- |\r\n| 2xx | 成功                                                           |\r\n| 3xx | 302 重定向  304 缓存                                             |\r\n| 4xx | 客户端错误  404 请求路径没有资源 405 请求方式没有对应的 doXXX 方法 |\r\n| 5xx | 服务端错误 500 服务器内部错误                                   |\r\n\r\n## 重定向\r\n\r\n![image-20230417151649942](./assets/image-20230417151649942.png)\r\n\r\n## 访问缓存\r\n\r\n![image-20230417151652051](./assets/image-20230417151652051.png)\r\n\r\n## Response 对象\r\n\r\n### 对 Response 响应设置方法\r\n\r\n1. **设置响应行数据**\r\n\r\n   | 设置状态码 | setStatus(int sx) |\r\n   | ---------- | ----------------- |\r\n\r\n2. **设置响应头数据**\r\n\r\n   | 设置响应头数据 | setHeader(String name,String value) |\r\n   | -------------- | ----------------------------------- |\r\n\r\n3. **设置响应体数据**\r\n\r\n   | 获取字符输出流 | PrintWriter getWriter()               |\r\n   | -------------- | ------------------------------------- |\r\n   | 获取字节输出流 | ServletOutputStream getOutputStream() |\r\n\r\n### Response 通用方法\r\n\r\n**1.重定向**\r\n\r\n> 1.地址栏发送变化\r\n>\r\n> 2.重定向可以访问其他路径下的资源\r\n>\r\n> 3.重定向是两次请求，不能用 request 域共享数据\r\n\r\n| 重定向     | response.sendRedirect(\"/web/responseServletDemo2\");                                       |\r\n| ---------- | ----------------------------------------------------------------------------------------- |\r\n| 或者这样写 | response.setStatus(302);<br/>response.setHeader(\"location\", \"/web/responseServletDemo2\"); |\r\n\r\n**2.服务器输出字符数据到浏览器**\r\n\r\n| 字符               | PrintWriter writer = response.getWriter(); <br>writer.write(\"hello 张三\"); |\r\n| ------------------ | ------------------------------------------------------------------------- |\r\n| 乱码               | response.setContentType(\"text/html;charset=utf-8\");                       |\r\n| 告诉浏览器编码方式 | response.setHeader(\"content-type\",\"text/html;charset=utf-8\");             |\r\n| 同一个原理         | response.setContentType(\"text/html;charset=utf-8\");                       |\r\n\r\n**3.服务器输出字节数据到浏览器**\r\n\r\n| 字节 | ServletOutputStream is = response.getOutputStream();<br>is.write(\"hello 张三\".getBytes(StandardCharsets.UTF_8)); |\r\n| ---- | --------------------------------------------------------------------------------------------------------------- |\r\n\r\n## ServletContext 对象\r\n\r\n> 代表整个 web 应用，可以和服务器通信\r\n\r\n| 通过 request 获取     | request.getServletContext |\r\n| ------------------- | ------------------------- |\r\n| 通过 httpServlet 获取 | this.getServletContext    |\r\n\r\n1. 获取 MIME 类型\r\n\r\n   1. 互联网通信中定义的文件类型 \r\n\r\n   2. 大类型/小类型  text/html   image/jpeg\r\n\r\n      | 获取 mine 类型 | getMimeType |\r\n      | ------------ | ----------- |\r\n\r\n2. 域对象：共享数据\r\n\r\n   | 存储数据         | void setAttribute(String name,Object obj) |\r\n   | ---------------- | ----------------------------------------- |\r\n   | 通过键获取值     | Object getAttitude(String name)           |\r\n   | 通过键移除键值对 | void removeAttribute(String name)         |\r\n\r\n   > ServletContext 域对象的范围是最大的，共享项目中所有的对象\r\n\r\n3. 获取文件的真实路径\r\n\r\n   | 获取文件的真实路径  | getRealPath()                          |\r\n   | ------------------- | -------------------------------------- |\r\n   | src 目录下的文件     | getRealPath(\"/WEB-INFO/classes/a.txt\") |\r\n   | web 目录下的文件     | getRealPath(\"/a.txt\")                  |\r\n   | WEB-INF 目录下的文件 | getRealPath(\"/WEB-INF/a.txt\")          |\r\n\r\n> 超链接下的资源如果浏览器能够解析就展示，不能解析就下载\r\n>\r\n> Content-disposition: 以什么格式打开响应体数据\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/04.HTTP.md b/src/java/javaweb/04.HTTP.md
--- a/src/java/javaweb/04.HTTP.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/04.HTTP.md	(date 1682515257622)
@@ -1,12 +1,5 @@
 ---
-title: HTTP
-date: 2023-03-07 14:59:21
-permalink: /pages/8976c3/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # HTTP
 
@@ -109,13 +102,13 @@
    | 获取 get 方式请求参数       | String getQueryString()                                                                                                                  |
    | 获取协议及版本            | String getProtocol()                                                                                                                     |
    | 获取客户机的 IP 地址        | String getRemoteAddr()                                                                                                                   |
-   | 获取请求头数据            | String getHeader(String name):通过请求头的名称获取请求头的值 Enumeration<String> getHeaderNames():获取所有的请求头名称                    |
+   | 获取请求头数据            | `String getHeader(String name)`:通过请求头的名称获取请求头的值 `Enumeration<String> getHeaderNames()`:获取所有的请求头名称                |
 
 2. **获取请求头数据**
 
-   | 获取请求头的名称获取请求头的值 | String getHeader(String name)        |
-   | ------------------------------ | ------------------------------------ |
-   | 获取所有请求头的名称           | Enumeration<String> getHeaderNames() |
+   | 获取请求头的名称获取请求头的值 | String getHeader(String name)           |
+   | ------------------------------ | --------------------------------------- |
+   | 获取所有请求头的名称           | `Enumeration <String> getHeaderNames()` |
 
 3. **获取请求体数据**
 
@@ -135,11 +128,11 @@
    >
    >post 方式：会乱码，设置 request 的编码☆request.setCharacterEncoding("utf-8");
 
-   | ☆根据参数名称获取参数值      | String getParameter(String name)         |
+   | ☆根据参数名称获取参数值      | `String getParameter(String name)`       |
    | ---------------------------- | ---------------------------------------- |
-   | 根据参数名称获取参数值的数组 | String[] getParameterValues(String name) |
-   | 获取所有请求的参数名称       | Enumeration<String> getParameterNames()  |
-   | ☆获取所有参数的 map 集合       | Map<String,String[]> getParameterMap()   |
+   | 根据参数名称获取参数值的数组 | `String[] getParameterValues(String name)` |
+   | 获取所有请求的参数名称       | `Enumeration<String> getParameterNames()` |
+   | ☆获取所有参数的 map 集合       | `Map<String,String[]> getParameterMap()` |
 
 2. **请求转发**
 
Index: src/java/javaweb/01.JavaWeb 基础.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: JavaWeb 基础\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/b53599/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# JavaWeb 基础\r\n\r\n## 网络通信三要素\r\n\r\n- IP：计算机在网络中的唯一标识\r\n- 端口：应用程序在网络中的唯一标识 (0~65535)\r\n- 传输协议：`tcp:安全 三次握手 速度稍慢 udp:不安全 速度快`\r\n\r\n## Tomcat\r\n\r\n- Tomcat 是 web 服务器，存放项目的静态资源和动态资源\r\n\r\n- Tomcat 目录结构\r\n\r\n![image-20230417151435653](./assets/image-20230417151435653.png)\r\n\r\n- 简单部署：将项目打成 war 包，将 war 放到 webapps 目录下，war 包会自动解压缩\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/01.JavaWeb 基础.md b/src/java/javaweb/01.JavaWeb 基础.md
--- a/src/java/javaweb/01.JavaWeb 基础.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/01.JavaWeb 基础.md	(date 1682512970063)
@@ -1,12 +1,5 @@
 ---
-title: JavaWeb 基础
-date: 2023-03-07 14:59:21
-permalink: /pages/b53599/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # JavaWeb 基础
 
Index: src/java/javaweb/11.Filter 过滤器.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Filter 过滤器\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/7beafb/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# Filter 过滤器\r\n\r\n## Filter 过滤器概念\r\n\r\n> 拦截请求，增强功能，通用功能\r\n\r\n![image-20230417151755353](./assets/image-20230417151755353.png)\r\n\r\n##  Filter 常见功能\r\n\r\n- 登录验证\r\n- 统一编码\r\n- 敏感字符过滤\r\n\r\n## Filter 实现细节\r\n\r\n- 实现 Filter 接口\r\n\r\n- Filter[xml 配置]和注解配置\r\n\r\n```xml\r\n<filter>\r\n    <filter-name>myFilter</filter-name>\r\n    <filter-class>filter.MyFilter01</filter-class>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>myFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n</filter-mapping>\r\n```\r\n\r\n- 配置@WebFilter(\"/*\")\r\n- 过滤器执行流程\r\n\r\n`请求`->`过滤器`->`对Request进行增强`->`放行`->`响应`->`过滤器`->`对Response进行增强`\r\n\r\n- Filter 生命周期：参考 Servlet\r\n  - init\r\n  - doFilter\r\n  - destroy\r\n- Filter 配置\r\n  - 拦截路径配置：`/*` `/user/*` `*.jsp` `/index.jsp`\r\n  - 拦截方式配置：\r\n    - 资源访问方式:dispatcherTypes\r\n    - DispatcherType.REQUEST:浏览器直接访问资源\r\n    - DispatcherType.FORWARD:转发访问资源\r\n    - DispatcherType.INCLUDE:包含访问资源\r\n    - DispatcherType.ERROR:错误跳转资源\r\n    - DispatcherType.ASYNC:异部访问\r\n- Filter 链\r\n  - `Filter1`->`Filter2`->`Filter2`->`Filter1`\r\n\r\n## Filter 案例\r\n\r\n![image-20230417151800276](./assets/image-20230417151800276.png)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/11.Filter 过滤器.md b/src/java/javaweb/11.Filter 过滤器.md
--- a/src/java/javaweb/11.Filter 过滤器.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/11.Filter 过滤器.md	(date 1682512990959)
@@ -1,12 +1,5 @@
 ---
-title: Filter 过滤器
-date: 2023-03-07 14:59:21
-permalink: /pages/7beafb/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # Filter 过滤器
 
Index: src/java/javaweb/10.JSTL 表达式.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: JSTL 表达式\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/0f0354/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n\r\n# JSTL 表达式\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/10.JSTL 表达式.md b/src/java/javaweb/10.JSTL 表达式.md
--- a/src/java/javaweb/10.JSTL 表达式.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/10.JSTL 表达式.md	(date 1682512989464)
@@ -1,12 +1,5 @@
 ---
-title: JSTL 表达式
-date: 2023-03-07 14:59:21
-permalink: /pages/0f0354/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 
 # JSTL 表达式
Index: src/java/javaweb/13.开发那些事.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 开发那些事\r\ndate: 2023-04-17 18:56:46\r\npermalink: /pages/a07d97/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# 开发那些事\r\n\r\n[开发那些事](http://heavy_code_industry.gitee.io/code_heavy_industry/pro000-dev-story/)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/13.开发那些事.md b/src/java/javaweb/13.开发那些事.md
--- a/src/java/javaweb/13.开发那些事.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/13.开发那些事.md	(date 1682512995552)
@@ -1,12 +1,5 @@
 ---
-title: 开发那些事
-date: 2023-04-17 18:56:46
-permalink: /pages/a07d97/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # 开发那些事
 
Index: src/java/javase/14.Java File 类与 IO 流.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\norder: 14\r\ncategories:\r\n  - Java\r\n---\r\n# Java File 类与 IO 流\r\n\r\n官网：[http://www.atguigu.com](http://www.atguigu.com/)\r\n\r\n---\r\n\r\n![image-20230417080941042](./../../.vuepress/public/Tomcat/image-20230417080941042.png)\r\n\r\n## java.io.File 类的使用\r\n\r\n### 概述\r\n\r\n-  File 类及本章下的各种流，都定义在 java.io 包下。\r\n-  一个 File 对象代表硬盘或网络中可能存在的一个文件或者文件目录（俗称文件夹），与平台无关。（体会万事万物皆对象）\r\n-  File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。\r\n   - File 对象可以作为参数传递给流的构造器。\r\n-  想要在 Java 程序中表示一个真实存在的文件或目录，那么必须有一个 File 对象，但是 Java 程序中的一个 File 对象，可能没有一个真实存在的文件或目录。\r\n\r\n\r\n### 构造器\r\n\r\n* `public File(String pathname) ` ：以 pathname 为路径创建 File 对象，可以是绝对路径或者相对路径，如果 pathname 是相对路径，则默认的当前路径在系统属性 user.dir 中存储。\r\n* `public File(String parent, String child) ` ：以 parent 为父路径，child 为子路径创建 File 对象。\r\n* `public File(File parent, String child)` ：根据一个父 File 对象和子文件路径创建 File 对象\r\n\r\n关于路径：\r\n\r\n* **绝对路径：**从盘符开始的路径，这是一个完整的路径。\r\n* **相对路径：**相对于`项目目录`的路径，这是一个便捷的路径，开发中经常使用。\r\n  * IDEA 中，main 中的文件的相对路径，是相对于\"`当前工程`\"\r\n  * IDEA 中，单元测试方法中的文件的相对路径，是相对于\"`当前module`\"\r\n\r\n举例：\r\n\r\n```java\r\npublic class FileObjectTest {\r\n    public static void main(String[] args) {\r\n        // 文件路径名\r\n        String pathname = \"D:\\\\aaa.txt\";\r\n        File file1 = new File(pathname);\r\n\r\n        // 文件路径名\r\n        String pathname2 = \"D:\\\\aaa\\\\bbb.txt\";\r\n        File file2 = new File(pathname2);\r\n\r\n        // 通过父路径和子路径字符串\r\n        String parent = \"d:\\\\aaa\";\r\n        String child = \"bbb.txt\";\r\n        File file3 = new File(parent, child);\r\n\r\n        // 通过父级 File 对象和子路径字符串\r\n        File parentDir = new File(\"d:\\\\aaa\");\r\n        String childFile = \"bbb.txt\";\r\n        File file4 = new File(parentDir, childFile);\r\n    }\r\n    \r\n    @Test\r\n    public void test01() throws IOException{\r\n        File f1 = new File(\"d:\\\\atguigu\\\\javase\\\\HelloIO.java\"); //绝对路径\r\n        System.out.println(\"文件/目录的名称：\" + f1.getName());\r\n        System.out.println(\"文件/目录的构造路径名：\" + f1.getPath());\r\n        System.out.println(\"文件/目录的绝对路径名：\" + f1.getAbsolutePath());\r\n        System.out.println(\"文件/目录的父目录名：\" + f1.getParent());\r\n    }\r\n    @Test\r\n    public void test02()throws IOException{\r\n        File f2 = new File(\"/HelloIO.java\");//绝对路径，从根路径开始\r\n        System.out.println(\"文件/目录的名称：\" + f2.getName());\r\n        System.out.println(\"文件/目录的构造路径名：\" + f2.getPath());\r\n        System.out.println(\"文件/目录的绝对路径名：\" + f2.getAbsolutePath());\r\n        System.out.println(\"文件/目录的父目录名：\" + f2.getParent());\r\n    }\r\n\r\n    @Test\r\n    public void test03() throws IOException {\r\n        File f3 = new File(\"HelloIO.java\");//相对路径\r\n        System.out.println(\"user.dir =\" + System.getProperty(\"user.dir\"));\r\n        System.out.println(\"文件/目录的名称：\" + f3.getName());\r\n        System.out.println(\"文件/目录的构造路径名：\" + f3.getPath());\r\n        System.out.println(\"文件/目录的绝对路径名：\" + f3.getAbsolutePath());\r\n        System.out.println(\"文件/目录的父目录名：\" + f3.getParent());\r\n    }\r\n    @Test\r\n    public void test04() throws IOException{\r\n        File f5 = new File(\"HelloIO.java\");//相对路径\r\n        System.out.println(\"user.dir =\" + System.getProperty(\"user.dir\"));\r\n        System.out.println(\"文件/目录的名称：\" + f5.getName());\r\n        System.out.println(\"文件/目录的构造路径名：\" + f5.getPath());\r\n        System.out.println(\"文件/目录的绝对路径名：\" + f5.getAbsolutePath());\r\n        System.out.println(\"文件/目录的父目录名：\" + f5.getParent());\r\n    }\r\n}\r\n```\r\n\r\n> 注意：\r\n>\r\n> 1. 无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。\r\n>\r\n> 2. window 的路径分隔符使用“\\”，而 Java 程序中的“\\”表示转义字符，所以在 Windows 中表示路径，需要用“\\\\”。或者直接使用“/”也可以，Java 程序支持将“/”当成平台无关的`路径分隔符`。或者直接使用 File.separator 常量值表示。比如：\r\n>\r\n>    File file2 = new File(\"d:\" + File.separator + \"atguigu\" + File.separator + \"info.txt\");\r\n>\r\n> 3. 当构造路径是绝对路径时，那么 getPath 和 getAbsolutePath 结果一样\r\n>\r\n>    当构造路径是相对路径时，那么 getAbsolutePath 的路径 = user.dir 的路径 + 构造路径\r\n\r\n### 常用方法\r\n\r\n#### 1、获取文件和目录基本信息\r\n\r\n* public String getName() ：获取名称\r\n* public String getPath() ：获取路径\r\n* `public String getAbsolutePath()`：获取绝对路径\r\n* public File getAbsoluteFile()：获取绝对路径表示的文件\r\n* `public String getParent()`：获取上层文件目录路径。若无，返回 null\r\n* public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。\r\n* public long lastModified() ：获取最后一次的修改时间，毫秒值\r\n\r\n> 如果 File 对象代表的文件或目录存在，则 File 对象实例初始化时，就会用硬盘中对应文件或目录的属性信息（例如，时间、类型等）为 File 对象的属性赋值，否则除了路径和名称，File 对象的其他属性将会保留默认值。\r\n\r\n![image-20230417081813872](./assets/image-20230417081813872.png)\r\n\r\n举例：\r\n\r\n```java\r\npublic class FileInfoMethod {\r\n    public static void main(String[] args) {\r\n        File f = new File(\"d:/aaa/bbb.txt\");\r\n        System.out.println(\"文件构造路径：\"+f.getPath());\r\n        System.out.println(\"文件名称：\"+f.getName());\r\n        System.out.println(\"文件长度：\"+f.length()+\"字节\");\r\n        System.out.println(\"文件最后修改时间：\" + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of(\"Asia/Shanghai\")));\r\n\r\n        File f2 = new File(\"d:/aaa\");\r\n        System.out.println(\"目录构造路径：\"+f2.getPath());\r\n        System.out.println(\"目录名称：\"+f2.getName());\r\n        System.out.println(\"目录长度：\"+f2.length()+\"字节\");\r\n        System.out.println(\"文件最后修改时间：\" + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of(\"Asia/Shanghai\")));\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n输出结果：\r\n文件构造路径:d:\\aaa\\bbb.java\r\n文件名称:bbb.java\r\n文件长度:636字节\r\n文件最后修改时间：2022-07-23T22:01:32.065\r\n\r\n目录构造路径:d:\\aaa\r\n目录名称:aaa\r\n目录长度:4096字节\r\n文件最后修改时间：2022-07-23T22:01:32.065\r\n```\r\n\r\n#### 2、列出目录的下一级\r\n\r\n* public String[] list() ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。\r\n* public File[] listFiles() ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。 \r\n\r\n```java\r\npublic class DirListFiles {\r\n    @Test\r\n    public void test01() {\r\n        File dir = new File(\"d:/atguigu\");\r\n        String[] subs = dir.list();\r\n        for (String sub : subs) {\r\n            System.out.println(sub);\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### 3、File 类的重命名功能\r\n\r\n- public boolean renameTo(File dest):把文件重命名为指定的文件路径。\r\n\r\n#### 4、判断功能的方法\r\n\r\n- `public boolean exists()` ：此 File 表示的文件或目录是否实际存在。\r\n- `public boolean isDirectory()` ：此 File 表示的是否为目录。\r\n- `public boolean isFile()` ：此 File 表示的是否为文件。\r\n- public boolean canRead() ：判断是否可读\r\n- public boolean canWrite() ：判断是否可写\r\n- public boolean isHidden() ：判断是否隐藏\r\n\r\n\r\n举例：\r\n\r\n```java\r\npublic class FileIs {\r\n    public static void main(String[] args) {\r\n        File f = new File(\"d:\\\\aaa\\\\bbb.java\");\r\n        File f2 = new File(\"d:\\\\aaa\");\r\n        // 判断是否存在\r\n        System.out.println(\"d:\\\\aaa\\\\bbb.java 是否存在：\"+f.exists());\r\n        System.out.println(\"d:\\\\aaa 是否存在：\"+f2.exists());\r\n        // 判断是文件还是目录\r\n        System.out.println(\"d:\\\\aaa 文件？:\"+f2.isFile());\r\n        System.out.println(\"d:\\\\aaa 目录？:\"+f2.isDirectory());\r\n    }\r\n}\r\n```\r\n\r\n```\r\n输出结果：\r\nd:\\aaa\\bbb.java 是否存在:true\r\nd:\\aaa 是否存在:true\r\nd:\\aaa 文件?:false\r\nd:\\aaa 目录?:true\r\n```\r\n\r\n> 如果文件或目录不存在，那么 exists()、isFile() 和 isDirectory() 都是返回 true\r\n\r\n#### 5、创建、删除功能\r\n\r\n- `public boolean createNewFile()` ：创建文件。若文件存在，则不创建，返回 false。\r\n- `public boolean mkdir()` ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。\r\n- `public boolean mkdirs()` ：创建文件目录。如果上层文件目录不存在，一并创建。\r\n- `public boolean delete()` ：删除文件或者文件夹\r\n  删除注意事项：① Java 中的删除不走回收站。② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。\r\n\r\n举例：\r\n\r\n```java\r\npublic class FileCreateDelete {\r\n    public static void main(String[] args) throws IOException {\r\n        // 文件的创建\r\n        File f = new File(\"aaa.txt\");\r\n        System.out.println(\"aaa.txt 是否存在：\"+f.exists()); \r\n        System.out.println(\"aaa.txt 是否创建：\"+f.createNewFile()); \r\n        System.out.println(\"aaa.txt 是否存在：\"+f.exists()); \r\n\r\n        // 目录的创建\r\n        File f2= new File(\"newDir\");\r\n        System.out.println(\"newDir 是否存在：\"+f2.exists());\r\n        System.out.println(\"newDir 是否创建：\"+f2.mkdir());\r\n        System.out.println(\"newDir 是否存在：\"+f2.exists());\r\n\r\n        // 创建一级目录\r\n        File f3= new File(\"newDira\\\\newDirb\");\r\n        System.out.println(\"newDira\\\\newDirb 创建：\" + f3.mkdir());\r\n        File f4= new File(\"newDir\\\\newDirb\");\r\n        System.out.println(\"newDir\\\\newDirb 创建：\" + f4.mkdir());\r\n        // 创建多级目录\r\n        File f5= new File(\"newDira\\\\newDirb\");\r\n        System.out.println(\"newDira\\\\newDirb 创建：\" + f5.mkdirs());\r\n\r\n        // 文件的删除\r\n        System.out.println(\"aaa.txt 删除：\" + f.delete());\r\n\r\n        // 目录的删除\r\n        System.out.println(\"newDir 删除：\" + f2.delete());\r\n        System.out.println(\"newDir\\\\newDirb 删除：\" + f4.delete());\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n运行结果：\r\naaa.txt是否存在:false\r\naaa.txt是否创建:true\r\naaa.txt是否存在:true\r\nnewDir是否存在:false\r\nnewDir是否创建:true\r\nnewDir是否存在:true\r\nnewDira\\newDirb创建：false\r\nnewDir\\newDirb创建：true\r\nnewDira\\newDirb创建：true\r\naaa.txt删除：true\r\nnewDir删除：false\r\nnewDir\\newDirb删除：true\r\n```\r\n\r\n> API 中说明：delete 方法，如果此 File 表示目录，则目录必须为空才能删除。\r\n\r\n### 练习\r\n\r\n练习 1：利用 File 构造器，new 一个文件目录 file\r\n\r\n\u200B      1) 在其中创建多个文件和目录\r\n\r\n\u200B      2) 编写方法，实现删除 file 中指定文件的操作\r\n\r\n练习 2：判断指定目录下是否有后缀名为.jpg 的文件。如果有，就输出该文件名称\r\n\r\n```java\r\npublic class FindJPGFileTest {\r\n\t//方法 1：\r\n\t@Test\r\n\tpublic void test1(){\r\n\t\tFile srcFile = new File(\"d:\\\\code\");\r\n\t\t\r\n\t\tString[] fileNames = srcFile.list();\r\n\t\tfor(String fileName : fileNames){\r\n\t\t\tif(fileName.endsWith(\".jpg\")){\r\n\t\t\t\tSystem.out.println(fileName);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n    //方法 2：\r\n\t@Test\r\n\tpublic void test2(){\r\n\t\tFile srcFile = new File(\"d:\\\\code\");\r\n\t\t\r\n\t\tFile[] listFiles = srcFile.listFiles();\r\n\t\tfor(File file : listFiles){\r\n\t\t\tif(file.getName().endsWith(\".jpg\")){\r\n\t\t\t\tSystem.out.println(file.getAbsolutePath());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n    //方法 3：\r\n\t/*\r\n\t * File 类提供了两个文件过滤器方法\r\n\t * public String[] list(FilenameFilter filter)\r\n\t * public File[] listFiles(FileFilter filter)\r\n\r\n\t */\r\n\t@Test\r\n\tpublic void test3(){\r\n\t\tFile srcFile = new File(\"d:\\\\code\");\r\n\t\t\r\n\t\tFile[] subFiles = srcFile.listFiles(new FilenameFilter() {\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic boolean accept(File dir, String name) {\r\n\t\t\t\treturn name.endsWith(\".jpg\");\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tfor(File file : subFiles){\r\n\t\t\tSystem.out.println(file.getAbsolutePath());\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n\r\n```\r\n\r\n练习 3：遍历指定目录所有文件名称，包括子文件目录中的文件。\r\n\r\n  拓展 1：并计算指定目录占用空间的大小\r\n\r\n  拓展 2：删除指定文件目录及其下的所有文件\r\n\r\n```java\r\npublic class ListFilesTest {\r\n\t//练习 3：(方式 1)\r\n    public static void printSubFile(File dir) {\r\n        // 打印目录的子文件\r\n        File[] subfiles = dir.listFiles();\r\n\r\n        for (File f : subfiles) {\r\n            if (f.isDirectory()) {// 文件目录\r\n                printSubFile(f);\r\n            } else {// 文件\r\n                System.out.println(f.getAbsolutePath());\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    // //练习 3：(方式 2)\r\n    public void listAllSubFiles(File file) {\r\n        if (file.isFile()) {\r\n            System.out.println(file);\r\n        } else {\r\n            File[] all = file.listFiles();\r\n            // 如果 all[i] 是文件，直接打印\r\n            // 如果 all[i] 是目录，接着再获取它的下一级\r\n            for (File f : all) {\r\n                listAllSubFiles(f);// 递归调用：自己调用自己就叫递归\r\n            }\r\n        }\r\n    }\r\n    @Test\r\n    public void testListAllFiles(){\r\n        // 1.创建目录对象\r\n        File dir = new File(\"E:\\\\teach\\\\01_javaSE\\\\_尚硅谷 Java 编程语言\\\\3_软件\");\r\n\r\n        // 2.打印目录的子文件\r\n        printSubFile(dir);\r\n    }\r\n\r\n    // 拓展 1：求指定目录所在空间的大小\r\n    public long getDirectorySize(File file) {\r\n        // file 是文件，那么直接返回 file.length()\r\n        // file 是目录，把它的下一级的所有 file 大小加起来就是它的总大小\r\n        long size = 0;\r\n        if (file.isFile()) {\r\n            size = file.length();\r\n        } else {\r\n            File[] all = file.listFiles();// 获取 file 的下一级\r\n            // 累加 all[i] 的大小\r\n            for (File f : all) {\r\n                size += getDirectorySize(f);// f 的大小;\r\n            }\r\n        }\r\n        return size;\r\n    }\r\n\r\n    // 拓展 2：删除指定的目录\r\n    public void deleteDirectory(File file) {\r\n        // 如果 file 是文件，直接 delete\r\n        // 如果 file 是目录，先把它的下一级干掉，然后删除自己\r\n        if (file.isDirectory()) {\r\n            File[] all = file.listFiles();\r\n            // 循环删除的是 file 的下一级\r\n            for (File f : all) {// f 代表 file 的每一个下级\r\n                deleteDirectory(f);\r\n            }\r\n        }\r\n        // 删除自己\r\n        file.delete();\r\n    }\r\n\r\n}\r\n```\r\n\r\n## IO 流原理及流的分类\r\n\r\n![image-20230417081930697](./assets/image-20230417081930697.png)\r\n\r\n### Java IO 原理\r\n\r\n- Java 程序中，对于数据的输入/输出操作以“`流(stream)`”的方式进行，可以看做是一种数据的流动。\r\n\r\n  ![image-20230417081935674](./assets/image-20230417081935674.png)\r\n\r\n- I/O流中的I/O是`Input/Output`的缩写，I/O 技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。\r\n\r\n  - `输入input`：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。\r\n  - `输出output`：将程序（内存）数据输出到磁盘、光盘等存储设备中。\r\n\r\n![image-20230417081939800](./assets/image-20230417081939800.png)\r\n\r\n### 流的分类\r\n\r\n`java.io`包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过`标准的方法`输入或输出数据。\r\n\r\n- 按数据的流向不同分为：**输入流**和**输出流**。\r\n\r\n  - **输入流** ：把数据从`其他设备`上读取到`内存`中的流。 \r\n    - 以 InputStream、Reader 结尾\r\n  - **输出流** ：把数据从`内存` 中写出到`其他设备`上的流。\r\n    - 以 OutputStream、Writer 结尾\r\n\r\n- 按操作数据单位的不同分为：**字节流（8bit）**和**字符流（16bit）**。\r\n\r\n  - **字节流** ：以字节为单位，读写数据的流。\r\n    - 以 InputStream、OutputStream 结尾\r\n  - **字符流** ：以字符为单位，读写数据的流。\r\n    - 以 Reader、Writer 结尾\r\n\r\n- 根据 IO 流的角色不同分为：**节点流**和**处理流**。\r\n\r\n  - **节点流**：直接从数据源或目的地读写数据\r\n\r\n    ![image-20230417082031653](./assets/image-20230417082031653.png)\r\n\r\n  - **处理流**：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。\r\n\r\n    ![image-20230417082038180](./assets/image-20230417082038180.png)\r\n\r\n小结：图解\r\n\r\n![image-20230417082111336](./assets/image-20230417082111336.png)\r\n\r\n### 流的 API\r\n\r\n- Java 的 IO 流共涉及 40 多个类，实际上非常规则，都是从如下 4 个抽象基类派生的。\r\n\r\n| （抽象基类） |   输入流    |    输出流    |\r\n| :----------: | :---------: | :----------: |\r\n|    字节流    | InputStream | OutputStream |\r\n|    字符流    |   Reader    |    Writer    |\r\n\r\n- 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。\r\n\r\n![image-20230417082132377](./assets/image-20230417082132377.png)\r\n\r\n**常用的节点流：**  \r\n\r\n* 文件流：FileInputStream、FileOutputStrean、FileReader、FileWriter \r\n* 字节/字符数组流：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter \r\n  * 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。\r\n\r\n**常用处理流：**\r\n\r\n* 缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter\r\n  * 作用：增加缓冲功能，避免频繁读写硬盘，进而提升读写效率。\r\n* 转换流：InputStreamReader、OutputStreamReader\r\n  * 作用：实现字节流和字符流之间的转换。\r\n* 对象流：ObjectInputStream、ObjectOutputStream\r\n  * 作用：提供直接读写 Java 对象功能\r\n\r\n## 节点流之一：FileReader\\FileWriter\r\n\r\n### Reader 与 Writer\r\n\r\nJava 提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。不能操作图片，视频等非文本文件。\r\n\r\n> 常见的文本文件有如下的格式：.txt、.java、.c、.cpp、.py 等\r\n>\r\n> 注意：.doc、.xls、.ppt 这些都不是文本文件。\r\n\r\n#### 字符输入流：Reader\r\n\r\n`java.io.Reader`抽象类是表示用于读取字符流的所有类的父类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\r\n\r\n- `public int read()`：从输入流读取一个字符。虽然读取了一个字符，但是会自动提升为 int 类型。返回该字符的 Unicode 编码值。如果已经到达流末尾了，则返回 -1。\r\n- `public int read(char[] cbuf)`：从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中。每次最多读取 cbuf.length 个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回 -1。 \r\n- `public int read(char[] cbuf,int off,int len)`：从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中，从 cbuf[off]开始的位置存储。每次最多读取 len 个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回 -1。 \r\n- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    \r\n\r\n> 注意：当完成流的操作时，必须调用 close() 方法，释放系统资源，否则会造成内存泄漏。\r\n\r\n#### 字符输出流：Writer\r\n\r\n`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。\r\n\r\n- `public void write(int c)` ：写出单个字符。\r\n- `public void write(char[] cbuf) `：写出字符数组。 \r\n- `public void write(char[] cbuf, int off, int len) `：写出字符数组的某一部分。off：数组的开始索引；len：写出的字符个数。 \r\n- `public void write(String str) `：写出字符串。 \r\n- `public void write(String str, int off, int len)` ：写出字符串的某一部分。off：字符串的开始索引；len：写出的字符个数。\r\n- `public void flush() `：刷新该流的缓冲。  \r\n- `public void close()` ：关闭此流。\r\n\r\n> 注意：当完成流的操作时，必须调用 close() 方法，释放系统资源，否则会造成内存泄漏。\r\n\r\n### FileReader 与 FileWriter\r\n\r\n#### FileReader\r\n\r\n`java.io.FileReader `类用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区。\r\n\r\n- `FileReader(File file)`：创建一个新的 FileReader，给定要读取的 File 对象。   \r\n- `FileReader(String fileName)`：创建一个新的 FileReader，给定要读取的文件的名称。  \r\n\r\n**举例：**读取 hello.txt 文件中的字符数据，并显示在控制台上\r\n\r\n```java\r\npublic class FileReaderWriterTest {\r\n    \r\n    //实现方式 1\r\n    @Test\r\n    public void test1() throws IOException {\r\n        //1. 创建 File 类的对象，对应着物理磁盘上的某个文件\r\n        File file = new File(\"hello.txt\");\r\n        //2. 创建 FileReader 流对象，将 File 类的对象作为参数传递到 FileReader 的构造器中\r\n        FileReader fr = new FileReader(file);\r\n        //3. 通过相关流的方法，读取文件中的数据\r\n//        int data = fr.read(); //每调用一次读取一个字符\r\n//        while (data != -1) {\r\n//            System.out.print((char) data);\r\n//            data = fr.read();\r\n//        }\r\n        int data;\r\n        while ((data = fr.read()) != -1) {\r\n            System.out.print((char) data);\r\n        }\r\n\r\n        //4. 关闭相关的流资源，避免出现内存泄漏\r\n        fr.close();\r\n\r\n    }\r\n\r\n    //实现方式 2：在方式 1 的基础上改进，使用 try-catch-finally 处理异常。保证流是可以关闭的\r\n    @Test\r\n    public void test2() {\r\n        FileReader fr = null;\r\n        try {\r\n            //1. 创建 File 类的对象，对应着物理磁盘上的某个文件\r\n            File file = new File(\"hello.txt\");\r\n            //2. 创建 FileReader 流对象，将 File 类的对象作为参数传递到 FileReader 的构造器中\r\n            fr = new FileReader(file);\r\n            //3. 通过相关流的方法，读取文件中的数据\r\n            /*\r\n             * read():每次从对接的文件中读取一个字符。并将此字符返回。\r\n             * 如果返回值为 -1，则表示文件到了末尾，可以不再读取。\r\n             * */\r\n//            int data = fr.read();\r\n//            while(data != -1){\r\n//                System.out.print((char)data);\r\n//                data = fr.read();\r\n//            }\r\n\r\n            int data;\r\n            while ((data = fr.read()) != -1) {\r\n                System.out.println((char) data);\r\n            }\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //4. 关闭相关的流资源，避免出现内存泄漏\r\n            try {\r\n                if (fr != null)\r\n                    fr.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    //实现方式 3：调用 read(char[] cbuf),每次从文件中读取多个字符\r\n    @Test\r\n    public void test3() {\r\n        FileReader fr = null;\r\n        try {\r\n            //1. 创建 File 类的对象，对应着物理磁盘上的某个文件\r\n            File file = new File(\"hello.txt\");\r\n            //2. 创建 FileReader 流对象，将 File 类的对象作为参数传递到 FileReader 的构造器中\r\n            fr = new FileReader(file);\r\n            //3. 通过相关流的方法，读取文件中的数据\r\n            char[] cbuf = new char[5];\r\n            /*\r\n             * read(char[] cbuf) : 每次将文件中的数据读入到 cbuf 数组中，并返回读入到数组中的\r\n             * 字符的个数。\r\n             * */\r\n            int len; //记录每次读入的字符的个数\r\n            while ((len = fr.read(cbuf)) != -1) {\r\n                //处理 char[] 数组即可\r\n                //错误：\r\n//                for(int i = 0;i < cbuf.length;i++){\r\n//                    System.out.print(cbuf[i]);\r\n//                }\r\n                //错误：\r\n//                String str = new String(cbuf);\r\n//                System.out.print(str);\r\n                //正确：\r\n//                for(int i = 0;i < len;i++){\r\n//                    System.out.print(cbuf[i]);\r\n//                }\r\n                //正确：\r\n                String str = new String(cbuf, 0, len);\r\n                System.out.print(str);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //4. 关闭相关的流资源，避免出现内存泄漏\r\n            try {\r\n                if (fr != null)\r\n                    fr.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n不同实现方式的类比：\r\n\r\n![image-20230417082325977](./assets/image-20230417082325977.png)\r\n\r\n#### FileWriter\r\n\r\n`java.io.FileWriter `类用于写出字符到文件，构造时使用系统默认的字符编码和默认字节缓冲区。\r\n\r\n- `FileWriter(File file)`：创建一个新的 FileWriter，给定要读取的 File 对象。   \r\n- `FileWriter(String fileName)`：创建一个新的 FileWriter，给定要读取的文件的名称。  \r\n- `FileWriter(File file,boolean append)`：创建一个新的 FileWriter，指明是否在现有文件末尾追加内容。\r\n\r\n举例：\r\n\r\n```java\r\npublic class FWWrite {\r\n    //注意：应该使用 try-catch-finally 处理异常。这里出于方便阅读代码，使用了 throws 的方式\r\n    @Test\r\n    public void test01()throws IOException {\r\n        // 使用文件名称创建流对象\r\n        FileWriter fw = new FileWriter(new File(\"fw.txt\"));\r\n        // 写出数据\r\n        fw.write(97); // 写出第 1 个字符\r\n        fw.write('b'); // 写出第 2 个字符\r\n        fw.write('C'); // 写出第 3 个字符\r\n        fw.write(30000); // 写出第 4 个字符，中文编码表中 30000 对应一个汉字。\r\n\t\t\r\n        //关闭资源\r\n        fw.close();\r\n    }\r\n\t//注意：应该使用 try-catch-finally 处理异常。这里出于方便阅读代码，使用了 throws 的方式\r\n    @Test\r\n    public void test02()throws IOException {\r\n        // 使用文件名称创建流对象\r\n        FileWriter fw = new FileWriter(new File(\"fw.txt\"));\r\n        // 字符串转换为字节数组\r\n        char[] chars = \"尚硅谷\".toCharArray();\r\n\r\n        // 写出字符数组\r\n        fw.write(chars); // 尚硅谷\r\n\r\n        // 写出从索引 1 开始，2 个字符。\r\n        fw.write(chars,1,2); // 硅谷\r\n\r\n        // 关闭资源\r\n        fw.close();\r\n    }\r\n\t//注意：应该使用 try-catch-finally 处理异常。这里出于方便阅读代码，使用了 throws 的方式\r\n    @Test\r\n    public void test03()throws IOException {\r\n        // 使用文件名称创建流对象\r\n        FileWriter fw = new FileWriter(\"fw.txt\");\r\n        // 字符串\r\n        String msg = \"尚硅谷\";\r\n\r\n        // 写出字符数组\r\n        fw.write(msg); //尚硅谷\r\n\r\n        // 写出从索引 1 开始，2 个字符。\r\n        fw.write(msg,1,2);\t// 硅谷\r\n\r\n        // 关闭资源\r\n        fw.close();\r\n    }\r\n    \r\n    @Test\r\n    public void test04(){\r\n        FileWriter fw = null;\r\n        try {\r\n            //1. 创建 File 的对象\r\n            File file = new File(\"personinfo.txt\");\r\n            //2. 创建 FileWriter 的对象，将 File 对象作为参数传递到 FileWriter 的构造器中\r\n            //如果输出的文件已存在，则会对现有的文件进行覆盖\r\n            fw = new FileWriter(file);\r\n//            fw = new FileWriter(file,false);\r\n            //如果输出的文件已存在，则会在现有的文件末尾写入数据\r\n//            fw = new FileWriter(file,true);\r\n\r\n            //3. 调用相关的方法，实现数据的写出操作\r\n            //write(String str) / write(char[] cbuf)\r\n            fw.write(\"I love you,\");\r\n            fw.write(\"you love him.\");\r\n            fw.write(\"so sad\".toCharArray());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //4. 关闭资源，避免内存泄漏\r\n            try {\r\n                if (fw != null)\r\n                    fw.close();\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 小结\r\n\r\n```\r\n① \r\n因为出现流资源的调用，为了避免内存泄漏，需要使用try-catch-finally处理异常\r\n\r\n② \r\n对于输入流来说，File类的对象必须在物理磁盘上存在，否则执行就会报FileNotFoundException。如果传入的是一个目录，则会报IOException异常。\r\n\r\n对于输出流来说，File类的对象是可以不存在的。\r\n   > 如果File类的对象不存在，则可以在输出的过程中，自动创建File类的对象\r\n   > 如果File类的对象存在，\r\n      > 如果调用FileWriter(File file)或FileWriter(File file,false)，输出时会新建File文件覆盖已有的文件\r\n      > 如果调用FileWriter(File file,true)构造器，则在现有的文件末尾追加写出内容。\r\n```\r\n\r\n### 关于 flush（刷新）\r\n\r\n因为内置缓冲区的原因，如果 FileWriter 不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush()` 方法了。\r\n\r\n- `flush()` ：刷新缓冲区，流对象可以继续使用。\r\n- `close() `：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\r\n\r\n注意：即便是 flush() 方法写出了数据，操作的最后还是要调用 close 方法，释放系统资源。\r\n\r\n举例：\r\n\r\n```java\r\npublic class FWWriteFlush {\r\n    //注意：应该使用 try-catch-finally 处理异常。这里出于方便阅读代码，使用了 throws 的方式\r\n    @Test\r\n    public void test() throws IOException {\r\n        // 使用文件名称创建流对象\r\n        FileWriter fw = new FileWriter(\"fw.txt\");\r\n        // 写出数据，通过 flush\r\n        fw.write('刷'); // 写出第 1 个字符\r\n        fw.flush();\r\n        fw.write('新'); // 继续写出第 2 个字符，写出成功\r\n        fw.flush();\r\n\r\n        // 写出数据，通过 close\r\n        fw.write('关'); // 写出第 1 个字符\r\n        fw.close();\r\n        fw.write('闭'); // 继续写出第 2 个字符，【报错】java.io.IOException: Stream closed\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n## 节点流之二：FileInputStream\\FileOutputStream\r\n\r\n如果我们读取或写出的数据是非文本文件，则 Reader、Writer 就无能为力了，必须使用字节流。\r\n\r\n### InputStream 和 OutputStream\r\n\r\n#### 字节输入流：InputStream\r\n\r\n`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\r\n\r\n- `public int read()`：从输入流读取一个字节。返回读取的字节值。虽然读取了一个字节，但是会自动提升为 int 类型。如果已经到达流末尾，没有数据可读，则返回 -1。 \r\n- `public int read(byte[] b)`：从输入流中读取一些字节数，并将它们存储到字节数组 b 中。每次最多读取 b.length 个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回 -1。 \r\n- `public int read(byte[] b,int off,int len)`：从输入流中读取一些字节数，并将它们存储到字节数组 b 中，从 b[off]开始存储，每次最多读取 len 个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回 -1。 \r\n- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    \r\n\r\n> 说明：close() 方法，当完成流的操作时，必须调用此方法，释放系统资源。\r\n\r\n####  字节输出流：OutputStream\r\n\r\n`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。\r\n\r\n- `public void write(int b)` ：将指定的字节输出流。虽然参数为 int 类型四个字节，但是只会保留一个字节的信息写出。\r\n- `public void write(byte[] b)`：将 b.length 字节从指定的字节数组写入此输出流。  \r\n- `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。  \r\n- `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  \r\n- `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  \r\n\r\n> 说明：close() 方法，当完成流的操作时，必须调用此方法，释放系统资源。\r\n\r\n### FileInputStream 与 FileOutputStream\r\n\r\n#### FileInputStream\r\n\r\n`java.io.FileInputStream `类是文件输入流，从文件中读取字节。\r\n\r\n- `FileInputStream(File file)`：通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的 File 对象 file 命名。 \r\n- `FileInputStream(String name)`：通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的路径名 name 命名。  \r\n\r\n举例：\r\n\r\n```java\r\n//read.txt 文件中的内容如下：\r\nabcde\r\n```\r\n\r\n读取操作\r\n\r\n```java\r\npublic class FISRead {\r\n    //注意：应该使用 try-catch-finally 处理异常。这里出于方便阅读代码，使用了 throws 的方式\r\n    @Test\r\n    public void test() throws IOException {\r\n        // 使用文件名称创建流对象\r\n        FileInputStream fis = new FileInputStream(\"read.txt\");\r\n        // 读取数据，返回一个字节\r\n        int read = fis.read();\r\n        System.out.println((char) read);\r\n        read = fis.read();\r\n        System.out.println((char) read);\r\n        read = fis.read();\r\n        System.out.println((char) read);\r\n        read = fis.read();\r\n        System.out.println((char) read);\r\n        read = fis.read();\r\n        System.out.println((char) read);\r\n        // 读取到末尾，返回 -1\r\n        read = fis.read();\r\n        System.out.println(read);\r\n        // 关闭资源\r\n        fis.close();\r\n        /*\r\n        文件内容：abcde\r\n        输出结果：\r\n        a\r\n        b\r\n        c\r\n        d\r\n        e\r\n        -1\r\n         */\r\n    }\r\n\r\n    @Test\r\n    public void test02()throws IOException{\r\n        // 使用文件名称创建流对象\r\n        FileInputStream fis = new FileInputStream(\"read.txt\");\r\n        // 定义变量，保存数据\r\n        int b;\r\n        // 循环读取\r\n        while ((b = fis.read())!=-1) {\r\n            System.out.println((char)b);\r\n        }\r\n        // 关闭资源\r\n        fis.close();\r\n    }\r\n\t\r\n    @Test\r\n    public void test03()throws IOException{\r\n        // 使用文件名称创建流对象。\r\n        FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为 abcde\r\n        // 定义变量，作为有效个数\r\n        int len;\r\n        // 定义字节数组，作为装字节数据的容器\r\n        byte[] b = new byte[2];\r\n        // 循环读取\r\n        while (( len= fis.read(b))!=-1) {\r\n            // 每次读取后，把数组变成字符串打印\r\n            System.out.println(new String(b));\r\n        }\r\n        // 关闭资源\r\n        fis.close();\r\n        /*\r\n        输出结果：\r\n        ab\r\n        cd\r\n        ed\r\n        最后错误数据`d`，是由于最后一次读取时，只读取一个字节`e`，数组中，\r\n        上次读取的数据没有被完全替换，所以要通过`len`，获取有效的字节\r\n         */\r\n    }\r\n\r\n    @Test\r\n    public void test04()throws IOException{\r\n        // 使用文件名称创建流对象。\r\n        FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为 abcde\r\n        // 定义变量，作为有效个数\r\n        int len;\r\n        // 定义字节数组，作为装字节数据的容器\r\n        byte[] b = new byte[2];\r\n        // 循环读取\r\n        while (( len= fis.read(b))!=-1) {\r\n            // 每次读取后，把数组的有效字节部分，变成字符串打印\r\n            System.out.println(new String(b,0,len));//  len 每次读取的有效字节个数\r\n        }\r\n        // 关闭资源\r\n        fis.close();\r\n        /*\r\n        输出结果：\r\n        ab\r\n        cd\r\n        e\r\n         */\r\n    }\r\n}\r\n```\r\n\r\n#### FileOutputStream\r\n\r\n`java.io.FileOutputStream `类是文件输出流，用于将数据写出到文件。\r\n\r\n- `public FileOutputStream(File file)`：创建文件输出流，写出由指定的 File 对象表示的文件。 \r\n- `public FileOutputStream(String name)`：创建文件输出流，指定的名称为写出文件。\r\n- `public FileOutputStream(File file, boolean append)`：创建文件输出流，指明是否在现有文件末尾追加内容。\r\n\r\n举例：\r\n\r\n```java\r\npublic class FOSWrite {\r\n    //注意：应该使用 try-catch-finally 处理异常。这里出于方便阅读代码，使用了 throws 的方式\r\n    @Test\r\n    public void test01() throws IOException {\r\n        // 使用文件名称创建流对象\r\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");\r\n        // 写出数据\r\n        fos.write(97); // 写出第 1 个字节\r\n        fos.write(98); // 写出第 2 个字节\r\n        fos.write(99); // 写出第 3 个字节\r\n        // 关闭资源\r\n        fos.close();\r\n      /*  输出结果：abc*/\r\n    }\r\n\r\n    @Test\r\n    public void test02()throws IOException {\r\n        // 使用文件名称创建流对象\r\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");\r\n        // 字符串转换为字节数组\r\n        byte[] b = \"abcde\".getBytes();\r\n        // 写出从索引 2 开始，2 个字节。索引 2 是 c，两个字节，也就是 cd。\r\n        fos.write(b,2,2);\r\n        // 关闭资源\r\n        fos.close();\r\n    }\r\n    //这段程序如果多运行几次，每次都会在原来文件末尾追加 abcde\r\n    @Test\r\n    public void test03()throws IOException {\r\n        // 使用文件名称创建流对象\r\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\",true);\r\n        // 字符串转换为字节数组\r\n        byte[] b = \"abcde\".getBytes();\r\n        fos.write(b);\r\n        // 关闭资源\r\n        fos.close();\r\n    }\r\n    \r\n    //使用 FileInputStream\\FileOutputStream，实现对文件的复制\r\n    @Test\r\n    public void test05() {\r\n        FileInputStream fis = null;\r\n        FileOutputStream fos = null;\r\n        try {\r\n            //1. 造文件 - 造流\r\n            //复制图片：成功\r\n//            fis = new FileInputStream(new File(\"pony.jpg\"));\r\n//            fos = new FileOutputStream(new File(\"pony_copy1.jpg\"));\r\n\r\n            //复制文本文件：成功\r\n            fis = new FileInputStream(new File(\"hello.txt\"));\r\n            fos = new FileOutputStream(new File(\"hello1.txt\"));\r\n\r\n            //2. 复制操作（读、写）\r\n            byte[] buffer = new byte[1024];\r\n            int len;//每次读入到 buffer 中字节的个数\r\n            while ((len = fis.read(buffer)) != -1) {\r\n                fos.write(buffer, 0, len);\r\n//                String str = new String(buffer,0,len);\r\n//                System.out.print(str);\r\n            }\r\n            System.out.println(\"复制成功\");\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        } finally {\r\n            //3. 关闭资源\r\n            try {\r\n                if (fos != null)\r\n                    fos.close();\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n            try {\r\n                if (fis != null)\r\n                    fis.close();\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 练习\r\n\r\n**练习：**实现图片加密操作。\r\n\r\n提示：\r\n\r\n![image-20230417082447096](./assets/image-20230417082447096.png)\r\n\r\n```java\r\npublic class FileSecretTest {\r\n    /*\r\n    * 图片的加密\r\n    * */\r\n    @Test\r\n    public void test1(){\r\n        FileInputStream fis = null;\r\n        FileOutputStream fos = null;\r\n        try {\r\n            File file1 = new File(\"pony.jpg\");\r\n            File file2 = new File(\"pony_secret.jpg\");\r\n            fis = new FileInputStream(file1);\r\n            fos = new FileOutputStream(file2);\r\n\r\n            //方式 1：每次读入一个字节，效率低\r\n//            int data;\r\n//            while((data = fis.read()) != -1){\r\n//                fos.write(data ^ 5);\r\n//            }\r\n            //方式 2：每次读入一个字节数组，效率高\r\n            int len;\r\n            byte[] buffer = new byte[1024];\r\n            while((len = fis.read(buffer)) != -1){\r\n\r\n                for(int i = 0;i < len;i++){\r\n                    buffer[i] = (byte) (buffer[i] ^ 5);\r\n                }\r\n\r\n                fos.write(buffer,0,len);\r\n\r\n            }\r\n\r\n\r\n            System.out.println(\"加密成功\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n\r\n            try {\r\n                fos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            try {\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * 图片的解密\r\n     * */\r\n    @Test\r\n    public void test2(){\r\n        FileInputStream fis = null;\r\n        FileOutputStream fos = null;\r\n        try {\r\n            File file1 = new File(\"pony_secret.jpg\");\r\n            File file2 = new File(\"pony_unsecret.jpg\");\r\n            fis = new FileInputStream(file1);\r\n            fos = new FileOutputStream(file2);\r\n\r\n            //方式 1：每次读入一个字节，效率低\r\n//            int data;\r\n//            while((data = fis.read()) != -1){\r\n//                fos.write(data ^ 5);\r\n//            }\r\n            //方式 2：每次读入一个字节数组，效率高\r\n            int len;\r\n            byte[] buffer = new byte[1024];\r\n            while((len = fis.read(buffer)) != -1){\r\n\r\n                for(int i = 0;i < len;i++){\r\n                    buffer[i] = (byte) (buffer[i] ^ 5);\r\n                }\r\n\r\n                fos.write(buffer,0,len);\r\n\r\n            }\r\n\r\n            System.out.println(\"解密成功\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n\r\n            try {\r\n                fos.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            try {\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 处理流之一：缓冲流\r\n\r\n- `为了提高数据读写的速度`，Java API 提供了带缓冲功能的流类：缓冲流。\r\n\r\n- 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：\r\n  - **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` \r\n  - **字符缓冲流**：`BufferedReader`，`BufferedWriter`\r\n\r\n- 缓冲流的基本原理：在创建流对象时，内部会创建一个缓冲区数组（缺省使用`8192个字节(8Kb)`的缓冲区），通过缓冲区读写，减少系统 IO 次数，从而提高读写的效率。\r\n\r\n\r\n![image-20230417082556044](./assets/image-20230417082556044.png)\r\n\r\n![image-20230417082558890](./assets/image-20230417082558890.png)\r\n\r\n### 构造器\r\n\r\n* `public BufferedInputStream(InputStream in)` ：创建一个 新的字节型的缓冲输入流。 \r\n* `public BufferedOutputStream(OutputStream out)`：创建一个新的字节型的缓冲输出流。\r\n\r\n代码举例：\r\n\r\n```java\r\n// 创建字节缓冲输入流\r\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"abc.jpg\"));\r\n// 创建字节缓冲输出流\r\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"abc_copy.jpg\"));\r\n```\r\n\r\n* `public BufferedReader(Reader in)` ：创建一个 新的字符型的缓冲输入流。 \r\n* `public BufferedWriter(Writer out)`：创建一个新的字符型的缓冲输出流。\r\n\r\n代码举例：\r\n\r\n```java\r\n// 创建字符缓冲输入流\r\nBufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));\r\n// 创建字符缓冲输出流\r\nBufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\"));\r\n```\r\n\r\n### 效率测试\r\n\r\n查询 API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。\r\n\r\n```java\r\n//方法 1：使用 FileInputStream\\FileOutputStream 实现非文本文件的复制\r\npublic void copyFileWithFileStream(String srcPath,String destPath){\r\n    FileInputStream fis = null;\r\n    FileOutputStream fos = null;\r\n    try {\r\n        //1. 造文件 - 造流\r\n        fis = new FileInputStream(new File(srcPath));\r\n        fos = new FileOutputStream(new File(destPath));\r\n\r\n        //2. 复制操作（读、写）\r\n        byte[] buffer = new byte[100];\r\n        int len;//每次读入到 buffer 中字节的个数\r\n        while ((len = fis.read(buffer)) != -1) {\r\n            fos.write(buffer, 0, len);\r\n        }\r\n        System.out.println(\"复制成功\");\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    } finally {\r\n        //3. 关闭资源\r\n        try {\r\n            if (fos != null)\r\n                fos.close();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        try {\r\n            if (fis != null)\r\n                fis.close();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}\r\n\r\n@Test\r\npublic void test1(){\r\n    String srcPath = \"C:\\\\Users\\\\shkstart\\\\Desktop\\\\01-复习.mp4\";\r\n    String destPath = \"C:\\\\Users\\\\shkstart\\\\Desktop\\\\01-复习 2.mp4\";\r\n\r\n    long start = System.currentTimeMillis();\r\n\r\n    copyFileWithFileStream(srcPath,destPath);\r\n\r\n    long end = System.currentTimeMillis();\r\n\r\n    System.out.println(\"花费的时间为：\" + (end - start));//7677 毫秒\r\n\r\n}\r\n\r\n//方法 2：使用 BufferedInputStream\\BufferedOuputStream 实现非文本文件的复制\r\npublic void copyFileWithBufferedStream(String srcPath,String destPath){\r\n    FileInputStream fis = null;\r\n    FileOutputStream fos = null;\r\n    BufferedInputStream bis = null;\r\n    BufferedOutputStream bos = null;\r\n    try {\r\n        //1. 造文件\r\n        File srcFile = new File(srcPath);\r\n        File destFile = new File(destPath);\r\n        //2. 造流\r\n        fis = new FileInputStream(srcFile);\r\n        fos = new FileOutputStream(destFile);\r\n\r\n        bis = new BufferedInputStream(fis);\r\n        bos = new BufferedOutputStream(fos);\r\n\r\n        //3. 读写操作\r\n        int len;\r\n        byte[] buffer = new byte[100];\r\n        while ((len = bis.read(buffer)) != -1) {\r\n            bos.write(buffer, 0, len);\r\n        }\r\n        System.out.println(\"复制成功\");\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        //4. 关闭资源 (如果有多个流，我们需要先关闭外面的流，再关闭内部的流)\r\n        try {\r\n            if (bos != null)\r\n                bos.close();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        try {\r\n            if (bis != null)\r\n                bis.close();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n\r\n    }\r\n}\r\n@Test\r\npublic void test2(){\r\n    String srcPath = \"C:\\\\Users\\\\shkstart\\\\Desktop\\\\01-复习.mp4\";\r\n    String destPath = \"C:\\\\Users\\\\shkstart\\\\Desktop\\\\01-复习 2.mp4\";\r\n\r\n    long start = System.currentTimeMillis();\r\n\r\n    copyFileWithBufferedStream(srcPath,destPath);\r\n\r\n    long end = System.currentTimeMillis();\r\n\r\n    System.out.println(\"花费的时间为：\" + (end - start));//415 毫秒\r\n\r\n}\r\n```\r\n\r\n### 字符缓冲流特有方法\r\n\r\n字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\r\n\r\n* BufferedReader：`public String readLine()`: 读一行文字。 \r\n* BufferedWriter：`public void newLine()`: 写一行行分隔符，由系统属性定义符号。 \r\n\r\n```java\r\npublic class BufferedIOLine {\r\n    @Test\r\n    public void testReadLine()throws IOException {\r\n        // 创建流对象\r\n        BufferedReader br = new BufferedReader(new FileReader(\"in.txt\"));\r\n        // 定义字符串，保存读取的一行文字\r\n        String line;\r\n        // 循环读取，读取到最后返回 null\r\n        while ((line = br.readLine())!=null) {\r\n            System.out.println(line);\r\n        }\r\n        // 释放资源\r\n        br.close();\r\n    }\r\n\r\n    @Test\r\n    public void testNewLine()throws IOException{\r\n        // 创建流对象\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\"));\r\n        // 写出数据\r\n        bw.write(\"尚\");\r\n        // 写出换行\r\n        bw.newLine();\r\n        bw.write(\"硅\");\r\n        bw.newLine();\r\n        bw.write(\"谷\");\r\n        bw.newLine();\r\n        // 释放资源\r\n        bw.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n> 说明：\r\n>\r\n> 1. 涉及到嵌套的多个流时，如果都显式关闭的话，需要先关闭外层的流，再关闭内层的流\r\n>\r\n> 2. 其实在开发中，只需要关闭最外层的流即可，因为在关闭外层流时，内层的流也会被关闭。\r\n\r\n### 练习\r\n\r\n**练习 1：**分别使用节点流：FileInputStream、FileOutputStream 和缓冲流：BufferedInputStream、BufferedOutputStream 实现文本文件/图片/视频文件的复制。并比较二者在数据复制方面的效率。\r\n\r\n**练习 2：**\r\n\r\n姓氏统计：一个文本文件中存储着北京所有高校在校生的姓名，格式如下：\r\n\r\n```\r\n每行一个名字，姓与名以空格分隔：\r\n张 三\r\n李 四\r\n王 小五\r\n```\r\n\r\n现在想统计所有的姓氏在文件中出现的次数，请描述一下你的解决方案。\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    HashMap<String, Integer> map = new HashMap<>();\r\n    BufferedReader br = null;\r\n    try {\r\n        br = new BufferedReader(new FileReader(new File(\"e:/name.txt\")));\r\n        String value = null; // 临时接收文件中的字符串变量\r\n        StringBuffer buffer = new StringBuffer();\r\n        flag:\r\n        while ((value = br.readLine()) != null) { // 开始读取文件中的字符\r\n            char[] c = value.toCharArray();\r\n            for (int i = 0; i < c.length; i++) {\r\n                if (c[i] != ' ') {\r\n                    buffer.append(String.valueOf(c[i]));\r\n                } else {\r\n                    if (map.containsKey(buffer.toString())) {\r\n                        int count = map.get(buffer.toString());\r\n                        map.put(buffer.toString(), count + 1);\r\n                    } else {\r\n                        map.put(buffer.toString(), 1);\r\n                    }\r\n                    buffer.delete(0, buffer.length());\r\n                    continue flag;\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (br != null) {\r\n            try {\r\n                br.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    Set<Map.Entry<String, Integer>> set = map.entrySet();\r\n    Iterator<Map.Entry<String, Integer>> it = set.iterator();\r\n    while (it.hasNext()) {\r\n        Map.Entry<String, Integer> end = (Map.Entry<String, Integer>) it.next();\r\n        System.out.println(end);\r\n    }\r\n}\r\n```\r\n\r\n## 处理流之二：转换流\r\n\r\n### 问题引入\r\n\r\n**引入情况 1：**\r\n\r\n使用`FileReader` 读取项目中的文本文件。由于 IDEA 设置中针对项目设置了 UTF-8 编码，当读取 Windows 系统中创建的文本文件时，如果 Windows 系统默认的是 GBK 编码，则读入内存中会出现乱码。\r\n\r\n```java\r\npublic class Problem {\r\n    public static void main(String[] args) throws IOException {\r\n        FileReader fileReader = new FileReader(\"E:\\\\File_GBK.txt\");\r\n        int data;\r\n        while ((data = fileReader.read()) != -1) {\r\n            System.out.print((char)data);\r\n        }\r\n        fileReader.close();\r\n    }\r\n}\r\n\r\n输出结果：\r\n���\r\n```\r\n\r\n那么如何读取 GBK 编码的文件呢？ \r\n\r\n**引入情况 2：**\r\n\r\n针对文本文件，现在使用一个字节流进行数据的读入，希望将数据显示在控制台上。此时针对包含中文的文本数据，可能会出现乱码。\r\n\r\n### 转换流的理解\r\n\r\n**作用：转换流是字节与字符间的桥梁！**\r\n\r\n![image-20230417082707652](./assets/image-20230417082707652.png)\r\n\r\n具体来说：\r\n\r\n![image-20230417082711356](./assets/image-20230417082711356.png)\r\n\r\n### InputStreamReader 与 OutputStreamWriter\r\n\r\n- **InputStreamReader** \r\n\r\n  - 转换流`java.io.InputStreamReader`，是 Reader 的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \r\n\r\n  - 构造器\r\n\r\n    - `InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 \r\n    - `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。\r\n\r\n  - 举例\r\n\r\n    ```java\r\n    //使用默认字符集\r\n    InputStreamReader isr1 = new InputStreamReader(new FileInputStream(\"in.txt\"));\r\n    //使用指定字符集\r\n    InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\r\n    ```\r\n\r\n  - 示例代码：\r\n\r\n    ```java\r\n    public class InputStreamReaderDemo {\r\n        public static void main(String[] args) throws IOException {\r\n            // 定义文件路径，文件为 gbk 编码\r\n            String fileName = \"E:\\\\file_gbk.txt\";\r\n            //方式 1：\r\n            // 创建流对象，默认 UTF8 编码\r\n            InputStreamReader isr1 = new InputStreamReader(new FileInputStream(fileName));\r\n            // 定义变量，保存字符\r\n            int charData;\r\n            // 使用默认编码字符流读取，乱码\r\n            while ((charData = isr1.read()) != -1) {\r\n                System.out.print((char)charData); // ��Һ�\r\n            }\r\n            isr1.close();\r\n    \t\t\r\n            //方式 2：\r\n            // 创建流对象，指定 GBK 编码\r\n            InputStreamReader isr2 = new InputStreamReader(new FileInputStream(fileName) , \"GBK\");\r\n            // 使用指定编码字符流读取，正常解析\r\n            while ((charData = isr2.read()) != -1) {\r\n                System.out.print((char)charData);// 大家好\r\n            }\r\n            isr2.close();\r\n        }\r\n    }\r\n    ```\r\n  \r\n- **OutputStreamWriter**\r\n\r\n  - 转换流`java.io.OutputStreamWriter` ，是 Writer 的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \r\n\r\n  - 构造器\r\n\r\n    - `OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 \r\n    - `OutputStreamWriter(OutputStream in,String charsetName)`: 创建一个指定字符集的字符流。\r\n\r\n  - 举例：\r\n\r\n    ```java\r\n    //使用默认字符集\r\n    OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));\r\n    //使用指定的字符集\r\n    OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\");\r\n    ```\r\n\r\n  - 示例代码：\r\n\r\n    ```java\r\n    public class OutputStreamWriterDemo {\r\n        public static void main(String[] args) throws IOException {\r\n            // 定义文件路径\r\n            String FileName = \"E:\\\\out_utf8.txt\";\r\n            // 创建流对象，默认 UTF8 编码\r\n            OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\r\n            // 写出数据\r\n            osw.write(\"你好\"); // 保存为 6 个字节\r\n            osw.close();\r\n    \r\n            // 定义文件路径\r\n            String FileName2 = \"E:\\\\out_gbk.txt\";\r\n            // 创建流对象，指定 GBK 编码\r\n            OutputStreamWriter osw2 = new OutputStreamWriter(new                     \r\n                                                    FileOutputStream(FileName2),\"GBK\");\r\n            // 写出数据\r\n            osw2.write(\"你好\");// 保存为 4 个字节\r\n            osw2.close();\r\n        }\r\n    }\r\n    ```\r\n\r\n### 字符编码和字符集\r\n\r\n#### 编码与解码\r\n\r\n计算机中储存的信息都是用`二进制数`表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为**编码** 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为**解码** 。\r\n\r\n**字符编码（Character Encoding）** : 就是一套自然语言的字符与二进制数之间的对应规则。\r\n\r\n**编码表**：生活中文字和计算机中二进制的对应规则\r\n\r\n**乱码的情况**：按照 A 规则存储，同样按照 A 规则解析，那么就能显示正确的文本符号。反之，按照 A 规则存储，再按照 B 规则解析，就会导致乱码现象。\r\n\r\n```\r\n编码:字符(人能看懂的)--字节(人看不懂的)\r\n\r\n解码:字节(人看不懂的)-->字符(人能看懂的)\r\n```\r\n\r\n#### 字符集\r\n\r\n* **字符集 Charset**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\r\n\r\n- 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有 ASCII 字符集、GBK 字符集、Unicode 字符集等。\r\n\r\n\r\n可见，当指定了**编码**，它所对应的**字符集**自然就指定了，所以**编码**才是我们最终要关心的。\r\n\r\n* **ASCII 字符集** ：\r\n\r\n  * ASCII 码（American Standard Code for Information Interchange，美国信息交换标准代码）：上个世纪 60 年代，美国制定了一套字符编码，对`英语字符`与二进制位之间的关系，做了统一规定。这被称为 ASCII 码。\r\n  * ASCII 码用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\r\n  * 基本的 ASCII 字符集，使用 7 位（bits）表示一个字符（最前面的 1 位统一规定为 0），共`128个`字符。比如：空格“SPACE”是 32（二进制 00100000），大写的字母 A 是 65（二进制 01000001）。\r\n  * 缺点：不能表示所有字符。\r\n\r\n* **ISO-8859-1 字符集**：\r\n\r\n  * 拉丁码表，别名 Latin-1，用于显示欧洲使用的语言，包括荷兰语、德语、意大利语、葡萄牙语等\r\n  * ISO-8859-1 使用单字节编码，兼容 ASCII 编码。\r\n\r\n* **GBxxx 字符集**：\r\n\r\n  * GB 就是国标的意思，是为了`显示中文`而设计的一套字符集。\r\n  * **GB2312**：简体中文码表。一个小于 127 的字符的意义与原来相同，即向下兼容 ASCII 码。但两个大于 127 的字符连在一起时，就表示一个汉字，这样大约可以组合了包含`7000多个简体汉字`，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，这就是常说的\"全角\"字符，而原来在 127 号以下的那些符号就叫\"半角\"字符了。\r\n  * **GBK**：最常用的中文码表。是在 GB2312 标准基础上的扩展规范，使用了`双字节`编码方案，共收录了`21003个`汉字，完全兼容 GB2312 标准，同时支持`繁体汉字`以及日韩汉字等。\r\n  * **GB18030**：最新的中文码表。收录汉字`70244个`，采用`多字节`编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\r\n\r\n* **Unicode 字符集** ：\r\n\r\n  * Unicode 编码为表达`任意语言的任意字符`而设计，也称为统一码、标准万国码。Unicode 将世界上所有的文字用`2个字节`统一进行编码，为每个字符设定唯一的二进制编码，以满足跨语言、跨平台进行文本处理的要求。\r\n\r\n  - Unicode 的缺点：这里有三个问题：\r\n    - 第一，英文字母只用一个字节表示就够了，如果用更多的字节存储是`极大的浪费`。\r\n    - 第二，如何才能`区别Unicode和ASCII`？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？\r\n    - 第三，如果和 GBK 等双字节编码方式一样，用最高位是 1 或 0 表示两个字节和一个字节，就少了很多值无法用于表示字符，`不够表示所有字符`。\r\n  - Unicode 在很长一段时间内无法推广，直到互联网的出现，为解决 Unicode 如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现。具体来说，有三种编码方案，UTF-8、UTF-16 和 UTF-32。\r\n\r\n* **UTF-8 字符集**：\r\n\r\n  * Unicode 是字符集，UTF-8、UTF-16、UTF-32 是三种`将数字转换到程序数据`的编码方案。顾名思义，UTF-8 就是每次 8 个位传输数据，而 UTF-16 就是每次 16 个位。其中，UTF-8 是在互联网上`使用最广`的一种 Unicode 的实现方式。\r\n  * 互联网工程工作小组（IETF）要求所有互联网协议都必须支持 UTF-8 编码。所以，我们开发 Web 应用，也要使用 UTF-8 编码。UTF-8 是一种`变长的编码方式`。它使用 1-4 个字节为每个字符编码，编码规则：\r\n    1. 128 个 US-ASCII 字符，只需一个字节编码。\r\n    2. 拉丁文等字符，需要二个字节编码。 \r\n    3. 大部分常用字（含中文），使用三个字节编码。\r\n    4. 其他极少使用的 Unicode 辅助字符，使用四字节编码。\r\n\r\n- 举例\r\n\r\nUnicode 符号范围  | UTF-8 编码方式\r\n\r\n```\r\n(十六进制)           | （二进制）\r\n\r\n————————————————————|—–—–—–—–—–—–—–—–—–—–—–—–—–—–\r\n\r\n0000 0000-0000 007F | 0xxxxxxx（兼容原来的ASCII）\r\n\r\n0000 0080-0000 07FF | 110xxxxx 10xxxxxx\r\n\r\n0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\r\n\r\n0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n```\r\n\r\n![image-20230417082918439](./assets/image-20230417082918439.png)\r\n\r\n- 小结\r\n\r\n![image-20230417082921670](./assets/image-20230417082921670.png)\r\n\r\n> 注意：在中文操作系统上，ANSI（美国国家标准学会、AMERICAN NATIONAL STANDARDS INSTITUTE: ANSI）编码即为 GBK；在英文操作系统上，ANSI 编码即为 ISO-8859-1。\r\n\r\n### 练习\r\n\r\n把当前 module 下的《康师傅的话.txt》字符编码为 GBK，复制到电脑桌面目录下的《寄语.txt》，\r\n字符编码为 UTF-8。\r\n\r\n在当前 module 下的文本内容：\r\n\r\n```\r\n六项精进：\r\n（一）付出不亚于任何人的努力\r\n（二）要谦虚，不要骄傲\r\n（三）要每天反省\r\n（四）活着，就要感谢\r\n（五）积善行、思利他\r\n（六）不要有感性的烦恼\r\n```\r\n\r\n代码：\r\n\r\n```java\r\npublic class InputStreamReaderDemo {\r\n\r\n    @Test\r\n    public void test() {\r\n        InputStreamReader isr = null;\r\n        OutputStreamWriter osw = null;\r\n        try {\r\n            isr = new InputStreamReader(new FileInputStream(\"康师傅的话.txt\"),\"gbk\");\r\n\r\n            osw = new OutputStreamWriter(new FileOutputStream(\"C:\\\\Users\\\\shkstart\\\\Desktop\\\\寄语.txt\"),\"utf-8\");\r\n\r\n            char[] cbuf = new char[1024];\r\n            int len;\r\n            while ((len = isr.read(cbuf)) != -1) {\r\n                osw.write(cbuf, 0, len);\r\n                osw.flush();\r\n            }\r\n            System.out.println(\"文件复制完成\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                if (isr != null)\r\n                    isr.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            try {\r\n                if (osw != null)\r\n                    osw.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 处理流之三/四：数据流、对象流\r\n\r\n### 数据流与对象流说明\r\n\r\n如果需要将内存中定义的变量（包括基本数据类型或引用数据类型）保存在文件中，那怎么办呢？\r\n\r\n```java\r\nint age = 300;\r\nchar gender = '男';\r\nint energy = 5000;\r\ndouble price = 75.5;\r\nboolean relive = true;\r\n\r\nString name = \"巫师\";\r\nStudent stu = new Student(\"张三\",23,89);\r\n```\r\n\r\nJava 提供了数据流和对象流来处理这些类型的数据：\r\n\r\n- **数据流：DataOutputStream、DataInputStream**\r\n  - DataOutputStream：允许应用程序将基本数据类型、String 类型的变量写入输出流中\r\n\r\n  - DataInputStream：允许应用程序以与机器无关的方式从底层输入流中读取基本数据类型、String 类型的变量。\r\n- 对象流 DataInputStream 中的方法：\r\n\r\n```java\r\n  byte readByte()                short readShort()\r\n  int readInt()                  long readLong()\r\n  float readFloat()              double readDouble()\r\n  char readChar()\t\t\t\t boolean readBoolean()\t\t\t\t\t\r\n  String readUTF()               void readFully(byte[] b)\r\n```\r\n\r\n- 对象流 DataOutputStream 中的方法：将上述的方法的 read 改为相应的 write 即可。\r\n- 数据流的弊端：只支持 Java 基本数据类型和字符串的读写，而不支持其它 Java 对象的类型。而 ObjectOutputStream 和 ObjectInputStream 既支持 Java 基本数据类型的数据读写，又支持 Java 对象的读写，所以重点介绍对象流 ObjectOutputStream 和 ObjectInputStream。\r\n- **对象流：ObjectOutputStream、ObjectInputStream**\r\n\r\n  - ObjectOutputStream：将 Java 基本数据类型和对象写入字节输出流中。通过在流中使用文件可以实现 Java 各种基本数据类型的数据以及对象的持久存储。\r\n  - ObjectInputStream：ObjectInputStream 对以前使用 ObjectOutputStream 写出的基本数据类型的数据和对象进行读入操作，保存在内存中。\r\n\r\n> 说明：对象流的强大之处就是可以把 Java 中的对象写入到数据源中，也能把对象从数据源中还原回来。\r\n\r\n### 对象流 API\r\n\r\n**ObjectOutputStream 中的构造器：**\r\n\r\n`public ObjectOutputStream(OutputStream out) `：创建一个指定的 ObjectOutputStream。\r\n\r\n```java\r\nFileOutputStream fos = new FileOutputStream(\"game.dat\");\r\nObjectOutputStream oos = new ObjectOutputStream(fos);\r\n```\r\n\r\n**ObjectOutputStream 中的方法：**\r\n\r\n- public void writeBoolean(boolean val)：写出一个 boolean 值。\r\n- public void writeByte(int val)：写出一个 8 位字节\r\n- public void writeShort(int val)：写出一个 16 位的 short 值\r\n- public void writeChar(int val)：写出一个 16 位的 char 值\r\n- public void writeInt(int val)：写出一个 32 位的 int 值\r\n- public void writeLong(long val)：写出一个 64 位的 long 值\r\n- public void writeFloat(float val)：写出一个 32 位的 float 值。\r\n- public void writeDouble(double val)：写出一个 64 位的 double 值\r\n- public void writeUTF(String str)：将表示长度信息的两个字节写入输出流，后跟字符串 s 中每个字符的 UTF-8 修改版表示形式。根据字符的值，将字符串 s 中每个字符转换成一个字节、两个字节或三个字节的字节组。注意，将 String 作为基本数据写入流中与将它作为 Object 写入流中明显不同。如果 s 为 null，则抛出 NullPointerException。\r\n- `public void writeObject(Object obj)`：写出一个 obj 对象\r\n- public void close() ：关闭此输出流并释放与此流相关联的任何系统资源\r\n\r\n**ObjectInputStream 中的构造器：**\r\n\r\n`public ObjectInputStream(InputStream in) `：创建一个指定的 ObjectInputStream。\r\n\r\n```java\r\nFileInputStream fis = new FileInputStream(\"game.dat\");\r\nObjectInputStream ois = new ObjectInputStream(fis);\r\n```\r\n\r\n**ObjectInputStream 中的方法：**\r\n\r\n- public boolean readBoolean()：读取一个 boolean 值\r\n- public byte readByte()：读取一个 8 位的字节\r\n- public short readShort()：读取一个 16 位的 short 值\r\n- public char readChar()：读取一个 16 位的 char 值\r\n- public int readInt()：读取一个 32 位的 int 值\r\n- public long readLong()：读取一个 64 位的 long 值\r\n- public float readFloat()：读取一个 32 位的 float 值\r\n- public double readDouble()：读取一个 64 位的 double 值\r\n- public String readUTF()：读取 UTF-8 修改版格式的 String\r\n- `public void readObject(Object obj)`：读入一个 obj 对象\r\n- public void close() ：关闭此输入流并释放与此流相关联的任何系统资源\r\n\r\n### 认识对象序列化机制\r\n\r\n**1、何为对象序列化机制？**\r\n\r\n`对象序列化机制`允许把内存中的 Java 对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。\r\n\r\n- 序列化过程：用一个字节序列可以表示一个对象，该字节序列包含该`对象的类型`和`对象中存储的属性`等信息。字节序列写出到文件之后，相当于文件中`持久保存`了一个对象的信息。 \r\n\r\n\r\n- 反序列化过程：该字节序列还可以从文件中读取回来，重构对象，对它进行`反序列化`。`对象的数据`、`对象的类型`和`对象中存储的数据`信息，都可以用来在内存中创建对象。\r\n\r\n![image-20230417083027669](./assets/image-20230417083027669.png)\r\n\r\n**2、序列化机制的重要性**\r\n\r\n序列化是 RMI（Remote Method Invoke、远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础。\r\n\r\n序列化的好处，在于可将任何实现了 Serializable 接口的对象转化为**字节数据**，使其在保存和传输时可被还原。\r\n\r\n**3、实现原理**\r\n\r\n- 序列化：用 ObjectOutputStream 类保存基本类型数据或对象的机制。方法为：\r\n  - `public final void writeObject (Object obj)` : 将指定的对象写出。\r\n\r\n- 反序列化：用 ObjectInputStream 类读取基本类型数据或对象的机制。方法为：\r\n  - `public final Object readObject ()` : 读取一个对象。\r\n\r\n![image-20230417083033801](./assets/image-20230417083033801.png)\r\n\r\n### 如何实现序列化机制\r\n\r\n如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现`java.io.Serializable ` 接口。`Serializable` 是一个`标记接口`，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出`NotSerializableException` 。\r\n\r\n* 如果对象的某个属性也是引用数据类型，那么如果该属性也要序列化的话，也要实现`Serializable` 接口\r\n* 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用`transient` 关键字修饰。\r\n* `静态（static）变量`的值不会序列化。因为静态变量的值不属于某个对象。\r\n\r\n举例 1：\r\n\r\n```java\r\npublic class ReadWriteDataOfAnyType {\r\n    @Test\r\n    public void save() throws IOException {\r\n        String name = \"巫师\";\r\n        int age = 300;\r\n        char gender = '男';\r\n        int energy = 5000;\r\n        double price = 75.5;\r\n        boolean relive = true;\r\n\r\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"game.dat\"));\r\n        oos.writeUTF(name);\r\n        oos.writeInt(age);\r\n        oos.writeChar(gender);\r\n        oos.writeInt(energy);\r\n        oos.writeDouble(price);\r\n        oos.writeBoolean(relive);\r\n        oos.close();\r\n    }\r\n    @Test\r\n    public void reload()throws IOException{\r\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"game.dat\"));\r\n        String name = ois.readUTF();\r\n        int age = ois.readInt();\r\n        char gender = ois.readChar();\r\n        int energy = ois.readInt();\r\n        double price = ois.readDouble();\r\n        boolean relive = ois.readBoolean();\r\n\r\n        System.out.println(name+\",\" + age + \",\" + gender + \",\" + energy + \",\" + price + \",\" + relive);\r\n\r\n        ois.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n举例 2：\r\n\r\n```java\r\npublic class Employee implements Serializable {\r\n    //static final long serialVersionUID = 23234234234L;\r\n    public static String company; //static 修饰的类变量，不会被序列化\r\n    public String name;\r\n    public String address;\r\n    public transient int age; // transient 瞬态修饰成员，不会被序列化\r\n\r\n    public Employee(String name, String address, int age) {\r\n        this.name = name;\r\n        this.address = address;\r\n        this.age = age;\r\n    }\r\n\r\n    public static String getCompany() {\r\n        return company;\r\n    }\r\n\r\n    public static void setCompany(String company) {\r\n        Employee.company = company;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Employee{\" +\r\n                \"name='\" + name + '\\'' +\r\n                \", address='\" + address + '\\'' +\r\n                \", age=\" + age +\r\n                \", company=\" + company +\r\n                '}';\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npublic class ReadWriteObject {\r\n    @Test\r\n    public void save() throws IOException {\r\n        Employee.setCompany(\"尚硅谷\");\r\n        Employee e = new Employee(\"小谷姐姐\", \"宏福苑\", 23);\r\n        // 创建序列化流对象\r\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"employee.dat\"));\r\n        // 写出对象\r\n        oos.writeObject(e);\r\n        // 释放资源\r\n        oos.close();\r\n        System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。\r\n    }\r\n\r\n    @Test\r\n    public void reload() throws IOException, ClassNotFoundException {\r\n        // 创建反序列化流\r\n        FileInputStream fis = new FileInputStream(\"employee.dat\");\r\n        ObjectInputStream ois = new ObjectInputStream(fis);\r\n        // 读取一个对象\r\n        Employee e = (Employee) ois.readObject();\r\n        // 释放资源\r\n        ois.close();\r\n        fis.close();\r\n\r\n        System.out.println(e);\r\n    }\r\n}\r\n```\r\n\r\n举例 3：如果有多个对象需要序列化，则可以将对象放到集合中，再序列化集合对象即可。\r\n\r\n```java\r\npublic class ReadWriteCollection {\r\n    @Test\r\n    public void save() throws IOException {\r\n        ArrayList<Employee> list = new ArrayList<>();\r\n        list.add(new Employee(\"张三\", \"宏福苑\", 23));\r\n        list.add(new Employee(\"李四\", \"白庙\", 24));\r\n        list.add(new Employee(\"王五\", \"平西府\", 25));\r\n        // 创建序列化流对象\r\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"employees.dat\"));\r\n        // 写出对象\r\n        oos.writeObject(list);\r\n        // 释放资源\r\n        oos.close();\r\n    }\r\n\r\n    @Test\r\n    public void reload() throws IOException, ClassNotFoundException {\r\n        // 创建反序列化流\r\n        FileInputStream fis = new FileInputStream(\"employees.dat\");\r\n        ObjectInputStream ois = new ObjectInputStream(fis);\r\n        // 读取一个对象\r\n        ArrayList<Employee> list = (ArrayList<Employee>) ois.readObject();\r\n        // 释放资源\r\n        ois.close();\r\n        fis.close();\r\n\r\n        System.out.println(list);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 反序列化失败问题\r\n\r\n**问题 1：**\r\n\r\n对于 JVM 可以反序列化对象，它必须是能够找到 class 文件的类。如果找不到该类的 class 文件，则抛出一个 `ClassNotFoundException` 异常。  \r\n\r\n**问题 2：**\r\n\r\n当 JVM 反序列化对象时，能找到 class 文件，但是 class 文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个`InvalidClassException`异常。发生这个异常的原因如下：\r\n\r\n* 该类的序列版本号与从流中读取的类描述符的版本号不匹配 \r\n* 该类包含未知数据类型  \r\n\r\n解决办法：\r\n\r\n`Serializable` 接口给需要序列化的类，提供了一个序列版本号：`serialVersionUID` 。凡是实现 Serializable 接口的类都应该有一个表示序列化版本标识符的静态变量：\r\n\r\n```java\r\nstatic final long serialVersionUID = 234242343243L; //它的值由程序员随意指定即可。\r\n```\r\n\r\n- serialVersionUID 用来表明类的不同版本间的兼容性。简单来说，Java 的序列化机制是通过在运行时判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常 (InvalidCastException)。\r\n- 如果类没有显示定义这个静态常量，它的值是 Java 运行时环境根据类的内部细节`自动生成`的。若类的实例变量做了修改，serialVersionUID `可能发生变化`。因此，建议显式声明。\r\n- 如果声明了 serialVersionUID，即使在序列化完成之后修改了类导致类重新编译，则原来的数据也能正常反序列化，只是新增的字段值是默认值而已。\r\n\r\n```java\r\npublic class Employee implements Serializable {\r\n    private static final long serialVersionUID = 1324234L; //增加 serialVersionUID\r\n    \r\n    //其它结构：略\r\n}\r\n```\r\n\r\n### 面试题&练习\r\n\r\n面试题：谈谈你对 java.io.Serializable 接口的理解，我们知道它用于序列化，是空方法接口，还有其它认识吗？\r\n\r\n```java\r\n实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。\r\n    \r\n由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。\r\n\r\n```\r\n\r\n练习：\r\n\r\n- 需求说明：\r\n  - 网上购物时某用户填写订单，订单内容为产品列表，保存在“save.bin”中。\r\n  - 运行时，如果不存在“save.bin”，则进行新订单录入，如果存在，则显示并计算客户所需付款。\r\n\r\n- 分析：\r\n  - 编写 Save() 方法保存对象到“save.bin”\r\n  - 编写 Load() 方法获得对象，计算客户所需付款\r\n\r\n![image-20230417090111198](./assets/image-20230417090111198.png)\r\n\r\n##  其他流的使用\r\n\r\n### 标准输入、输出流\r\n\r\n- System.in 和 System.out 分别代表了系统标准的输入和输出设备\r\n- 默认输入设备是：键盘，输出设备是：显示器\r\n- System.in 的类型是 InputStream\r\n- System.out 的类型是 PrintStream，其是 OutputStream 的子类 FilterOutputStream 的子类\r\n- 重定向：通过 System 类的 setIn，setOut 方法对默认设备进行改变。\r\n  - public static void setIn(InputStream in)\r\n  - public static void setOut(PrintStream out)\r\n\r\n**举例：**\r\n\r\n从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。\r\n\r\n```java\r\nSystem.out.println(\"请输入信息 (退出输入 e 或 exit):\");\r\n// 把\"标准\"输入流 (键盘输入) 这个字节流包装成字符流，再包装成缓冲流\r\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\nString s = null;\r\ntry {\r\n    while ((s = br.readLine()) != null) { // 读取用户输入的一行数据 --> 阻塞程序\r\n        if (\"e\".equalsIgnoreCase(s) || \"exit\".equalsIgnoreCase(s)) {\r\n            System.out.println(\"安全退出!!\");\r\n            break;\r\n        }\r\n        // 将读取到的整行字符串转成大写输出\r\n        System.out.println(\"-->:\" + s.toUpperCase());\r\n        System.out.println(\"继续输入信息\");\r\n    }\r\n} catch (IOException e) {\r\n    e.printStackTrace();\r\n} finally {\r\n    try {\r\n        if (br != null) {\r\n            br.close(); // 关闭过滤流时，会自动关闭它包装的底层节点流\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\r\n\r\n```\r\n\r\n**拓展：**\r\n\r\nSystem 类中有三个常量对象：System.out、System.in、System.err\r\n\r\n查看 System 类中这三个常量对象的声明：\r\n\r\n```java\r\npublic final static InputStream in = null;\r\npublic final static PrintStream out = null;\r\npublic final static PrintStream err = null;\r\n```\r\n\r\n奇怪的是，\r\n\r\n- 这三个常量对象有 final 声明，但是却初始化为 null。final 声明的常量一旦赋值就不能修改，那么 null 不会空指针异常吗？\r\n- 这三个常量对象为什么要小写？final 声明的常量按照命名规范不是应该大写吗？\r\n- 这三个常量的对象有 set 方法？final 声明的常量不是不能修改值吗？set 方法是如何修改它们的值的？\r\n\r\n```java\r\nfinal声明的常量，表示在Java的语法体系中它们的值是不能修改的，而这三个常量对象的值是由C/C++等系统函数进行初始化和修改值的，所以它们故意没有用大写，也有set方法。\r\n```\r\n\r\n```java\r\npublic static void setOut(PrintStream out) {\r\n    checkIO();\r\n    setOut0(out);\r\n}\r\npublic static void setErr(PrintStream err) {\r\n    checkIO();\r\n    setErr0(err);\r\n}\r\npublic static void setIn(InputStream in) {\r\n    checkIO();\r\n    setIn0(in);\r\n}\r\nprivate static void checkIO() {\r\n    SecurityManager sm = getSecurityManager();\r\n    if (sm != null) {\r\n        sm.checkPermission(new RuntimePermission(\"setIO\"));\r\n    }\r\n}\r\nprivate static native void setIn0(InputStream in);\r\nprivate static native void setOut0(PrintStream out);\r\nprivate static native void setErr0(PrintStream err);\r\n```\r\n\r\n**练习：**\r\n\r\nCreate a program named MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and String values from the keyboard.\r\n\r\n![image-20230417090129788](./assets/image-20230417090129788.png)\r\n\r\n```java\r\npublic class MyInput {\r\n    // Read a string from the keyboard\r\n    public static String readString() {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\r\n        // Declare and initialize the string\r\n        String string = \"\";\r\n\r\n        // Get the string from the keyboard\r\n        try {\r\n            string = br.readLine();\r\n\r\n        } catch (IOException ex) {\r\n            System.out.println(ex);\r\n        }\r\n\r\n        // Return the string obtained from the keyboard\r\n        return string;\r\n    }\r\n\r\n    // Read an int value from the keyboard\r\n    public static int readInt() {\r\n        return Integer.parseInt(readString());\r\n    }\r\n\r\n    // Read a double value from the keyboard\r\n    public static double readDouble() {\r\n        return Double.parseDouble(readString());\r\n    }\r\n\r\n    // Read a byte value from the keyboard\r\n    public static double readByte() {\r\n        return Byte.parseByte(readString());\r\n    }\r\n\r\n    // Read a short value from the keyboard\r\n    public static double readShort() {\r\n        return Short.parseShort(readString());\r\n    }\r\n\r\n    // Read a long value from the keyboard\r\n    public static double readLong() {\r\n        return Long.parseLong(readString());\r\n    }\r\n\r\n    // Read a float value from the keyboard\r\n    public static double readFloat() {\r\n        return Float.parseFloat(readString());\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 打印流\r\n\r\n- 实现将基本数据类型的数据格式转化为字符串输出。\r\n\r\n\r\n- 打印流：`PrintStream`和`PrintWriter`\r\n\r\n  - 提供了一系列重载的 print() 和 println() 方法，用于多种数据类型的输出\r\n\r\n    ![image-20230417090144157](./assets/image-20230417090144157.png)\r\n\r\n    ![image-20230417090149241](./assets/image-20230417090149241.png)\r\n\r\n  - PrintStream 和 PrintWriter 的输出不会抛出 IOException 异常\r\n\r\n  - PrintStream 和 PrintWriter 有自动 flush 功能\r\n\r\n  - PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。\r\n\r\n  - System.out 返回的是 PrintStream 的实例\r\n\r\n- 构造器\r\n\r\n  - PrintStream(File file) ：创建具有指定文件且不带自动行刷新的新打印流。 \r\n  - PrintStream(File file, String csn)：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 \r\n  - PrintStream(OutputStream out) ：创建新的打印流。 \r\n  - PrintStream(OutputStream out, boolean autoFlush)：创建新的打印流。autoFlush 如果为 true，则每当写入 byte 数组、调用其中一个 println 方法或写入换行符或字节 ('\\n') 时都会刷新输出缓冲区。\r\n  - PrintStream(OutputStream out, boolean autoFlush, String encoding) ：创建新的打印流。 \r\n  - PrintStream(String fileName)：创建具有指定文件名称且不带自动行刷新的新打印流。 \r\n  - PrintStream(String fileName, String csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。\r\n\r\n- 代码举例 1\r\n\r\n\r\n```java\r\npublic class TestPrintStream {\r\n    public static void main(String[] args) throws FileNotFoundException {\r\n        PrintStream ps = new PrintStream(\"io.txt\");\r\n        ps.println(\"hello\");\r\n        ps.println(1);\r\n        ps.println(1.5);\r\n        ps.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n- 代码举例 2\r\n\r\n```java\r\nPrintStream ps = null;\r\ntry {\r\n    FileOutputStream fos = new FileOutputStream(new File(\"D:\\\\IO\\\\text.txt\"));\r\n    // 创建打印输出流，设置为自动刷新模式 (写入换行符或字节 '\\n' 时都会刷新输出缓冲区)\r\n    ps = new PrintStream(fos, true);\r\n    if (ps != null) {// 把标准输出流 (控制台输出) 改成文件\r\n        System.setOut(ps);\r\n    }\r\n    for (int i = 0; i <= 255; i++) { // 输出 ASCII 字符\r\n        System.out.print((char) i);\r\n        if (i % 50 == 0) { // 每 50 个数据一行\r\n            System.out.println(); // 换行\r\n        }\r\n    }\r\n} catch (FileNotFoundException e) {\r\n    e.printStackTrace();\r\n} finally {\r\n    if (ps != null) {\r\n        ps.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n- 代码举例 3：自定义一个日志工具\r\n\r\n```java\r\n/*\r\n日志工具\r\n */\r\npublic class Logger {\r\n    /*\r\n    记录日志的方法。\r\n     */\r\n    public static void log(String msg) {\r\n        try {\r\n            // 指向一个日志文件\r\n            PrintStream out = new PrintStream(new FileOutputStream(\"log.txt\", true));\r\n            // 改变输出方向\r\n            System.setOut(out);\r\n            // 日期当前时间\r\n            Date nowTime = new Date();\r\n            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\r\n            String strTime = sdf.format(nowTime);\r\n\r\n            System.out.println(strTime + \": \" + msg);\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class LogTest {\r\n    public static void main(String[] args) {\r\n        //测试工具类是否好用\r\n        Logger.log(\"调用了 System 类的 gc() 方法，建议启动垃圾回收\");\r\n        Logger.log(\"调用了 TeamView 的 addMember() 方法\");\r\n        Logger.log(\"用户尝试进行登录，验证失败\");\r\n    }\r\n}\r\n```\r\n\r\n### Scanner 类\r\n\r\n构造方法\r\n\r\n* Scanner(File source) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 \r\n* Scanner(File source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 \r\n* Scanner(InputStream source) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。 \r\n* Scanner(InputStream source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。\r\n\r\n常用方法：\r\n\r\n* boolean hasNextXxx()：如果通过使用 nextXxx() 方法，此扫描器输入信息中的下一个标记可以解释为默认基数中的一个 Xxx 值，则返回 true。\r\n* Xxx nextXxx()：将输入信息的下一个标记扫描为一个 Xxx\r\n\r\n```java\r\npublic class TestScanner {\r\n\r\n    @Test\r\n    public void test01() throws IOException {\r\n        Scanner input = new Scanner(System.in);\r\n        PrintStream ps = new PrintStream(\"1.txt\");\r\n        while(true){\r\n            System.out.print(\"请输入一个单词：\");\r\n            String str = input.nextLine();\r\n            if(\"stop\".equals(str)){\r\n                break;\r\n            }\r\n            ps.println(str);\r\n        }\r\n        input.close();\r\n        ps.close();\r\n    }\r\n    \r\n    @Test\r\n    public void test2() throws IOException {\r\n        Scanner input = new Scanner(new FileInputStream(\"1.txt\"));\r\n        while(input.hasNextLine()){\r\n            String str = input.nextLine();\r\n            System.out.println(str);\r\n        }\r\n        input.close();\r\n    }\r\n}\r\n```\r\n\r\n## apache-common 包的使用\r\n\r\n### 介绍\r\n\r\nIO 技术开发中，代码量很大，而且代码的重复率较高，为此 Apache 软件基金会，开发了 IO 技术的工具类`commonsIO`，大大简化了 IO 开发。\r\n\r\nApahce 软件基金会属于第三方，（Oracle 公司第一方，我们自己第二方，其他都是第三方）我们要使用第三方开发好的工具，需要添加 jar 包。\r\n\r\n### 导包及举例\r\n\r\n- 在导入 commons-io-2.5.jar 包之后，内部的 API 都可以使用。\r\n\r\n\r\n![image-20230417090232305](./assets/image-20230417090232305.png)\r\n\r\n- IOUtils 类的使用\r\n\r\n```java\r\n- 静态方法：IOUtils.copy(InputStream in,OutputStream out)传递字节流，实现文件复制。\r\n- 静态方法：IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常。\r\n```\r\n\r\n```java\r\npublic class Test01 {\r\n    public static void main(String[] args)throws Exception {\r\n        //- 静态方法：IOUtils.copy(InputStream in,OutputStream out) 传递字节流，实现文件复制。\r\n        IOUtils.copy(new FileInputStream(\"E:\\\\Idea\\\\io\\\\1.jpg\"),new FileOutputStream(\"E:\\\\Idea\\\\io\\\\file\\\\柳岩.jpg\"));\r\n        //- 静态方法：IOUtils.closeQuietly(任意流对象) 悄悄的释放资源，自动处理 close() 方法抛出的异常。\r\n       /* FileWriter fw = null;\r\n        try {\r\n            fw = new FileWriter(\"day21\\\\io\\\\writer.txt\");\r\n            fw.write(\"hahah\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n           IOUtils.closeQuietly(fw);\r\n        }*/\r\n    }\r\n}\r\n```\r\n\r\n- FileUtils 类的使用\r\n\r\n```java\r\n- 静态方法：void copyDirectoryToDirectory(File src,File dest)：整个目录的复制，自动进行递归遍历\r\n          参数:\r\n          src:要复制的文件夹路径\r\n          dest:要将文件夹粘贴到哪里去\r\n             \r\n- 静态方法：void writeStringToFile(File file,String content)：将内容content写入到file中\r\n- 静态方法：String readFileToString(File file)：读取文件内容，并返回一个String\r\n- 静态方法：void copyFile(File srcFile,File destFile)：文件复制\r\n```\r\n\r\n```java\r\npublic class Test02 {\r\n    public static void main(String[] args) {\r\n        try {\r\n            //- 静态方法：void copyDirectoryToDirectory(File src,File dest);\r\n            FileUtils.copyDirectoryToDirectory(new File(\"E:\\\\Idea\\\\io\\\\aa\"),new File(\"E:\\\\Idea\\\\io\\\\file\"));\r\n\r\n\r\n            //- 静态方法：writeStringToFile(File file,String str)\r\n            FileUtils.writeStringToFile(new File(\"day21\\\\io\\\\commons.txt\"),\"柳岩你好\");\r\n\r\n            //- 静态方法：String readFileToString(File file)\r\n            String s = FileUtils.readFileToString(new File(\"day21\\\\io\\\\commons.txt\"));\r\n            System.out.println(s);\r\n            //- 静态方法：void copyFile(File srcFile,File destFile)\r\n            FileUtils.copyFile(new File(\"io\\\\yangm.png\"),new File(\"io\\\\yangm2.png\"));\r\n            System.out.println(\"复制成功\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javase/14.Java File 类与 IO 流.md b/src/java/javase/14.Java File 类与 IO 流.md
--- a/src/java/javase/14.Java File 类与 IO 流.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javase/14.Java File 类与 IO 流.md	(date 1682519104022)
@@ -9,7 +9,7 @@
 
 ---
 
-![image-20230417080941042](./../../.vuepress/public/Tomcat/image-20230417080941042.png)
+![image-20230417080941042](./assets/image-20230417080941042.png)
 
 ## java.io.File 类的使用
 
Index: src/java/javaweb/12.Listener 监听器.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Listener 监听器\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/08f469/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# Listener 监听器\r\n\r\n## 监听器机制\r\n\r\n- 注册监听：将事件，事件源，监听器绑定在一起，当事件源发生了某个事件后，执行监听器代码。\r\n\r\n## ServletContextListener\r\n\r\n- 监听 ServletContext 对象的销毁和创建\r\n\r\n- contextDestroyed(ServletContextEvent sce):ServletContext 对象被销毁前调用该对象\r\n- contextInitialized(ServletContextEvent sce):ServletContext 对象被创建后调用该对象\r\n\r\n## 监听器配置\r\n\r\n- 注解配置`@WebListener`\r\n- xml 配置\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/12.Listener 监听器.md b/src/java/javaweb/12.Listener 监听器.md
--- a/src/java/javaweb/12.Listener 监听器.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/12.Listener 监听器.md	(date 1682512992596)
@@ -1,12 +1,5 @@
 ---
-title: Listener 监听器
-date: 2023-03-07 14:59:21
-permalink: /pages/08f469/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # Listener 监听器
 
Index: src/java/javaweb/07.Session.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Session\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/9e6421/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# Session\r\n\r\n## Session 概念\r\n\r\n> 服务器端会话技术，将数据保存在服务器 HttpSession 对象\r\n\r\n| 获取 httpSession 对象 | request.getSession() |\r\n| ------------------- | -------------------- |\r\n| 存取数据            | getAttribute()       |\r\n| 获取数据            | setAttribute()       |\r\n| 移出数据            | removeAttribute()    |\r\n\r\n## Session 原理\r\n\r\n![image-20230417151728204](./assets/image-20230417151728204.png)\r\n\r\n## Session 细节\r\n\r\n- 默认情况 Session 是一次会话，如果要关闭浏览器后还能获取相同的 Session 对象，就需要创建 Cookie 持久化保存\r\n- Session 钝化和活化：在服务器正常关闭后，将 Session 对象序列化到硬盘上，在服务器正常启动后，将 Session 序列化转化为内存中的 Session 对象，Tomcat 会自动完成，生成的文件在 tomcat 的 work 目录中\r\n- Session 失效时间:1.服务器关闭，2 默认失效时间 30 分钟\r\n\r\n## Session 特点\r\n\r\n- 一次会话多次请求，存在服务器端\r\n- Session 存储任意类型，任意大小\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/07.Session.md b/src/java/javaweb/07.Session.md
--- a/src/java/javaweb/07.Session.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/07.Session.md	(date 1682512983861)
@@ -1,12 +1,5 @@
 ---
-title: Session
-date: 2023-03-07 14:59:21
-permalink: /pages/9e6421/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # Session
 
Index: src/java/javaweb/06.JSP.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: JSP\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/d22745/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# JSP\r\n\r\n## JSP 概念\r\n\r\n> java 服务端页面，功能：简化书写\r\n\r\n## jsp 原理\r\n\r\n> jsp 本质上就是一个 servlet\r\n\r\n![image-20230417151715959](./assets/image-20230417151715959.png)\r\n\r\n- 相关源码在 Tomcat 源码中\r\n- index_jsp extends HttpJspBase\r\n- HttpJspBase extends HttpServlet\r\n\r\n## jsp 脚本\r\n\r\n| <% 代码 %>  | service() | 定义的 java 语句，在 service 方法 |\r\n| ----------- | --------- | ---------------------------- |\r\n| <%! 代码 %> | 成员位置  | 定义成员变量，成员方法 (不用)  |\r\n| <%= 代码 %> | 输出页面  | 输出到页面上                 |\r\n\r\n## jsp 内置对象\r\n\r\n| request         | HttpRequest        | 域对象：一次请求共享数据 (转发)          |\r\n| --------------- | ------------------ | -------------------------------------- |\r\n| response        | HttpRresponse      | 响应对象                               |\r\n| out             | JspWriter          | 字符输出流对象                         |\r\n| **pageContext** | **PageContext**    | **域对象：当前页面共享数据**            |\r\n| **session**     | **HttpSession**    | **域对象：一次会话的多个请求共享数据**  |\r\n| **application** | **ServletContext** | **域对象：所有用户共享数据**            |\r\n| config          | ServletConfig      | 配置文件                               |\r\n| page            | Object             | this，当前                              |\r\n| exception       | Throwable          | isErrorPage(true) 可以使用 exception 对象 |\r\n\r\n![image-20230417151719630](./assets/image-20230417151719630.png)\r\n\r\n## jsp 指令\r\n\r\n><%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n\r\n| page 指令    | contentType    | 设置 MIME 和字符集                          |\r\n| ----------- | -------------- | ----------------------------------------- |\r\n|             | language       | 设置语言                                  |\r\n|             | buffer         | 设置缓冲区                                |\r\n|             | import         | 设置导包                                  |\r\n|             | errorPage      | 错误页面                                  |\r\n|             | isErrorPage    | 是否是错误页面 (true) 可以使用 exception 对象 |\r\n| include 指令 | 引入重复的页面 |                                           |\r\n| taglib 指令  | 导入标签库     | 比如 jstl 标签库                            |\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/06.JSP.md b/src/java/javaweb/06.JSP.md
--- a/src/java/javaweb/06.JSP.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/06.JSP.md	(date 1682512982149)
@@ -1,12 +1,5 @@
 ---
-title: JSP
-date: 2023-03-07 14:59:21
-permalink: /pages/d22745/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # JSP
 
Index: src/java/javaweb/09.EL 表达式.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: EL 表达式\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/566083/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# EL 表达式\r\n\r\n## EL 表达式\r\n\r\n> ${表达式} EL 表达式为了简化 jsp 开发，不用写 java 代码\r\n\r\n## 从域对象中获取值\r\n\r\n| pageScope        | pageContext |\r\n| ---------------- | ----------- |\r\n| requestScope     | request     |\r\n| sessionScope     | session     |\r\n| applicationScope | application |\r\n\r\n```\r\n例如request域中存储了name=zhangsan\r\nEL表达式获取值:${requestScope.name}\r\n```\r\n\r\n```el\r\n<%=request.getSession().getAttribute(\"user\")%>欢迎您\r\n${sessionScope.user}欢迎您!\r\n```\r\n\r\n## 从域对象中获取对象\r\n\r\n```html\r\n<%=\r\nUser user = new User();\r\nuser.setName = \"zhangsan\";\r\nuser.setAge = \"18\";\r\nrequest.setAttribute(\"user\",user)\r\n%>\r\n\r\n${requestScope.user.name}\r\n${requestScope.user.age}\r\n//获取 list 集合的值${域。键名 [index]}\r\n//获取 map 集合的值${域。键名。值名}\r\n```\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/09.EL 表达式.md b/src/java/javaweb/09.EL 表达式.md
--- a/src/java/javaweb/09.EL 表达式.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/09.EL 表达式.md	(date 1682512988189)
@@ -1,12 +1,5 @@
 ---
-title: EL 表达式
-date: 2023-03-07 14:59:21
-permalink: /pages/566083/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # EL 表达式
 
Index: src/java/javaweb/08.MVC 模型.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: MVC 模型\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/07f48c/\r\ncategories:\r\n  - Java\r\n  - JavaWeb\r\ntags:\r\n  - \r\n---\r\n# MVC 模型\r\n\r\n> model 模型\r\n>\r\n> view 视图\r\n>\r\n> controller 控制器\r\n\r\n![image-20230417151735609](./assets/image-20230417151735609.png)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/javaweb/08.MVC 模型.md b/src/java/javaweb/08.MVC 模型.md
--- a/src/java/javaweb/08.MVC 模型.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/javaweb/08.MVC 模型.md	(date 1682512986531)
@@ -1,12 +1,5 @@
 ---
-title: MVC 模型
-date: 2023-03-07 14:59:21
-permalink: /pages/07f48c/
-categories:
-  - Java
-  - JavaWeb
-tags:
-  - 
+
 ---
 # MVC 模型
 
Index: src/java/JVM/08.堆.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 堆\r\ndate: 2023-04-05 07:26:25\r\npermalink: /pages/a7de02/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/08.堆.md b/src/java/JVM/08.堆.md
--- a/src/java/JVM/08.堆.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/08.堆.md	(date 1682513050492)
@@ -1,10 +1,3 @@
 ---
-title: 堆
-date: 2023-04-05 07:26:25
-permalink: /pages/a7de02/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
Index: src/java/JVM/07.本地方法栈.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 本地方法栈\r\ndate: 2023-04-05 07:28:07\r\npermalink: /pages/f7189c/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/07.本地方法栈.md b/src/java/JVM/07.本地方法栈.md
--- a/src/java/JVM/07.本地方法栈.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/07.本地方法栈.md	(date 1682513049000)
@@ -1,10 +1,1 @@
----
-title: 本地方法栈
-date: 2023-04-05 07:28:07
-permalink: /pages/f7189c/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
----
+
Index: src/java/JVM/10.直接内存.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 直接内存\r\ndate: 2023-04-05 07:28:44\r\npermalink: /pages/014306/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/10.直接内存.md b/src/java/JVM/10.直接内存.md
--- a/src/java/JVM/10.直接内存.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/10.直接内存.md	(date 1682513250302)
@@ -1,10 +1,3 @@
 ---
-title: 直接内存
-date: 2023-04-05 07:28:44
-permalink: /pages/014306/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
Index: src/java/JVM/09.方法区.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 方法区\r\ndate: 2023-04-05 07:26:33\r\npermalink: /pages/abb785/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/09.方法区.md b/src/java/JVM/09.方法区.md
--- a/src/java/JVM/09.方法区.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/09.方法区.md	(date 1682513054362)
@@ -1,10 +1,3 @@
 ---
-title: 方法区
-date: 2023-04-05 07:26:33
-permalink: /pages/abb785/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
Index: src/java/JVM/04.程序计数器.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 程序计数器\r\ndate: 2023-04-05 07:27:10\r\npermalink: /pages/3e45c5/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n\r\n# 程序计数器\r\n\r\n## 介绍\r\n\r\nJVM 中的程序计数寄存器（Program Counter Register）中，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。\r\n\r\n![image-20230405154737285](./assets/image-20230405154737285.png)\r\n\r\n它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。\r\n\r\n在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。\r\n\r\n任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者如果是在执行 native 方法，则是未指定值（undefned）。\r\n\r\n它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\r\n\r\n它是唯一一个在 Java 虚拟机规范中没有规定任何 outotMemoryError 情况的区域。\r\n\r\n## 作用\r\n\r\nPC**寄存器用来存储指向下一条指令的地址**，也即将要执行的指令代码。由执行引擎读取下一条指令。\r\n\r\n![image-20200705155728557](./assets/image-20230405154859863.png)\r\n\r\n## 代码演示\r\n\r\n我们首先写一个简单的代码\r\n\r\n```java\r\npublic class PCRegisterTest {\r\n    public static void main(String[] args) {\r\n        int i = 10;\r\n        int j = 20;\r\n        int k = i + j;\r\n    }\r\n}\r\n```\r\n\r\n然后将代码进行编译成字节码文件，我们再次查看，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。\r\n\r\n```bash\r\n0: bipush        10\r\n2: istore_1\r\n3: bipush        20\r\n5: istore_2\r\n6: iload_1\r\n7: iload_2\r\n8: iadd\r\n9: istore_3\r\n10: return\r\n```\r\n\r\n通过 PC 寄存器，我们就可以知道当前程序执行到哪一步了\r\n\r\n![image-20230405155748433](./assets/image-20230405155748433.png)\r\n\r\n\r\n\r\n## 使用 PC 寄存器存储字节码指令地址有什么用呢？\r\n\r\n因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。\r\n\r\nJVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。\r\n\r\n![image-20230405160141968](./assets/image-20230405160141968.png)\r\n\r\n## PC 寄存器为什么被设定为私有的？\r\n\r\n我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。**\r\n\r\n由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。\r\n\r\n这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\r\n\r\n![image-20230405160147336](./assets/image-20230405160147336.png)\r\n\r\n## CPU 时间片\r\n\r\nCPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。\r\n\r\n在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。\r\n\r\n但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。\r\n\r\n![image-20230405160153186](./assets/image-20230405160153186.png)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/04.程序计数器.md b/src/java/JVM/04.程序计数器.md
--- a/src/java/JVM/04.程序计数器.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/04.程序计数器.md	(date 1682513042119)
@@ -1,12 +1,5 @@
 ---
-title: 程序计数器
-date: 2023-04-05 07:27:10
-permalink: /pages/3e45c5/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
 
 # 程序计数器
Index: src/java/JVM/03.运行时数据区.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 运行时数据区\r\ndate: 2023-04-05 07:26:04\r\npermalink: /pages/828ced/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n\r\n# 运行时数据区\r\n\r\n## 前言\r\n\r\n本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段\r\n\r\n![image-20230405152551065](./assets/image-20230405152551065.png)\r\n\r\n当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区\r\n\r\n![image-20230405152641596](./assets/image-20230405152641596.png)\r\n\r\n也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品\r\n\r\n![image-20230405152658910](./assets/image-20230405152658910.png)\r\n\r\n内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。\r\n\r\n> 我们通过磁盘或者网络 IO 得到的数据，都需要先加载到内存中，然后 CPU 从内存中获取数据进行读取，也就是说内存充当了 CPU 和磁盘之间的桥梁\r\n\r\n运行时数据区的完整图\r\n\r\n![image-20230405152748693](./assets/image-20230405152748693.png)\r\n\r\nJava 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。\r\n\r\n灰色的为单独线程私有的，红色的为多个线程共享的。即：\r\n\r\n- 私有的：程序计数器、栈、本地栈。\r\n- 共享的：堆、堆外内存（永久代或元空间、代码缓存）\r\n\r\n![image-20230405153332493](./assets/image-20230405153332493.png)\r\n\r\n## 线程\r\n\r\n线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。\r\n\r\n在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射。\r\n\r\n- 当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。\r\n\r\n操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run（）方法。\r\n\r\n### JVM 系统线程\r\n\r\n如果你使用 console 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用`public static void main（String[]）`的 main 线程以及所有这个 main 线程自己创建的线程。这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：\r\n\r\n- 虚拟机线程：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括\"stop-the-world\"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。\r\n- 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。\r\n- GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。\r\n- 编译线程：这种线程在运行时会将字节码编译成到本地代码。\r\n- 信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/03.运行时数据区.md b/src/java/JVM/03.运行时数据区.md
--- a/src/java/JVM/03.运行时数据区.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/03.运行时数据区.md	(date 1682513040581)
@@ -1,12 +1,5 @@
 ---
-title: 运行时数据区
-date: 2023-04-05 07:26:04
-permalink: /pages/828ced/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
 
 # 运行时数据区
Index: src/java/JVM/06.本地方法接口.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 本地方法接口\r\ndate: 2023-04-05 07:27:42\r\npermalink: /pages/9a7fae/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/06.本地方法接口.md b/src/java/JVM/06.本地方法接口.md
--- a/src/java/JVM/06.本地方法接口.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/06.本地方法接口.md	(date 1682513046398)
@@ -1,10 +1,3 @@
 ---
-title: 本地方法接口
-date: 2023-04-05 07:27:42
-permalink: /pages/9a7fae/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
Index: src/java/JVM/05.虚拟机栈.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 虚拟机栈\r\ndate: 2023-04-05 07:26:15\r\npermalink: /pages/3a9140/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n\r\n# 虚拟机栈\r\n\r\n## 虚拟机栈概述\r\n\r\n由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。\r\n\r\n优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。\r\n\r\n有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap) 和 Java 栈（stack）？为什么？\r\n\r\n首先栈是运行时的单位，而堆是存储的单位\r\n\r\n- 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。\r\n- 堆解决的是数据存储的问题，即数据怎么放，放哪里\r\n\r\n![image-20230405161307238](./assets/image-20230405161307238.png)\r\n\r\n### Java 虚拟机栈是什么\r\n\r\nJava 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。\r\n\r\n>是线程私有的\r\n\r\n![image-20230405161325375](./assets/image-20230405161325375.png)\r\n\r\n### 生命周期\r\n\r\n生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了\r\n\r\n### 作用\r\n\r\n主管 Java 程序的运行，它保存方法的局部变量（8 种基本类型和引用数据类型的地址）、部分结果，并参与方法的调用和返回。\r\n\r\n> 局部变量，它是相比于成员变量来说的（或属性）\r\n>\r\n> 基本数据类型变量 VS  引用类型变量（类、数组、接口）\r\n\r\n### 栈的特点\r\n\r\n栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM 直接对 Java 栈的操作只有两个：\r\n\r\n- 每个方法执行，伴随着进栈（入栈、压栈）\r\n- 执行结束后的出栈工作\r\n\r\n对于栈来说不存在垃圾回收问题（栈存在溢出的情况）\r\n\r\n![image-20230405161924056](./assets/image-20230405161924056.png)\r\n\r\n### 开发中遇到哪些异常？\r\n\r\n栈中可能出现的异常\r\n\r\nJava 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的。\r\n\r\n如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 StackoverflowError 异常。\r\n\r\n如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 outofMemoryError 异常。\r\n\r\n```java\r\npublic class StackErrorTest {\r\n    private static int count = 1;\r\n    public static void main(String[] args) {\r\n        System.out.println(count++);\r\n        main(args);\r\n    }\r\n}\r\n```\r\n\r\n当栈深度达到 9803 的时候，就出现栈内存空间不足\r\n\r\n### 设置栈内存大小\r\n\r\n我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度\r\n\r\n```java\r\n-Xss1m\r\n-Xss1k\r\n```\r\n\r\n![image-20230405163129435](./assets/image-20230405163129435.png)\r\n\r\n## 栈的存储单位\r\n\r\n每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。\r\n\r\n在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。\r\n\r\n栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。\r\n\r\n### 栈中存储什么？\r\n\r\n每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。在这个线程上正在执行的每个方法都各自对应一个栈颜（Stack Frame）。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。\r\n\r\n> OOP 的基本概念：类和对象\r\n>\r\n> 类中基本结构：field（属性、字段、域）、method\r\n\r\nJVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。\r\n\r\n在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。\r\n\r\n执行引擎运行的所有字节码指令只针对当前栈帧进行操作。\r\n\r\n如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。\r\n\r\n![image-20230405164730776](./assets/image-20230405164730776.png)\r\n\r\n下面写一个简单的代码\r\n\r\n```java\r\npublic class StackFrameTest {\r\n    public static void main(String[] args) {\r\n        method01();\r\n    }\r\n\r\n    private static int method01() {\r\n        System.out.println(\"方法 1 的开始\");\r\n        int i = method02();\r\n        System.out.println(\"方法 1 的结束\");\r\n        return i;\r\n    }\r\n\r\n    private static int method02() {\r\n        System.out.println(\"方法 2 的开始\");\r\n        int i = method03();;\r\n        System.out.println(\"方法 2 的结束\");\r\n        return i;\r\n    }\r\n    private static int method03() {\r\n        System.out.println(\"方法 3 的开始\");\r\n        int i = 30;\r\n        System.out.println(\"方法 3 的结束\");\r\n        return i;\r\n    }\r\n}\r\n```\r\n\r\n输出结果为\r\n\r\n```bash\r\n方法1的开始\r\n方法2的开始\r\n方法3的开始\r\n方法3的结束\r\n方法2的结束\r\n方法1的结束\r\n```\r\n\r\n满足栈先进后出的概念，通过 IDEA 的 DEBUG，能够看到栈信息\r\n\r\n![image-20230405164934861](./assets/image-20230405164934861.png)\r\n\r\n### 栈运行原理\r\n\r\n不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。\r\n\r\n如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。\r\n\r\nJava 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。\r\n\r\n### 栈帧的内部结构\r\n\r\n每个栈帧中存储着：\r\n\r\n- 局部变量表（Local Variables）\r\n- 操作数栈（operand Stack）（或表达式栈）\r\n- 动态链接（DynamicLinking）（或指向运行时常量池的方法引用）\r\n- 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）\r\n- 一些附加信息\r\n\r\n![image-20230405165122034](./assets/image-20230405165122034.png)\r\n\r\n并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由**局部变量表和操作数栈**决定的\r\n\r\n![image-20230405165653981](./assets/image-20230405165653981.png)\r\n\r\n## 局部变量表\r\n\r\n局部变量表：Local Variables，被称之为局部变量数组或本地变量表\r\n\r\n**定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress 类型。**\r\n\r\n由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题\r\n\r\n局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。\r\n\r\n方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。\r\n\r\n局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。\r\n\r\n### 关于 Slot 的理解\r\n\r\n参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束。\r\n\r\n局部变量表，最基本的存储单元是 slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference），returnAddress 类型的变量。\r\n\r\n在局部变量表里，32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个 slot。\r\n\r\n>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true。\r\n>long 和 double 则占据两个 slot。\r\n\r\nJVM 会为局部变量表中的每一个 slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值\r\n\r\n当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个 slot 上\r\n\r\n如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可。（比如：访问 long 或 double 类型变量）\r\n\r\n如果当前帧是由构造方法或者实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 slot 处，其余的参数按照参数表顺序继续排列。\r\n\r\n![image-20230405171035244](./assets/image-20230405171035244.png)\r\n\r\n### Slot 的重复利用\r\n\r\n栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。\r\n\r\n\r\n\r\n### 静态变量与局部变量的对比\r\n\r\n变量的分类：\r\n\r\n- 按数据类型分：基本数据类型、引用数据类型\r\n- 按类中声明的位置分：成员变量（类变量，实例变量）、局部变量\r\n  - 类变量：linking 的 paper 阶段，给类变量默认赋值，init 阶段给类变量显示赋值即静态代码块\r\n  - 实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值\r\n  - 局部变量：在使用前必须进行显式赋值，不然编译不通过。\r\n\r\n参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。\r\n\r\n我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。\r\n\r\n和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。\r\n\r\n在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。\r\n\r\n局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。\r\n\r\n## 操作数栈\r\n\r\n### 概念\r\n\r\n操作数栈：Operand Stack\r\n\r\n每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 **操作数栈**，也可以称之为 **表达式栈**（Expression Stack）\r\n\r\n操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）\r\n\r\n- 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈\r\n- 比如：执行复制、交换、求和等操作\r\n\r\n\r\n\r\n代码举例\r\n\r\n\r\n\r\n操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。\r\n\r\n操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.\r\n\r\n> 这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的\r\n\r\n每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性中，为 maxstack 的值。\r\n\r\n栈中的任何一个元素都是可以任意的 Java 数据类型\r\n\r\n- 32bit 的类型占用一个栈单位深度\r\n- 64bit 的类型占用两个栈单位深度\r\n\r\n操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问\r\n\r\n如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 PC 寄存器中下一条需要执行的字节码指令。\r\n\r\n操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|\r\n\r\n另外，我们说 Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。\r\n\r\n### 代码追踪\r\n\r\n我们给定代码\r\n\r\n```java\r\npublic void testAddOperation() {\r\n    byte i = 15;\r\n    int j = 8;\r\n    int k = i + j;\r\n}\r\n```\r\n\r\n使用 javap 命令反编译 class 文件：javap -v 类名.class\r\n\r\n\r\n\r\n> byte、short、char、boolean 内部都是使用 int 型来进行保存的\r\n>\r\n> 从上面的代码我们可以知道，我们都是通过 bipush 对操作数 15 和  8 进行入栈操作\r\n>\r\n> 同时使用的是 iadd 方法进行相加操作，i -> 代表的就是 int，也就是 int 类型的加法操作\r\n\r\n执行流程如下所示：\r\n\r\n首先执行第一条语句，PC 寄存器指向的是 0，也就是指令地址为 0，然后使用 bipush 让操作数 15 入栈。\r\n\r\n\r\n\r\n执行完后，让 PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表 1 的位置，我们可以看到局部变量表的已经增加了一个元素\r\n\r\n\r\n\r\n> 为什么局部变量表不是从 0 开始的呢？\r\n>\r\n> 其实局部变量表也是从 0 开始的，但是因为 0 号位置存储的是 this 指针，所以说就直接省略了~\r\n\r\n然后 PC+1，指向的是下一行。让操作数 8 也入栈，同时执行 store 操作，存入局部变量表中\r\n\r\n\r\n\r\n\r\n\r\n然后从局部变量表中，依次将数据放在操作数栈中\r\n\r\n\r\n\r\n\r\n\r\n然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表 3 的位置\r\n\r\n\r\n\r\n\r\n\r\n最后 PC 寄存器的位置指向 10，也就是 return 方法，则直接退出方法\r\n\r\ni++和++i 的区别\r\n\r\n## 栈顶缓存技术\r\n\r\n栈顶缓存技术：Top Of Stack Cashing\r\n\r\n前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。\r\n\r\n由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。\r\n\r\n> 寄存器：指令更少，执行速度快\r\n\r\n## 动态链接\r\n\r\n动态链接：Dynamic Linking\r\n\r\n\r\n\r\n> 动态链接、方法返回地址、附加信息：有些地方被称为帧数据区\r\n\r\n每一个栈帧内部都包含一个指向**运行时常量池**中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令\r\n\r\n在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在 class 文件的常量池里。\r\n\r\n比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。\r\n\r\n\r\n\r\n> 为什么需要运行时常量池？\r\n>\r\n> 因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间\r\n>\r\n> 常量池的作用：就是为了提供一些符号和常量，便于指令的识别\r\n\r\n## 方法调用：解析与分配\r\n\r\n在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关\r\n\r\n### 链接\r\n\r\n#### 静态链接\r\n\r\n当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期克制，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接\r\n\r\n#### 动态链接\r\n\r\n如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。\r\n\r\n### 绑定机制\r\n\r\n对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。\r\n\r\n#### 早期绑定\r\n\r\n早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。\r\n\r\n#### 晚期绑定\r\n\r\n如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。\r\n\r\n### 早晚期绑定的发展历史\r\n\r\n随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。\r\n\r\nJava 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++语言中的虚函数（C++中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。\r\n\r\n### 虚方法和非虚方法\r\n\r\n- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。\r\n- 静态方法、私有方法、fina1 方法、实例构造器、父类方法都是非虚方法。\r\n- 其他方法称为虚方法。\r\n\r\n> 子类对象的多态的使用前提\r\n>\r\n> - 类的继承关系\r\n> - 方法的重写\r\n\r\n\r\n\r\n虚拟机中提供了以下几条方法调用指令：\r\n\r\n#### 普通调用指令：\r\n\r\n- invokestatic：调用静态方法，解析阶段确定唯一方法版本\r\n- invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本\r\n- invokevirtual：调用所有虚方法\r\n- invokeinterface：调用接口方法\r\n\r\n#### 动态调用指令：\r\n\r\n- invokedynamic：动态解析出需要调用的方法，然后执行\r\n\r\n前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（fina1 修饰的除外）称为虚方法。\r\n\r\n### invokednamic 指令\r\n\r\nJVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 invokedynamic 指令，这是 Java 为了实现动态类型语言】支持而做的一种改进。\r\n\r\n但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。\r\n\r\nJava7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。\r\n\r\n### 动态类型语言和静态类型语言\r\n\r\n动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。\r\n\r\n说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。\r\n\r\n> Java：String info = \"mogu blog\";     (Java 是静态类型语言的，会先编译就进行类型检查)\r\n>\r\n> JS：var name = \"shkstart\";    var name = 10;    （运行时才进行检查）\r\n\r\n### 方法重写的本质\r\n\r\n#### Java 语言中方法重写的本质：\r\n\r\n- 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。\r\n- 如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.1ang.I1legalAccessError 异常。\r\n- 否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。\r\n- 如果始终没有找到合适的方法，则抛出 java.1ang.AbstractMethodsrror 异常。\r\n\r\n#### IllegalAccessError 介绍\r\n\r\n程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。\r\n\r\n### 方法的调用：虚方法表\r\n\r\n在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表\r\n（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。\r\n\r\n每个类中都有一个虚方法表，表中存放着各个方法的实际入口。\r\n\r\n虚方法表是什么时候被创建的呢？\r\n\r\n虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。\r\n\r\n\r\n\r\n如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到 Object 的方法中。\r\n\r\n## 方法返回地址\r\n\r\n存放调用该方法的 pc 寄存器的值。一个方法的结束，有两种方式：\r\n\r\n- 正常执行完成\r\n\r\n- 出现未处理的异常，非正常退出\r\n\r\n无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\r\n\r\n当一个方法开始执行后，只有两种方式可以退出这个方法：\r\n\r\n执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；\r\n\r\n- 一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。\r\n- 在字节码指令中，返回指令包含 ireturn（当返回值是 boolean，byte，char，short 和 int 类型时使用），lreturn（Long 类型），freturn（Float 类型），dreturn（Double 类型），areturn。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。\r\n\r\n在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。\r\n\r\n方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码\r\n\r\n\r\n\r\n本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。\r\n\r\n正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。\r\n\r\n## 一些附加信息\r\n\r\n栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。\r\n\r\n## 栈的相关面试题\r\n\r\n- 举例栈溢出的情况？（StackOverflowError）\r\n  - 通过 -Xss 设置栈的大小\r\n- 调整栈大小，就能保证不出现溢出么？\r\n  - 不能保证不溢出\r\n- 分配的栈内存越大越好么？\r\n  - 不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。\r\n- 垃圾回收是否涉及到虚拟机栈？\r\n  - 不会\r\n- 方法中定义的局部变量是否线程安全？\r\n  - 具体问题具体分析\r\n\r\n```java\r\n/**\r\n * 面试题\r\n * 方法中定义局部变量是否线程安全？具体情况具体分析\r\n * 何为线程安全？\r\n *    如果只有一个线程才可以操作此数据，则必是线程安全的\r\n *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全\r\n * @author: 陌溪\r\n * @create: 2020-07-06-16:08\r\n */\r\npublic class StringBuilderTest {\r\n\r\n    // s1 的声明方式是线程安全的\r\n    public static void method01() {\r\n        // 线程内部创建的，属于局部变量\r\n        StringBuilder s1 = new StringBuilder();\r\n        s1.append(\"a\");\r\n        s1.append(\"b\");\r\n    }\r\n\r\n    // 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用\r\n    public static StringBuilder method04() {\r\n        StringBuilder stringBuilder = new StringBuilder();\r\n        stringBuilder.append(\"a\");\r\n        stringBuilder.append(\"b\");\r\n        return stringBuilder;\r\n    }\r\n\r\n    // stringBuilder 是线程不安全的，操作的是共享数据\r\n    public static void method02(StringBuilder stringBuilder) {\r\n        stringBuilder.append(\"a\");\r\n        stringBuilder.append(\"b\");\r\n    }\r\n\r\n\r\n    /**\r\n     * 同时并发的执行，会出现线程不安全的问题\r\n     */\r\n    public static void method03() {\r\n        StringBuilder stringBuilder = new StringBuilder();\r\n        new Thread(() -> {\r\n            stringBuilder.append(\"a\");\r\n            stringBuilder.append(\"b\");\r\n        }, \"t1\").start();\r\n\r\n        method02(stringBuilder);\r\n    }\r\n\r\n    // StringBuilder 是线程安全的，但是 String 也可能线程不安全的\r\n    public static String method05() {\r\n        StringBuilder stringBuilder = new StringBuilder();\r\n        stringBuilder.append(\"a\");\r\n        stringBuilder.append(\"b\");\r\n        return stringBuilder.toString();\r\n    }\r\n}\r\n```\r\n\r\n总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。\r\n\r\n运行时数据区，是否存在 Error 和 GC？\r\n\r\n| 运行时数据区 | 是否存在 Error | 是否存在 GC |\r\n| ------------ | ------------- | ---------- |\r\n| 程序计数器   | 否            | 否         |\r\n| 虚拟机栈     | 是            | 否         |\r\n| 本地方法栈   | 是            | 否         |\r\n| 方法区       | 是（OOM）     | 是         |\r\n| 堆           | 是            | 是         |\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/05.虚拟机栈.md b/src/java/JVM/05.虚拟机栈.md
--- a/src/java/JVM/05.虚拟机栈.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/05.虚拟机栈.md	(date 1682515574057)
@@ -1,12 +1,5 @@
 ---
-title: 虚拟机栈
-date: 2023-04-05 07:26:15
-permalink: /pages/3a9140/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
 
 # 虚拟机栈
@@ -426,7 +419,7 @@
 #### 普通调用指令：
 
 - invokestatic：调用静态方法，解析阶段确定唯一方法版本
-- invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本
+- invokespecial：调用 `<init>` 方法、私有及父类方法，解析阶段确定唯一方法版本
 - invokevirtual：调用所有虚方法
 - invokeinterface：调用接口方法
 
Index: src/java/JVM/02.类加载子系统.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 类加载子系统\r\ndate: 2023-04-05 07:25:52\r\npermalink: /pages/fe220d/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n\r\n# 类加载子系统\r\n\r\n## 概述\r\n\r\n![image-20230405092447012](./assets/image-20230405092447012.png)\r\n\r\n完整版如下\r\n\r\n![image-20230405092456489](./assets/image-20230405092456489.png)\r\n\r\n如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？\r\n\r\n- 类加载器\r\n- 执行引擎\r\n\r\n## 类加载器子系统作用\r\n\r\n类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件开头有特定的文件标识。\r\n\r\nClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。\r\n\r\n加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）\r\n\r\n![image-20230405092754641](./assets/image-20230405092754641.png)\r\n\r\n- class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例\r\n- class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区\r\n- 在.class 文件->JVM->最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色\r\n\r\n![image-20230405092904792](./assets/image-20230405092904792.png)\r\n\r\n## 类的加载过程\r\n\r\n例如下面的一段简单的代码\r\n\r\n```java\r\npublic class HelloLoader {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"我已经被加载啦\");\r\n    }\r\n}\r\n```\r\n\r\n它的加载过程是怎么样的呢？\r\n\r\n![image-20230405093637276](./assets/image-20230405093637276.png)\r\n\r\n完整的流程图如下所示\r\n\r\n![image-20230405093716247](./assets/image-20230405093716247.png)\r\n\r\n### 加载阶段\r\n\r\n通过一个类的全限定名获取定义此类的二进制字节流\r\n\r\n将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\r\n\r\n在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口\r\n\r\n#### 加载 class 文件的方式\r\n\r\n- 从本地系统中直接加载\r\n- 通过网络获取，典型场景：Web Applet\r\n- 从 zip 压缩包中读取，成为日后 jar、war 格式的基础\r\n- 运行时计算生成，使用最多的是：动态代理技术\r\n- 由其他文件生成，典型场景：JSP 应用从专有数据库中提取.class 文件，比较少见\r\n- 从加密文件中获取，典型的防 Class 文件被反编译的保护措施\r\n\r\n### 链接阶段\r\n\r\n#### 验证 Verify\r\n\r\n目的在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。\r\n\r\n主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。\r\n\r\n![image-20230405094312699](./assets/image-20230405094312699.png)\r\n\r\n如果出现不合法的字节码文件，那么将会验证不通过\r\n\r\n同时我们可以通过安装 IDEA 的插件，来查看我们的 Class 文件\r\n\r\n![image-20230405094326056](./assets/image-20230405094326056.png)\r\n\r\n安装完成后，我们编译完一个 class 文件后，点击 view 即可显示我们安装的插件来查看字节码方法了\r\n\r\n![image-20230405095655937](./assets/image-20230405095655937.png)\r\n\r\n#### 准备 Prepare\r\n\r\n为类变量分配内存并且设置该类变量的默认初始值，即零值。\r\n\r\n```java\r\npublic class HelloApp {\r\n    private static int a = 1;  // 准备阶段为 0，在下个阶段，也就是初始化的时候才是 1\r\n    public static void main(String[] args) {\r\n        System.out.println(a);\r\n    }\r\n}\r\n```\r\n\r\n上面的变量 a 在准备阶段会赋初始值，但不是 1，而是 0。\r\n\r\n这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；\r\n\r\n这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。\r\n\r\n#### 解析 Resolve\r\n\r\n将常量池内的符号引用转换为直接引用的过程。\r\n\r\n事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。\r\n\r\n符号引用指的是在类的字节码中使用的一种符号化的引用方式。\r\n\r\n直接引用则是指具体的内存地址或偏移量等实际的引用方式。\r\n\r\n解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info 等\r\n\r\n### 初始化阶段\r\n\r\n- 初始化阶段就是执行类构造器法 `<clinit>（）` 的过程\r\n\r\n- 此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来\r\n\r\n- **也就是说，当我们代码中包含 static 变量的时候，就会有 `<clinit>（）`  方法**\r\n\r\n- 构造器方法中指令按语句在源文件中出现的顺序执行\r\n\r\n- `<clinit>（）` 不同于类的构造器。（关联：构造器是虚拟机视角下的 `<init>（）` ）\r\n\r\n- 若该类具有父类，JVM 会保证子类的 `<clinit>（）` 执行前，父类的 `<clinit>（）` 已经执行完毕\r\n\r\n- 关于涉及到父类时候的变量赋值过程\r\n\r\n  ```java\r\n  public class ClinitTest1 {\r\n      static class Father {\r\n          public static int A = 1;\r\n          static {\r\n              A = 2;\r\n          }\r\n      }\r\n  \r\n      static class Son extends Father {\r\n          public static int b = A;\r\n      }\r\n  \r\n      public static void main(String[] args) {\r\n          System.out.println(Son.b);\r\n      }\r\n  }\r\n  \r\n  // 我们输出结果为 2，也就是说首先加载 ClinitTest1 的时候，会找到 main 方法，然后执行 Son 的初始化，但是 Son 继承了 Father，因此还需要执行 Father 的初始化，同时将 A 赋值为 2。我们通过反编译得到 Father 的加载过程，首先我们看到原来的值被赋值成 1，然后又被复制成 2，最后返回\r\n  ```\r\n\r\n- 虚拟机必须保证一个类的`<clinit>（）`方法在多线程下被同步加锁\r\n\r\n  ```java\r\n  public class DeadThreadTest {\r\n      public static void main(String[] args) {\r\n          new Thread(() -> {\r\n              System.out.println(Thread.currentThread().getName() + \"\\t 线程 t1 开始\");\r\n              new DeadThread();\r\n          }, \"t1\").start();\r\n  \r\n          new Thread(() -> {\r\n              System.out.println(Thread.currentThread().getName() + \"\\t 线程 t2 开始\");\r\n              new DeadThread();\r\n          }, \"t2\").start();\r\n      }\r\n  }\r\n  \r\n  class DeadThread {\r\n      static {\r\n          if (true) {\r\n              System.out.println(Thread.currentThread().getName() + \"\\t 初始化当前类\");\r\n              while (true) {\r\n  \r\n              }\r\n          }\r\n      }\r\n  }\r\n  \r\n  // 线程 t1 开始\r\n  // 线程 t2 开始\r\n  // 线程 t2 初始化当前类\r\n  ```\r\n\r\n  从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程\r\n\r\n### ⭐小总结\r\n\r\nJava 类的加载过程是将类文件中的二进制代码加载到内存中并转化为 Java 类型的过程，主要包括以下几个步骤：\r\n\r\n1. 加载：通过类加载器加载类文件，并将类的信息存储在方法区中，包括类的全限定名、访问修饰符、常量池、字段和方法等信息。\r\n2. 验证：验证类文件的正确性，包括语法和语义检查，以确保其符合 JVM 规范。\r\n3. 准备：为类的静态变量分配内存，并将其初始化为默认值，如 int 类型为 0，对象引用类型为 null。\r\n4. 解析：将类中的符号引用转换为直接引用，以便在运行时直接调用类中的方法和字段。\r\n5. 初始化：执行类的初始化代码，包括静态变量的赋值和静态代码块的执行。\r\n\r\n总的来说，类的加载过程主要是将类文件加载到内存中，并对其进行验证、准备、解析和初始化等操作，以便在程序运行时能够正确地使用类的各种成员。\r\n\r\n## 类加载器的分类\r\n\r\nJVM 支持两种类型的类加载器。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。\r\n\r\n从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，**而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器。**\r\n\r\n无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有 3 个，如下所示：\r\n\r\n![image-20230405142949347](./assets/image-20230405142949347.png)\r\n\r\n这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。\r\n\r\n我们通过一个类，获取它不同的加载器\r\n\r\n```java\r\npublic class ClassLoaderTest {\r\n    public static void main(String[] args) {\r\n        // 获取系统类加载器\r\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\r\n        System.out.println(systemClassLoader);\r\n\r\n        // 获取其上层的：扩展类加载器\r\n        ClassLoader extClassLoader = systemClassLoader.getParent();\r\n        System.out.println(extClassLoader);\r\n\r\n        // 试图获取 根加载器\r\n        ClassLoader bootstrapClassLoader = extClassLoader.getParent();\r\n        System.out.println(bootstrapClassLoader);\r\n\r\n        // 获取自定义加载器\r\n        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();\r\n        System.out.println(classLoader);\r\n        \r\n        // 获取 String 类型的加载器\r\n        ClassLoader classLoader1 = String.class.getClassLoader();\r\n        System.out.println(classLoader1);\r\n    }\r\n}\r\n```\r\n\r\n得到的结果，从结果可以看出根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取 String 类型的加载器，发现是 null，那么说明 String 类型是通过根加载器进行加载的，也就是说 Java 的核心类库都是使用根加载器进行加载的。\r\n\r\n```\r\nsun.misc.Launcher$AppClassLoader@18b4aac2\r\nsun.misc.Launcher$ExtClassLoader@1540e19d\r\nnull\r\nsun.misc.Launcher$AppClassLoader@18b4aac2\r\nnull \r\n```\r\n\r\n### 虚拟机自带的加载器\r\n\r\n#### 启动类加载器（引导类加载器，Bootstrap ClassLoader）\r\n\r\n- 这个类加载使用C/C++语言实现的，嵌套在JVM内部。\r\n- 它用来加载 Java 的核心库（JAVAHOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类\r\n- 并不继承自 java.lang.ClassLoader，没有父加载器。\r\n- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。\r\n- 出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类\r\n\r\n#### 扩展类加载器（Extension ClassLoader）\r\n\r\n- Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。\r\n- 派生于 ClassLoader 类\r\n- 父类加载器为启动类加载器\r\n- 从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。\r\n\r\n#### 应用程序类加载器（系统类加载器，AppClassLoader）\r\n\r\n- javI 语言编写，由 sun.misc.LaunchersAppClassLoader 实现\r\n- 派生于 ClassLoader 类\r\n- 父类加载器为扩展类加载器\r\n- 它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库\r\n- 该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载\r\n- 通过 classLoader#getSystemclassLoader（）方法可以获取到该类加载器\r\n\r\n### 用户自定义类加载器\r\n\r\n在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。\r\n为什么要自定义类加载器？\r\n\r\n- 隔离加载类\r\n- 修改类加载的方式\r\n- 扩展加载源\r\n- 防止源码泄漏\r\n\r\n用户自定义类加载器实现步骤：\r\n\r\n- 开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求\r\n- 在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass（）方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass（）方法，而是建议把自定义的类加载逻辑写在 findclass（）方法中\r\n- 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URIClassLoader 类，这样就可以避免自己去编写 findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。\r\n\r\n### 查看根加载器所能加载的目录\r\n\r\n刚刚我们通过概念了解到了，根加载器只能够加载 java /lib 目录下的 class，我们通过下面代码验证一下\r\n\r\n```java\r\npublic class ClassLoaderTest1 {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"*********启动类加载器************\");\r\n        // 获取 BootstrapClassLoader 能够加载的 API 的路径\r\n        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();\r\n        for (URL url : urls) {\r\n            System.out.println(url.toExternalForm());\r\n        }\r\n\r\n        // 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是 null，说明是  根加载器\r\n        ClassLoader classLoader = Provider.class.getClassLoader();\r\n        System.out.println(classLoader);\r\n    }\r\n}\r\n```\r\n\r\n得到的结果\r\n\r\n```\r\n*********启动类加载器************\r\nfile:/E:/Software/JDK1.8/Java/jre/lib/resources.jar\r\nfile:/E:/Software/JDK1.8/Java/jre/lib/rt.jar\r\nfile:/E:/Software/JDK1.8/Java/jre/lib/sunrsasign.jar\r\nfile:/E:/Software/JDK1.8/Java/jre/lib/jsse.jar\r\nfile:/E:/Software/JDK1.8/Java/jre/lib/jce.jar\r\nfile:/E:/Software/JDK1.8/Java/jre/lib/charsets.jar\r\nfile:/E:/Software/JDK1.8/Java/jre/lib/jfr.jar\r\nfile:/E:/Software/JDK1.8/Java/jre/classes\r\nnull\r\n```\r\n\r\n### 关于 ClassLoader\r\n\r\nClassLoader 类，它是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）\r\n\r\n![image-20230405145153051](./assets/image-20230405145153051.png)\r\n\r\nsun.misc.Launcher 它是一个 java 虚拟机的入口应用\r\n\r\n![image-20200705103636003](./assets/image-20230405145249091.png)\r\n\r\n获取 ClassLoader 的途径\r\n\r\n- 获取当前 ClassLoader：clazz.getClassLoader()\r\n- 获取当前线程上下文的 ClassLoader：Thread.currentThread().getContextClassLoader()\r\n- 获取系统的 ClassLoader：ClassLoader.getSystemClassLoader()\r\n- 获取调用者的 ClassLoader：DriverManager.getCallerClassLoader()\r\n\r\n### ⭐小总结\r\n\r\n类加载器是 Java 虚拟机的核心组件之一，它负责将 Java 类文件加载到内存中，并转换成 Java 类的对象。根据 Java 虚拟机规范的定义，类加载器被分为三种：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和系统类加载器（System ClassLoader）。\r\n\r\n1. 启动类加载器（Bootstrap ClassLoader）\r\n\r\n启动类加载器是 Java 虚拟机内置的类加载器，它负责加载 Java 平台核心库（如 rt.jar、charsets.jar 等）以及其他被虚拟机认为是基础的类，例如 java.lang.Object 等。启动类加载器是虚拟机的一部分，它不是 Java 类，因此没有相应的 Class 对象与之对应。\r\n\r\n1. 扩展类加载器（Extension ClassLoader）\r\n\r\n扩展类加载器负责加载 Java 平台扩展库中的类，例如 javax.* 等扩展包中的类。扩展类加载器是由启动类加载器加载的，它的父加载器是启动类加载器。扩展类加载器通常位于 jre/lib/ext 目录下。\r\n\r\n1. 系统类加载器（System ClassLoader）\r\n\r\n系统类加载器也称为应用类加载器，它负责加载应用程序的类。系统类加载器是由启动类加载器和扩展类加载器的子类加载的，它的父加载器是扩展类加载器。系统类加载器通常位于 classpath 路径下。\r\n\r\n除了上述三种标准的类加载器，Java 还支持自定义类加载器。自定义类加载器需要继承自 java.lang.ClassLoader 类，并覆盖其 findClass() 方法，以实现自己的类加载逻辑。自定义类加载器可以用于实现模块化、插件化等功能。\r\n\r\n## 双亲委派机制\r\n\r\nJava 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。\r\n\r\n### 工作原理\r\n\r\n- 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；\r\n- 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；\r\n- 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\r\n\r\n![image-20230405145826401](./assets/image-20230405145826401.png)\r\n\r\n### 双亲委派机制举例\r\n\r\n当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。\r\n\r\n![image-20230405145951680](./assets/image-20230405145951680.png)\r\n\r\n### 沙箱安全机制\r\n\r\n**自定义 string 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\\lang\\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。**\r\n\r\n### 双亲委派机制的优势\r\n\r\n通过上面的例子，我们可以知道，双亲机制可以\r\n\r\n- **避免类的重复加载**\r\n- **保护程序安全，防止核心 API 被随意篡改**\r\n  - **自定义类：java.lang.String**\r\n  - **自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）**\r\n\r\n## 其它内容\r\n\r\n###  如何判断两个 class 对象是否相同\r\n\r\n在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：\r\n\r\n- 类的完整类名必须一致，包括包名。\r\n- 加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。\r\n\r\n换句话说，在 JvM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。\r\n\r\nJVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。\r\n\r\n### 类的主动使用和被动使用\r\n\r\nJava 程序对类的使用方式分为：主动使用（主动加载）和被动使用（被动加载）。\r\n\r\n- 程序中使用了该类的实例化对象，或者使用了该类的静态成员变量或静态方法，这将触发该类的加载。\r\n- 通过反射机制动态加载类，例如通过 Class.forName() 方法或 ClassLoader 类的 loadClass() 方法。\r\n- 在一个类中继承了另一个类或实现了接口，子类或实现类需要在父类或接口中定义的所有类都被加载后才能被加载。\r\n- 启动 JVM 时需要加载的类，例如 java.lang.Object 和 java.lang.Class。\r\n- 使用 JVM 命令行参数-Xbootclasspath 指定的类。\r\n\r\n除了以上情况，其他使用 Java 类的方式都被看作是对类的被动使用，都不会导致类的初始化。\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/02.类加载子系统.md b/src/java/JVM/02.类加载子系统.md
--- a/src/java/JVM/02.类加载子系统.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/02.类加载子系统.md	(date 1682513038926)
@@ -1,12 +1,5 @@
 ---
-title: 类加载子系统
-date: 2023-04-05 07:25:52
-permalink: /pages/fe220d/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
 
 # 类加载子系统
Index: src/java/JVM/01.JVM 和 Java 体系架构.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: JVM 和 Java 体系架构\r\ndate: 2023-04-05 07:25:15\r\npermalink: /pages/bc7a42/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n\r\n# JVM 和 Java 体系架构\r\n\r\n## JVM 前言\r\n\r\n作为 Java 工程师的你曾被伤害过吗？你是否也遇到过这些问题？\r\n\r\n- 运行着的线上系统突然卡死，系统无法访问，甚至直接 OOM\r\n- 想解决线上 JVM GC 问题，但却无从下手\r\n- 新项目上线，对各种 JVM 参数设置一脸茫然，直接默认吧然后就 JJ 了\r\n- 每次面试之前都要重新背一遍 JVM 的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优 VM 参数，如何解决 GC、OOM 等问题，一脸懵逼\r\n\r\n![image-20230405074610203](./assets/image-20230405074610203.png)\r\n\r\n大部分 Java 开发人员，除会在项目中使用到与 Java 平台相关的各种高精尖技术，对于 Java 技术的核心 Java 虚拟机了解甚少。\r\n\r\n### 开发人员如何看待上层框架\r\n\r\n一些有一定工作经验的开发人员，打心眼儿里觉得 SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。\r\n\r\n如果我们把核心类库的 API 比做数学公式的话，那么 Java 虚拟机的知识就好比公式的推导过程。\r\n\r\n![image-20230405075133073](./assets/image-20230405075133073.png)\r\n\r\n计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言\r\n\r\n### 架构师每天都在思考什么？\r\n\r\n- 应该如何让我的系统更快？\r\n- 如何避免系统出现瓶颈？\r\n\r\n### 知乎上有条帖子：应该如何看招聘信息，直通年薪 50 万+？\r\n\r\n- 参与现有系统的性能优化，重构，保证平台性能和稳定性\r\n- 根据业务场景和需求，决定技术方向，做技术选型\r\n- 能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求\r\n- 解决各类潜在系统风险，核心功能的架构与代码编写\r\n- 分析系统瓶颈，解决各种疑难杂症，性能调优等\r\n\r\n### 为什么要学习 JVM\r\n\r\n- 面试的需要（BATJ、TMD，PKQ 等面试都爱问）\r\n- 中高级程序员必备技能\r\n  - 项目管理、调优的需求\r\n\r\n- 追求极客的精神\r\n  - 比如：垃圾回收算法、JIT（及时编译器）、底层原理\r\n\r\n### Java vs C++\r\n\r\n垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得 JVM 内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是 Java 工程师进阶的必备能力。\r\n\r\n![image-20230405080010567](./assets/image-20230405080010567.png)\r\n\r\nC 语言需要自己来分配内存和回收内存，Java 全部交给 JVM 进行分配和回收。\r\n\r\n### 推荐书籍\r\n\r\n![image-20230405080038658](./assets/image-20230405080038658.png)\r\n\r\n## Java 及 JVM 简介\r\n\r\n### Java 生态圈\r\n\r\nJava 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大 Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。\r\n\r\n- 作为一个平台，Java 虚拟机扮演着举足轻重的作用\r\n  - Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分\r\n\r\n- 作为灯种文化，Java 几乎成为了“开源”的代名词。\r\n  - 第三方开源软件和框架。如 Tomcat、Struts，MyBatis，Spring 等。\r\n  - 就连 JDK 和 JVM 自身也有不少开源的实现，如 openJDK、Harmony。\r\n- 作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众多也令人咋舌。\r\n\r\n![image-20230405080134528](./assets/image-20230405080134528.png)\r\n\r\n![image-20230405080143735](./assets/image-20230405080143735.png)\r\n\r\n随着 Java7 的正式发布，Java 虚拟机的设计者们通过 JSR-292 规范基本实现在 Java 虚拟机平台上运行非 Java 语言编写的程序。\r\n\r\nJava 虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说 Java 虚拟机拥有语言无关性，并不会单纯地与 Java 语言“终身绑定”，只要其他编程语言的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。\r\n\r\n### 字节码\r\n\r\n我们平时说的 java 字节码，指的是用 java 语言编译成的字节码。准确的说任何能在 jvm 平台上执行的字节码格式都是一样的。所以应该统称为：jvm 字节码。\r\n\r\n不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。\r\n\r\nJava 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式—Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。\r\n\r\n### 多语言混合编程\r\n\r\nJava 平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。\r\n\r\n试想一下，在一个项目之中，并行处理用 clojure 语言编写，展示层使用 JRuby/Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为它们最终都运行在一个虚拟机之上。\r\n\r\n对这些运行于 Java 虚拟机之上、Java 之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如 Da Vinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），推动 Java 虚拟机从“Java 语言的虚拟机”向“多语言虚拟机”的方向发展。\r\n\r\n### Java 发展的重大事件\r\n\r\n- 1990 年，在 Sun 计算机公司中，由 Patrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 oak，后期命名为 Java\r\n- 1995 年，Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。\r\n- 1996 年 1 月 23 日 sun Microsystems 发布了 JDK 1.0。\r\n- 1998 年，JDK1.2 版本发布。同时，sun 发布了 JSP/Servlet、EJB 规范，以及将 Java 分成了 J2EE、J2SE 和 J2ME。这表明了 Java 开始向企业、桌面应用和移动设备应用 3 大领域挺进。\r\n- 2000 年，JDK1.3 发布，Java HotSpot Virtual Machine 正式发布，成为 Java 的默认虚拟机。\r\n- 2002 年，JDK1.4 发布，古老的 Classic 虚拟机退出历史舞台。\r\n- 2003 年年底，Java 平台的 scala 正式发布，同年 Groovy 也加入了 Java 阵营。\r\n- 2004 年，JDK1.5 发布。同时 JDK1.5 改名为 JavaSE5.0。\r\n- 2006 年，JDK6 发布。同年，Java 开源并建立了 openJDK。顺理成章，Hotspot 虚拟机也成为了 openJDK 中的默认虚拟机。\r\n\r\n- 2007 年，Java 平台迎来了新伙伴 Clojure。\r\n- 2008 年，oracle 收购了 BEA，得到了 JRockit 虚拟机。\r\n- 2009 年，Twitter 宣布把后台大部分程序从 Ruby 迁移到 scala，这是 Java 平台的又一次大规模应用。\r\n- 2010 年，oracle 收购了 sun，获得 Java 商标和最真价值的 HotSpot 虚拟机。此时，oracle 拥有市场占用率最高的两款虚拟机 HotSpot 和 JRockit，并计划在未来对它们进行整合：HotRockit\r\n- 2011 年，JDK7 发布。在 JDK1.7u4 中，正式启用了新的垃圾回收器 G1。\r\n- 2017 年，JDK9 发布。将 G1 设置为默认 Gc，替代 CMS\r\n- 同年，IBM 的 J9 开源，形成了现在的 open J9 社区\r\n- 2018 年，Android 的 Java 侵权案判决，Google 赔偿 oracle 计 88 亿美元\r\n- 同年，oracle 宣告 JavagE 成为历史名词 JDBC、JMS、Servlet 赠予 Eclipse 基金会\r\n- 同年，JDK11 发布，LTS 版本的 JDK，发布革命性的 zGc，调整 JDK 授权许可\r\n- 2019 年，JDK12 发布，加入 RedHat 领导开发的 shenandoah GC\r\n\r\n![image-20230405080514934](./assets/image-20230405080514934.png)\r\n\r\n在 JDK11 之前，oracleJDK 中还会存在一些 openJDK 中没有的、闭源的功能。但在 JDK11 中，我们可以认为 openJDK 和 oracleJDK 代码实质上已经完全一致的程度。\r\n\r\n## 虚拟机与 Java 虚拟机\r\n\r\n### 虚拟机\r\n\r\n所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。\r\n\r\n- 大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。\r\n- 程序虚拟机的典型代表就是 Java 虚拟机，它专门为执行单个计算机程序而设计，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。\r\n\r\n无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。\r\n\r\n### Java 虚拟机\r\n\r\nJava 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。\r\n\r\nJVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。\r\n\r\nJava 技术的核心就是 Java 虚拟机（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机内部。\r\n\r\nJava 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。\r\n\r\n特点：\r\n\r\n- 一次编译，到处运行\r\n- 自动内存管理\r\n- 自动垃圾回收功能\r\n\r\n## JVM 的位置\r\n\r\nJVM 是运行在操作系统之上的，它与硬件没有直接的交互\r\n\r\n![image-20230405081233213](./assets/image-20230405081233213.png)\r\n\r\nJava 的体系结构\r\n\r\n![image-20230405081248522](./assets/image-20230405081248522.png)\r\n\r\n## JVM 整体结构\r\n\r\n- HotSpot VM 是目前市面上高性能虚拟机的代表作之一。\r\n- 它采用解释器与即时编译器并存的架构。\r\n- 在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C/C++程序一较高下的地步。\r\n\r\n![image-20230405081308481](./assets/image-20230405081308481.png)\r\n\r\n执行引擎包含三部分：解释器，及时编译器，垃圾回收器\r\n\r\n## Java 代码执行流程\r\n\r\n![image-20230405081639083](./assets/image-20230405081639083.png)\r\n\r\n只是能生成被 Java 虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了\r\n\r\n## JVM 的架构模型\r\n\r\nJava 编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：\r\n\r\n基于栈式架构的特点\r\n\r\n- 设计和实现更简单，适用于资源受限的系统\r\n- 避开了寄存器的分配难题：使用零地址指令方式分配\r\n- 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现\r\n- 不需要硬件支持，可移植性更好，更好实现跨平台\r\n\r\n基于寄存器架构的特点\r\n\r\n- 典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机\r\n- 指令集架构则完全依赖硬件，可移植性差\r\n- 性能优秀和执行更高效\r\n- 花费更少的指令去完成一项操作\r\n- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主\r\n\r\n### 举例\r\n\r\n同样执行 2+3 这种逻辑操作，其指令分别如下：\r\n\r\n基于栈的计算流程（以 Java 虚拟机为例）：\r\n\r\n```bash\r\niconst_2 //常量2入栈\r\nistore_1\r\niconst_3 // 常量3入栈\r\nistore_2\r\niload_1\r\niload_2\r\niadd //常量2/3出栈，执行相加\r\nistore_0 // 结果5入栈\r\n```\r\n\r\n而基于寄存器的计算流程\r\n\r\n```bash\r\nmov eax,2 //将eax寄存器的值设为1\r\nadd eax,3 //使eax寄存器的值加3\r\n```\r\n\r\n### 字节码反编译\r\n\r\n我们编写一个简单的代码，然后查看一下字节码的反编译后的结果\r\n\r\n```java\r\npublic class StackStruTest {\r\n    public static void main(String[] args) {\r\n        int i = 2;\r\n        int j = 3;\r\n        int k = i + j;\r\n    }\r\n}\r\n\r\n// E:\\IDEA-WorkSpace\\Java\\JVM\\01.JVM 和 Java 体系架构\\target\\classes\\com\\cj>\r\n// javap -v StackStruTest.class\r\n```\r\n\r\n然后我们找到编译后的 class 文件，使用下列命令进行反编译\r\n\r\n```bash\r\njavap -v StackStruTest.class\r\n```\r\n\r\n得到的文件为：\r\n\r\n```java\r\n{\r\n  public com.cj.StackStruTest();\r\n    descriptor: ()V\r\n    flags: (0x0001) ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=1, args_size=1\r\n         0: aload_0\r\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\r\n         4: return\r\n      LineNumberTable:\r\n        line 3: 0\r\n      LocalVariableTable:\r\n        Start  Length  Slot  Name   Signature\r\n            0       5     0  this   Lcom/cj/StackStruTest;\r\n\r\n  public static void main(java.lang.String[]);\r\n    descriptor: ([Ljava/lang/String;)V\r\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\r\n    Code:\r\n      stack=2, locals=4, args_size=1\r\n         0: iconst_2\r\n         1: istore_1\r\n         2: iconst_3\r\n         3: istore_2\r\n         4: iload_1\r\n         5: iload_2\r\n         6: iadd\r\n         7: istore_3\r\n         8: return\r\n      LineNumberTable:\r\n        line 5: 0\r\n        line 6: 2\r\n        line 7: 4\r\n        line 8: 8\r\n      LocalVariableTable:\r\n        Start  Length  Slot  Name   Signature\r\n            0       9     0  args   [Ljava/lang/String;\r\n            2       7     1     i   I\r\n            4       5     2     j   I\r\n            8       1     3     k   I\r\n}\r\n```\r\n\r\n### 栈\r\n\r\n- 跨平台性\r\n- 指令集小\r\n- 指令多\r\n- 执行性能比寄存器差\r\n\r\n### 小总结\r\n\r\n由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。\r\n\r\n时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说应该是 HotSpotVM 的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？\r\n\r\n## JVM 生命周期\r\n\r\n### 虚拟机的启动\r\n\r\nJava 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。\r\n\r\n### 虚拟机的执行\r\n\r\n- 一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序\r\n- 程序开始执行时他才运行，程序结束时他就停止\r\n- 执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程\r\n\r\n### 虚拟机的退出\r\n\r\n有如下的几种情况：\r\n\r\n- 程序正常执行结束\r\n\r\n- 程序在执行过程中遇到了异常或错误而异常终止\r\n- 由于操作系统用现错误而导致 Java 虚拟机进程终止\r\n- 某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。\r\n- 除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。\r\n\r\n## JVM 发展历程\r\n\r\n### Sun Classic VM\r\n\r\n- 早在 1996 年 Java1.0 版本的时候，Sun 公司发布了一款名为 sun classic VM 的 Java 虚拟机，它同时也是世界上第一款商用 Java 虚拟机，JDK1.4 时完全被淘汰。\r\n- 这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。\r\n- 如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。\r\n- 现在 hotspot 内置了此虚拟机。\r\n\r\n### Exact VM\r\n\r\n为了解决上一个虚拟机问题，jdk1.2 时，sun 提供了此虚拟机。\r\nExact Memory Management：准确式内存管理\r\n\r\n- 也可以叫Non-Conservative/Accurate Memory Management\r\n- 虚拟机可以知道内存中某个位置的数据具体是什么类型。|\r\n\r\n具备现代高性能虚拟机的维形\r\n\r\n- 热点探测（寻找出热点代码进行缓存）\r\n- 编译器与解释器混合工作模式\r\n\r\n只在 solaris 平台短暂使用，其他平台上还是 classic vm，英雄气短，终被 Hotspot 虚拟机替换\r\n\r\n### ⭐HotSpot VM\r\n\r\nHotSpot 历史\r\n\r\n- 最初由一家名为“Longview Technologies”的小公司设计\r\n- 1997 年，此公司被 sun 收购；2009 年，Sun 公司被甲骨文收购。\r\n- JDK1.3 时，HotSpot VM 成为默认虚拟机\r\n\r\n目前 Hotspot 占有绝对的市场地位，称霸武林。\r\n\r\n- 不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是 HotSpot\r\n- Sun/oracle JDK 和 openJDK 的默认虚拟机\r\n- 因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 Gc 机制。（比如其他两个商用虚机都没有方法区的概念）\r\n\r\n从服务器、桌面到移动端、嵌入式都有应用。\r\n\r\n名称中的 HotSpot 指的就是它的热点代码探测技术。\r\n\r\n- 通过计数器找到最具编译价值代码，触发即时编译或栈上替换\r\n- 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡\r\n\r\n### JRockit\r\n\r\n专注于服务器端应用\r\n\r\n- 它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。\r\n\r\n大量的行业基准测试显示，JRockit JVM 是世界上最快的 JVM。\r\n\r\n- 使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。\r\n\r\n优势：全面的 Java 运行时解决方案组合\r\n\r\n- JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要\r\n- MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。\r\n\r\n2008 年，JRockit 被 oracle 收购。\r\n\r\noracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。\r\n\r\n高斯林：目前就职于谷歌，研究人工智能和水下机器人\r\n\r\n### IBM 的 J9\r\n\r\n全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9\r\n\r\n市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM 广泛用于 IBM 的各种 Java 产品。\r\n\r\n目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机。\r\n\r\n2017 年左右，IBM 发布了开源 J9VM，命名为 openJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9\r\n\r\nOpenJDK   -> 是 JDK 开源了，包括了虚拟机\r\n\r\n### KVM 和 CDC / CLDC  Hotspot\r\n\r\noracle 在 Java ME 产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是 CLDC-HI 早期产品目前移动领域地位尴尬，智能机被 Angroid 和 ioS 二分天下。\r\n\r\nKVM 简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场\r\n\r\n- 智能控制器、传感器\r\n- 老人手机、经济欠发达地区的功能手机\r\n\r\n所有的虚拟机的原则：一次编译，到处运行。\r\n\r\n### Azul VM\r\n\r\n前面三大“高性能 Java 虚拟机”使用在通用硬件平台上这里 Azu1VW 和 BEALiquid VM 是与特定硬件平台绑定、软硬件配合的专有虚拟机 I\r\n\r\n- 高性能 Java 虚拟机中的战斗机。\r\n\r\nAzul VM 是 Azu1Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 ava 虚拟机。\r\n\r\n每个 Azu1VM 实例都可以管理至少数十个 CPU 和数百 GB 内存的硬件资源，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。\r\n\r\n2010 年，AzulSystems 公司开始从硬件转向软件，发布了自己的 zing JVM，可以在通用 x86 平台上提供接近于 Vega 系统的特性。\r\n\r\n### Liquid VM\r\n\r\n高性能 Java 虚拟机中的战斗机。\r\n\r\nBEA 公司开发的，直接运行在自家 Hypervisor 系统上 Liquid VM 即是现在的 JRockit VE（Virtual Edition），\r\n\r\nLiquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。\r\n\r\n随着 JRockit 虚拟机终止开发，Liquid vM 项目也停止了。\r\n\r\n### Apache Marmony\r\n\r\nApache 也曾经推出过与 JDK1.5 和 JDK1.6 兼容的 Java 运行平台 Apache Harmony。\r\n\r\n它是 IElf 和 Inte1 联合开发的开源 JVM，受到同样开源的 openJDK 的压制，Sun 坚决不让 Harmony 获得 JCP 认证，最终于 2011 年退役，IBM 转而参与 OpenJDK\r\n\r\n虽然目前并没有 Apache Harmony 被大规模商用的案例，但是它的 Java 类库代码吸纳进了 Android SDK。\r\n\r\n### Micorsoft JVM\r\n\r\n微软为了在 IE3 浏览器中支持 Java Applets，开发了 Microsoft JVM。\r\n\r\n只能在 window 平台下运行。但确是当时 Windows 下性能最好的 Java VM。\r\n\r\n1997 年，sun 以侵犯商标、不正当竞争罪名指控微软成功，赔了 sun 很多钱。微软 windowsXPSP3 中抹掉了其 VM。现在 windows 上安装的 jdk 都是 HotSpot。\r\n\r\n### Taobao JVM\r\n\r\n由 AliJVM 团队发布。阿里，国内使用 Java 最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。\r\n\r\n基于 openJDK 开发了自己的定制版本 AlibabaJDK，简称 AJDK。是整个阿里 Java 体系的基石。\r\n\r\n基于 openJDK Hotspot VM 发布的国内第一个优化、深度定制且开源的高性能服务器版 Java 虚拟机。\r\n\r\n- 创新的 GCIH（GCinvisible heap）技术实现了 off-heap，即将生命周期较长的 Java 对象从 heap 中移到 heap 之外，并且 Gc 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 Gc 的回收效率的目的。\r\n- GCIH 中的对象还能够在多个 Java 虚拟机进程中实现共享\r\n- 使用 crc32 指令实现 JvM intrinsic 降低 JNI 的调用开销\r\n- PMU hardware 的 Java profiling tool 和诊断协助功能\r\n- 针对大数据场景的 ZenGc \r\n\r\ntaobao vm 应用在阿里产品上性能高，硬件严重依赖 inte1 的 cpu，损失了兼容性，但提高了性能\r\n\r\n目前已经在淘宝、天猫上线，把 oracle 官方 JvM 版本全部替换了。\r\n\r\n### Dalvik VM\r\n\r\n谷歌开发的，应用于 Android 系统，并在 Android2.2 中提供了 JIT，发展迅猛。\r\n\r\nDalvik y 只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循 Java 虚拟机规范\r\n\r\n不能直接执行 Java 的 Class 文件\r\n\r\n基于寄存器架构，不是 jvm 的栈架构。\r\n\r\n执行的是编译以后的 dex（Dalvik Executable）文件。执行效率比较高。\r\n\r\n- 它执行的 dex（Dalvik Executable）文件可以通过 class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等。\r\n\r\nAndroid 5.0 使用支持提前编译（Ahead of Time Compilation，AoT）的 ART VM 替换 Dalvik VM。\r\n\r\n### Graal VM\r\n\r\n2018 年 4 月，oracle Labs 公开了 GraalvM，号称 \"Run Programs Faster Anywhere\"，勃勃野心。与 1995 年 java 的”write once，run anywhere\"遥相呼应。\r\n\r\nGraalVM 在 HotSpot VM 基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”\r\n的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R 等\r\n\r\n支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件\r\n\r\n工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。Graal VM 提供 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。\r\n\r\n如果说 HotSpot 有一天真的被取代，Graalvm 希望最大。但是 Java 的软件生态没有丝毫变化。\r\n\r\n### 小总结\r\n\r\n具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 oracle HotSpot VM 为默认虚拟机。\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/01.JVM 和 Java 体系架构.md b/src/java/JVM/01.JVM 和 Java 体系架构.md
--- a/src/java/JVM/01.JVM 和 Java 体系架构.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/01.JVM 和 Java 体系架构.md	(date 1682513036093)
@@ -1,12 +1,5 @@
 ---
-title: JVM 和 Java 体系架构
-date: 2023-04-05 07:25:15
-permalink: /pages/bc7a42/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
 
 # JVM 和 Java 体系架构
Index: src/java/JVM/16.垃圾回收器.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 垃圾回收器\r\ndate: 2023-04-05 07:29:42\r\npermalink: /pages/dc8d6a/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/16.垃圾回收器.md b/src/java/JVM/16.垃圾回收器.md
--- a/src/java/JVM/16.垃圾回收器.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/16.垃圾回收器.md	(date 1682513069844)
@@ -1,10 +1,3 @@
 ---
-title: 垃圾回收器
-date: 2023-04-05 07:29:42
-permalink: /pages/dc8d6a/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
Index: src/java/JVM/15.垃圾回收相关概念.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 垃圾回收相关概念\r\ndate: 2023-04-05 07:29:32\r\npermalink: /pages/a4fc73/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/15.垃圾回收相关概念.md b/src/java/JVM/15.垃圾回收相关概念.md
--- a/src/java/JVM/15.垃圾回收相关概念.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/15.垃圾回收相关概念.md	(date 1682513065343)
@@ -1,10 +1,3 @@
 ---
-title: 垃圾回收相关概念
-date: 2023-04-05 07:29:32
-permalink: /pages/a4fc73/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
Index: src/java/JVM/12.StringTable.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: StringTable\r\ndate: 2023-04-05 07:29:02\r\npermalink: /pages/a27774/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n\r\n# StringTable\r\n\r\n## String 的基本特性\r\n\r\n1. String：字符串，使用一对“”引起来表示\r\n\r\n   ```java\r\n   String s1 = \"atguigu\";   \t\t\t// 字面量的定义方式\r\n   String s2 = new String(\"hello\");     // new 对象的方式\r\n   ```\r\n\r\n2. String 被声明为 final 的，不可被继承\r\n\r\n3. String 实现了 Serializable 接口：表示字符串是支持序列化的。实现了 Comparable 接口：表示 String 可以比较大小\r\n\r\n4. String 在 jdk8 及以前内部定义了`final char value[]`用于存储字符串数据。JDK9 时改为`byte[]`\r\n\r\n## 为什么 JDK9 改变了 String 的结构\r\n\r\n> **官方文档**：http://openjdk.java.net/jeps/254\r\n\r\n### 为什么改为 byte[] 存储？\r\n\r\n1. String 类的当前实现将字符存储在 char 数组中，每个字符使用两个字节 (16 位)\r\n2. 从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部 char 数组中有一半的空间将不会使用，产生了大量浪费\r\n3. 之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组外加一个编码标识存储。该编码表示如果你的字符是 ISO-8859-1 或者 Latin-1，那么只需要一个字节存。如果你是其它字符集，比如 UTF-8，你仍然用两个字节存\r\n4. 结论：String 再也不用 char[] 来存储了，改成了 byte [] 加上编码标记，节约了一些空间\r\n5. 同时基于 String 的数据结构，例如 StringBuffer 和 StringBuilder 也同样做了修改\r\n\r\n```java\r\n// 之前\r\nprivate final char value[];\r\n// 之后\r\nprivate final byte[] value\r\n```\r\n\r\n## String 的基本特性\r\n\r\n- String：代表不可变的字符序列。简称：不可变性。\r\n- 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。\r\n- 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。\r\n- 当调用 String 的 replace() 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。\r\n- 通过字面量的方式（区别于 new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。\r\n\r\n```java\r\n@Test\r\npublic void test1() {\r\n   String s1 = \"abc\";//字面量定义的方式，\"abc\"存储在字符串常量池中\r\n   String s2 = \"abc\";\r\n   s1 = \"hello\";\r\n\r\n   System.out.println(s1 == s2);//判断地址：true  --> false\r\n\r\n   System.out.println(s1);//\r\n   System.out.println(s2);//abc\r\n\r\n}\r\n```\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/12.StringTable.md b/src/java/JVM/12.StringTable.md
--- a/src/java/JVM/12.StringTable.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/12.StringTable.md	(date 1682513061048)
@@ -1,12 +1,5 @@
 ---
-title: StringTable
-date: 2023-04-05 07:29:02
-permalink: /pages/a27774/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
 
 # StringTable
Index: src/java/JVM/11.执行引擎.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 执行引擎\r\ndate: 2023-04-05 07:28:52\r\npermalink: /pages/74dd0d/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/11.执行引擎.md b/src/java/JVM/11.执行引擎.md
--- a/src/java/JVM/11.执行引擎.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/11.执行引擎.md	(date 1682513056921)
@@ -1,10 +1,3 @@
 ---
-title: 执行引擎
-date: 2023-04-05 07:28:52
-permalink: /pages/74dd0d/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
Index: src/java/JVM/14.垃圾回收相关算法.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 垃圾回收相关算法\r\ndate: 2023-04-05 07:29:23\r\npermalink: /pages/ac41e3/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/14.垃圾回收相关算法.md b/src/java/JVM/14.垃圾回收相关算法.md
--- a/src/java/JVM/14.垃圾回收相关算法.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/14.垃圾回收相关算法.md	(date 1682513064051)
@@ -1,10 +1,3 @@
 ---
-title: 垃圾回收相关算法
-date: 2023-04-05 07:29:23
-permalink: /pages/ac41e3/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
Index: src/java/JVM/13.垃圾回收概述.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 垃圾回收概述\r\ndate: 2023-04-05 07:29:10\r\npermalink: /pages/80e105/\r\ncategories:\r\n  - Java\r\n  - JVM\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JVM/13.垃圾回收概述.md b/src/java/JVM/13.垃圾回收概述.md
--- a/src/java/JVM/13.垃圾回收概述.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JVM/13.垃圾回收概述.md	(date 1682513062538)
@@ -1,10 +1,3 @@
 ---
-title: 垃圾回收概述
-date: 2023-04-05 07:29:10
-permalink: /pages/80e105/
-categories:
-  - Java
-  - JVM
-tags:
-  - 
+
 ---
Index: src/java/JUC/05.Java 内存模型 JMM.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Java 内存模型 JMM\r\ndate: 2023-04-17 20:20:38\r\npermalink: /pages/9ff804/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n\r\n###  JAVA内存模型（JMM）\r\n\r\nCPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题。\r\n\r\nJVM规范中试图定义一种Java内存模型(java Memory Model，简称JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。\r\n\r\nJMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。\r\n\r\n**作用：**\r\n\r\n通过JMM来实现线程和主内存之间的抽象关系。 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。\r\n\r\n#### 三大特性\r\n\r\n**可见性**\r\n\r\n是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在主内存中。\r\n\r\n**原子性**\r\n\r\n指一个操作是不可打断的，即多线程环境下，操作不能被其他线程干扰。\r\n\r\n**有序性**\r\n\r\n指令重排\r\n\r\nJVM能根据处理器特性(CPU多 级缓存系统、多核处理器等)适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。但是，指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致(即可能产生\"脏读\")， 简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条， 不见得是从上到下顺序执行，执行顺序会被优化。\r\n\r\n![img](./assets/images_20221017191551.png)\r\n\r\n#### 多线程对变量的读写过程\r\n\r\n(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:\r\n\r\n![img](./assets/images_20221017192450.png)\r\n\r\n#### 先行发生原则\r\n\r\n**happens-before**\r\n\r\n在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者代码重排序，那么这两个操作之间必须存在happens-before(先行发生)原则。\r\n\r\n如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。 如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。\r\n\r\n**八条**\r\n\r\n- 次序规则\r\n\r\n  前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1。\r\n\r\n- 锁定规则\r\n\r\n  一个unLock操作先行发生于后面 (这里的“后面”是指时间上的先后) 对同一个锁的Iock操作。\r\n\r\n- volatile变量规则\r\n\r\n  对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的”后面\"同样是指时间上的先后。\r\n\r\n- 传递规则\r\n\r\n  如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C;\r\n\r\n- 线程启动规则（Thread Start Rule）\r\n\r\n  Thread对象的start()方法先行发生于此线程的每一个动作\r\n\r\n- 线程中断规则(Thread Interruption Rule)\r\n\r\n  对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 可以通过Thread.interrupted()检测到是否发生中断 也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发送。\r\n\r\n- 线程终止规则(Thread Termination Rule)\r\n\r\n  线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行。\r\n\r\n- 对象终结规则(Finalizer Rule)\r\n\r\n  一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/05.Java 内存模型 JMM.md b/src/java/JUC/05.Java 内存模型 JMM.md
--- a/src/java/JUC/05.Java 内存模型 JMM.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/05.Java 内存模型 JMM.md	(date 1682513019623)
@@ -1,12 +1,5 @@
 ---
-title: Java 内存模型 JMM
-date: 2023-04-17 20:20:38
-permalink: /pages/9ff804/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 
 ###  JAVA内存模型（JMM）
Index: src/java/JUC/04.LockSupport 与线程中断.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: LockSupport 与线程中断\r\ndate: 2023-04-17 20:20:28\r\npermalink: /pages/5b6bd3/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n\r\n###  LockSupport\r\n\r\n线程的等待和唤醒\r\n\r\n- 使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程，使用必须持有锁\r\n\r\n```\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Object obj = new Object();\r\n        new Thread(() -> {\r\n            synchronized (obj) {\r\n                System.out.println(Thread.currentThread().getName() + \"\\t-------come in\");\r\n                try {\r\n                    obj.wait();//释放了锁？？？\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(Thread.currentThread().getName() + \"\\t-------waked\");\r\n            }\r\n        }, \"t1\").start();\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        new Thread(() -> {\r\n            synchronized (obj) {\r\n                obj.notify();\r\n                System.out.println(Thread.currentThread().getName() + \"\\t-------notify\");\r\n            }\r\n        }, \"t2\").start();\r\n    }\r\n}\r\n//wait 须在 notify前面\r\n```\r\n\r\n- 使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程，使用必须持有锁\r\n\r\n```\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Lock lock = new ReentrantLock();\r\n        Condition condition = lock.newCondition();\r\n        new Thread(() -> {\r\n            lock.lock();\r\n            System.out.println(Thread.currentThread().getName() + \"\\t-------come in\");\r\n            try {\r\n                condition.await();\r\n                System.out.println(Thread.currentThread().getName() + \"\\t-------waked\");\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        }, \"t1\").start();\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        new Thread(() -> {\r\n            lock.lock();\r\n            condition.signal();\r\n            System.out.println(Thread.currentThread().getName() + \"\\t-------notify\");\r\n            lock.unlock();\r\n        }, \"t2\").start();\r\n    }\r\n}\r\n//先await() 后signal\r\n```\r\n\r\n- LockSupport类可以park阻塞当前线程以及unpark唤醒指定被阻塞的线程，\r\n\r\n```\r\n//park unpark 无顺序要求。因为park发了许可证，线程没使用，会保留，许可证不会积累，最多只有一个\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Thread t1 = new Thread(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"\\t-------come in\");\r\n            LockSupport.park();\r\n            System.out.println(Thread.currentThread().getName() + \"\\t-------waked\");\r\n        }, \"t1\");\r\n        t1.start();\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        new Thread(() -> {\r\n            LockSupport.unpark(t1);\r\n            System.out.println(Thread.currentThread().getName() + \"\\t-------notify\");\r\n        }, \"t2\").start();\r\n    }\r\n}\r\n```\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/04.LockSupport 与线程中断.md b/src/java/JUC/04.LockSupport 与线程中断.md
--- a/src/java/JUC/04.LockSupport 与线程中断.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/04.LockSupport 与线程中断.md	(date 1682513018739)
@@ -1,12 +1,5 @@
 ---
-title: LockSupport 与线程中断
-date: 2023-04-17 20:20:28
-permalink: /pages/5b6bd3/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 
 ###  LockSupport
Index: src/java/JUC/07.CAS.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: CAS\r\ndate: 2023-04-17 20:21:07\r\npermalink: /pages/0c7089/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n\r\n###  CAS\r\n\r\ncompare and swap的缩写，中文翻译成比较并交换，实现并发算法时常用到的一种技术。 它包含三个操作数一一内存位置、预期原值及更新值。 执行CAS操作的时候，将内存位置的值与预期原值比较:（类似乐观锁） 如果相匹配，那么处理器会自动将该位置值更新为新值。 如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。\r\n\r\nCAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较更新的原子性。 它是非阻塞的且自身具有原子性，也就是说这玩意效率更高且通过硬件保证，说明这玩意更可靠。 **CAS是一条CPU的原子指令**(cmpxchg指令)，不会造成所谓的数据不一致问题，Unsafe提供的 CAS方法(如compareAndSwapXXX)底层实现即为CPU指令cmpxchg。 执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现独占的，比起用synchronized重量级锁，这里的排他时间要短很多，所以在多线程情况下性能会比较好。\r\n\r\n#### 原子引用\r\n\r\n```\r\n@AllArgsConstructor\r\n@Data\r\nclass User {\r\n    String username;\r\n    int age;\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        AtomicReference<User> atomicReference = new AtomicReference<>();\r\n        User tom = new User(\"tom\", 22);\r\n        User cat = new User(\"cat\", 22);\r\n        atomicReference.set(tom);\r\n        System.out.println(atomicReference.compareAndSet(tom, cat) + \"\\t\" + atomicReference.get().toString());\r\n        System.out.println(atomicReference.compareAndSet(tom, cat) + \"\\t\" + atomicReference.get().toString());\r\n    }\r\n}\r\n```\r\n\r\n#### 自旋锁\r\n\r\nCAS是实现自旋锁的基础，CAS 利用CPU指令保证了操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转。是指尝试获取锁的线程不会立即阻寒，而是采用循环的方式去尝试获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。\r\n\r\n```\r\n//实现自旋锁\r\npublic class JucTest {\r\n    AtomicReference<Thread> atomicReference = new AtomicReference<>();\r\n    public void lock() {\r\n        Thread thread = Thread.currentThread();\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"come in\");\r\n        while (!atomicReference.compareAndSet(null, thread)) {\r\n\r\n        }\r\n    }\r\n    public void unLock() {\r\n        Thread thread = Thread.currentThread();\r\n        atomicReference.compareAndSet(thread, null);\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"task over, unLock\");\r\n    }\r\n    public static void main(String[] args) {\r\n        JucTest jucTest = new JucTest();\r\n        new Thread(() -> {\r\n            jucTest.lock();\r\n            try {\r\n                TimeUnit.SECONDS.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            jucTest.unLock();\r\n        }, \"A\").start();\r\n        //保证A先于B\r\n        try {\r\n            TimeUnit.MICROSECONDS.sleep(500);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        new Thread(() -> {\r\n            jucTest.lock();\r\n            jucTest.unLock();\r\n        }, \"B\").start();\r\n    }\r\n}\r\n```\r\n\r\n#### 缺点\r\n\r\n- 空轮询，CPU消耗大\r\n- ABA问题\r\n\r\n#### AtomicStampedReference\r\n\r\n```\r\n//该类可以添加版本号 避免ABA问题\r\n@AllArgsConstructor\r\n@Data\r\nclass Book {\r\n    private int id;\r\n    private String bookName;\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Book javaBook = new Book(1, \"javaBook\");\r\n        AtomicStampedReference<Book> stampedReference = new AtomicStampedReference<>(javaBook, 1);\r\n        System.out.println(stampedReference.getReference() + \"\\t\" + stampedReference.getStamp());\r\n        Book mysqlBook = new Book(2, \"mysqlBook\");\r\n        boolean b = stampedReference.compareAndSet(\r\n                javaBook,\r\n                mysqlBook,\r\n                stampedReference.getStamp(),\r\n                stampedReference.getStamp() + 1);\r\n        System.out.println(b + \"\\t\" + stampedReference.getReference() + \"\\t\" + stampedReference.getStamp());\r\n        b = stampedReference.compareAndSet(\r\n                mysqlBook,\r\n                javaBook,\r\n                stampedReference.getStamp(),\r\n                stampedReference.getStamp() + 1);\r\n        System.out.println(b + \"\\t\" + stampedReference.getReference() + \"\\t\" + stampedReference.getStamp());\r\n    }\r\n}\r\n```\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/07.CAS.md b/src/java/JUC/07.CAS.md
--- a/src/java/JUC/07.CAS.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/07.CAS.md	(date 1682513022175)
@@ -1,12 +1,5 @@
 ---
-title: CAS
-date: 2023-04-17 20:21:07
-permalink: /pages/0c7089/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 
 ###  CAS
Index: src/java/JUC/06.volatile 与 JMM.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: volatile 与 JMM\r\ndate: 2023-04-17 20:20:59\r\npermalink: /pages/bd4c00/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n\r\n###  volatile\r\n\r\n满足：可见性，有序性（禁重排）\r\n\r\n可见性：保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见。\r\n\r\n当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中，并及时发出通知，大家可以去主内存拿最新版，前面的修改对后面所有线程可见。 当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。\r\n\r\n怎么保证可见性，有序性：**内存屏障**\r\n\r\n#### 内存屏障\r\n\r\n内存屏障(也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作)，避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性(禁重排)，但volatile无法保证原 子性。\r\n\r\n**内存屏障之前**的所有写操作都要回写到主内存，\r\n\r\n**内存屏障之后**的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。\r\n\r\n**写屏障**( Store Memory Barrier) ：告诉处理器在写屏障之前将所有存储在缓存(store bufferes)中的数据同步到主内存。也就是说当看到Store屏障指令，就必须把该指令之前所有写入指令执行完毕才能继续往下执行。在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中。\r\n\r\n**读屏障**(Load Memory Barrier)：处理器在读屏障之后的读操作，都在读屏障之后执行。也就是说在Load屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。即在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据。\r\n\r\n#### 四大屏障\r\n\r\n| 屏障类型   | 指令示例                   | 说明                                                         |\r\n| ---------- | -------------------------- | ------------------------------------------------------------ |\r\n| LoadLoad   | Load1; LoadLoad; Load2     | 保证load1的读取操作在load2及后续读取操作之前执行             |\r\n| StoreStore | Store1; StoreStore; Store2 | 在store2及其后的写操作执行前， 保证store1的写操作已刷新到主内存 |\r\n| LoadStore  | Load1; LoadStore; Store2   | 在stroe2及其后的写操作执行前， 保证load1的读操作已读取结束   |\r\n| StoreLoad  | Store1; StoreLoad; Load2   | 保证store1的写操作已刷新到主内存之 后，load2及 其后的读操作才能执行 |\r\n\r\n```\r\npublic class JucTest {\r\n    //static boolean flag = true;\r\n    static volatile boolean flag = true;\r\n    public static void main(String[] args) {\r\n\r\n        Thread t1 = new Thread(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"\\t-------come in\");\r\n            while (flag);\r\n            System.out.println(Thread.currentThread().getName() + \"\\t-------out\");\r\n        }, \"t1\");\r\n        t1.start();\r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        flag = false;\r\n        System.out.println(\"修改完成\");\r\n    }\r\n}\r\n```\r\n\r\n1.主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。 2.主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值， 没有去主内存中更新获取flag最新的值。\r\n\r\n上述原因需要volatile解决\r\n\r\n**volatile没有原子性：**\r\n\r\n对于volatile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，也仅是数据加载时是最新的。但是多线程环境下，\"数据计算\"和\"数据赋值\"操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存中的操作将会作废去读主内存最新值，操作出现写丢失问题。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须使用加锁同步。\r\n\r\n如：i++\r\n\r\n**volatile可以禁重排**\r\n\r\n数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。\r\n\r\n不存在数据依赖关系，可以重排序。\r\n\r\n#### volatile使用场景\r\n\r\n- 单一赋值\r\n- 布尔状态标志，判断业务是否结束\r\n- 开销较低的读，写策略\r\n- DCL双端锁的发布\r\n\r\n```\r\n//单列模式\r\nclass SafeDoubleCheckSingleton {\r\n    //private static SafeDoubleCheckSingleton singleton;\r\n    private volatile static SafeDoubleCheckSingleton singleton;//解决下面隐患\r\n    private SafeDoubleCheckSingleton(){}\r\n    //双重锁设计\r\n    public static SafeDoubleCheckSingleton getInstance() {\r\n        if (singleton == null) {\r\n            synchronized (SafeDoubleCheckSingleton.class) {\r\n                if (singleton == null) {\r\n                    //隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取\r\n                    //1.分配内存\r\n                    //2.初始化对象\r\n                    //3.指向内存\r\n                    singleton = new SafeDoubleCheckSingleton();\r\n                }\r\n            }\r\n        }\r\n        return singleton;\r\n    }\r\n}\r\n```\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/06.volatile 与 JMM.md b/src/java/JUC/06.volatile 与 JMM.md
--- a/src/java/JUC/06.volatile 与 JMM.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/06.volatile 与 JMM.md	(date 1682513020758)
@@ -1,12 +1,5 @@
 ---
-title: volatile 与 JMM
-date: 2023-04-17 20:20:59
-permalink: /pages/bd4c00/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 
 ###  volatile
Index: src/java/JUC/01.线程基础知识复习.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 线程基础知识复习\r\ndate: 2023-04-17 20:14:00\r\npermalink: /pages/a87bc5/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n# 线程基础知识复习\r\n\r\n## JUC 是什么？\r\n\r\n### JUC 包设计开发者\r\n\r\n![image-20230417202735135](./assets/image-20230417202735135.png)\r\n\r\n### JUC 工具包\r\n\r\n`java.util.concurrent` 在 **并发编程** 中使用的工具包\r\n\r\n![image-20230417204700946](./assets/image-20230417204700946.png)\r\n\r\n## 为什么学习并用好多线程极其重要\r\n\r\n### 硬件方面\r\n\r\n#### 摩尔定律失效\r\n\r\n它是由英特尔创始人之一 Gordon Moore(戈登·摩尔) 提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目约每隔 18-24 个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔 18-24 个月翻一倍以上。这一定律揭示了信息技术进步的速度。可是从 2003 年开始 CPU 主频已经不再翻倍，而是采用多核而不是更快的主频。摩尔定律失效了，在主频不再提高且核数在不断增加的情况下，要想让程序更快就要用到并行或并发编程。\r\n\r\n### 软件方面\r\n\r\n- 面试 B 格可以高一点点\r\n- 充分利用多核处理器\r\n- 提高程序性能，高并发系统\r\n- 提高程序吞吐量，异步 + 回调等生产需求\r\n\r\n### 弊端及问题\r\n\r\n- 线程安全性问题\r\n  - i++\r\n  - 集合类安全否\r\n- 线程锁问题\r\n- 线程性能问题\r\n\r\n## 从 start 一个线程说起\r\n\r\n### start() 方法源码分析\r\n\r\n```java\r\npublic static void main(String[] args){\r\n\tThread t1 = new Thread(() -> {}，\"t1\");\r\n\tt1.start();\r\n}\r\n```\r\n\r\n```java\r\n// start 方法源码\r\npublic synchronized void start() {\r\n    /**\r\n     * This method is not invoked for the main method thread or \"system\"\r\n     * group threads created/set up by the VM. Any new functionality added\r\n     * to this method in the future may have to also be added to the VM.\r\n     *\r\n     * A zero status value corresponds to state \"NEW\".\r\n     */\r\n    if (threadStatus != 0)\r\n        throw new IllegalThreadStateException();\r\n\r\n    /* Notify the group that this thread is about to be started\r\n     * so that it can be added to the group's list of threads\r\n     * and the group's unstarted count can be decremented. */\r\n    group.add(this);\r\n\r\n    boolean started = false;\r\n    try {\r\n        // 重点调用了此处的方法\r\n        // private native void start0();//start0 是一个 native 方法\r\n        start0(); \r\n        started = true;\r\n    } finally {\r\n        try {\r\n            if (!started) {\r\n                group.threadStartFailed(this);\r\n            }\r\n        } catch (Throwable ignore) {\r\n            /* do nothing. If start0 threw a Throwable then\r\n              it will be passed up the call stack */\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> `native`调用的是本地方法，我们可以通过下载官网的 OpenJDK 查看其源码\r\n\r\n### Java 线程理解以及 openjdk 中的实现\r\n\r\n`private native void starto();`\r\n\r\nJava 语言本身底层就是 C++语言\r\n\r\nOpenJDK 源码网址：[https://openjdk.org/](https://openjdk.org/)\r\n\r\n### 更加底层的 C++源码解读\r\n\r\n- `openjdk8\\jdk\\src\\share\\native\\java\\lang` `thread.c`\r\n- `openjdk8\\hotspot\\src\\sharelvm\\prims ` `jvm.cpp`\r\n- `openjdk8\\hotspot\\src\\share\\vm\\runtime` `thread.cpp`\r\n\r\n#### thread.c\r\n\r\n- java 线程是通过 start 的方法启动执行的，主要内容在 native 方法 start0 中\r\n- openjdk 的写 JNI 一般是一一对应的，Thread.java 对应的就是 Thread.c\r\n- start0 其实是 JVM_StartThread，此时查看源码可以看到在 jvm.h 中找到声明，jvm.cpp 中有实现\r\n\r\n![image-20230417210441663](./assets/image-20230417210441663.png)\r\n\r\n#### jvm.cpp\r\n\r\n![image-20230417210612280](./assets/image-20230417210612280.png)\r\n\r\n![image-20230417210629981](./assets/image-20230417210629981.png)\r\n\r\n#### thread.cpp\r\n\r\n在这里调用了操作系统的线程启动\r\n\r\n![image-20230417210810055](./assets/image-20230417210810055.png)\r\n\r\n## Java 多线程相关概念\r\n\r\n### 1 把锁\r\n\r\nsynchronized\r\n\r\n### 2 个并\r\n\r\n- 并发 (concurrent): 是在同一实体上的多个事件，是在一台处理器上\"同时\"处理多个任务，同一时刻，其实只有一个事件在发生。\r\n- 并行 (parallel): 是在不同实体上的多个事件，是在多台处理器上同时处理多个任务，同一时刻，大家真的都在做事情，你做你的，我做我的，但是我们都在做。\r\n\r\n![image-20230417211125207](./assets/image-20230417211125207.png)\r\n\r\n### 3 个程\r\n\r\n> 通过上面 start 线程的案例，其实进程线程都来源于操作系统。\r\n\r\n- 进程：系统中运行的一个应用程序就是一个进程，每一个进程都有它自己的内存空间和系统资源。\r\n- 线程：也被称为轻量级进程，在同一进程内基本会有一个或者多个线程，是大多数操作系统进行调度的基本单元。\r\n- 管程：Monitor(监视器)，也就是我们平时说的锁。Monitor 其实是一种同步机制，它的义务是保证 (同一时间) 只有一个线程可以访问被包含的数据和代码。JVM 中同步是基于进入和退出监视器对象 (Monitor 管程对象) 来实现的，每个对象实例都会有一个 Monitor 对象。Monitor 对象会和 Java 对象一同创建并销毁，它的底层是由 C++语言来实现的。\r\n\r\n![image-20230417211541808](./assets/image-20230417211541808.png)\r\n\r\n## 用户线程和守护线程\r\n\r\n### Java 线程分为用户线程和守护线程\r\n\r\n- 一般情况下不做特别说明配置，默认都是用户线程。\r\n- 用户线程 (User Thread)\r\n  - 是系统的工作线程，它会完成这个程序需要完成的业务操作。\r\n- 守护线程 (Daemon Thread)\r\n  - 守护线程 (Daemon Thread): 是一种特殊的线程为其他线程服务的，在后台默默的完成一些系统性的服务，比如垃圾回收线程就是最典型的例子。守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程结束了，意味着程序需要完成的业务操作已经结束了。系统可以退出了。所有假设当系统只剩下守护线程的时候，java 虚拟机会自动退出。\r\n\r\n### 线程的 daemon 属性\r\n\r\n```java\r\n/* Whether or not the thread is a daemon thread. */\r\nprivate boolean     daemon = false;\r\n```\r\n\r\ntrue 表示是守护线程\r\n\r\nfalse 表示是用户线程\r\n\r\n### code 演示\r\n\r\n```java\r\npublic class DaemonDemo {\r\n    //一切方法运行的入口\r\n    public static void main(String[] args) {\r\n        Thread t1 = new Thread(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"\\t 开始运行，\" +\r\n                    (Thread.currentThread().isDaemon() ? \"守护线程\" : \"用户线程\"));\r\n            while (true) {\r\n\r\n            }\r\n        }, \"t1\");\r\n        t1.setDaemon(true);\r\n        t1.start();\r\n\r\n        //暂停几秒钟线程\r\n        try {\r\n            TimeUnit.SECONDS.sleep(3);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        System.out.println(Thread.currentThread().getName() + \"\\t ----end 主线程\");\r\n\r\n    }\r\n}\r\n//未加 t1.setDaemon(true);，默认是用户线程，他会继续运行，所以灯亮着\r\n//加了 t1.setDaemon(true);是守护线程，当用户线程 main 方法结束后自动退出了\r\n```\r\n\r\n### 小总结\r\n\r\n守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可退出了。假如当系统只剩下守护线程的时候，java 虚拟机会自动退出。\r\n\r\nsetDaemon(true) 方法必须在 start() 之前设置，否则报 IIIegalThreadStateException 异常\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/01.线程基础知识复习.md b/src/java/JUC/01.线程基础知识复习.md
--- a/src/java/JUC/01.线程基础知识复习.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/01.线程基础知识复习.md	(date 1682513015184)
@@ -1,12 +1,5 @@
 ---
-title: 线程基础知识复习
-date: 2023-04-17 20:14:00
-permalink: /pages/a87bc5/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 # 线程基础知识复习
 
Index: src/java/JUC/03.Java 锁.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Java 锁\r\ndate: 2023-04-17 20:20:17\r\npermalink: /pages/c84a96/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n###  锁\r\n\r\n#### 悲观锁\r\n\r\n认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，**synchronized**关键字和**Lock**的实现类都是悲观锁，适应写操作频繁的场景。\r\n\r\n#### 乐观锁\r\n\r\n认为自己在使用数据时不会有别的线程修改数据或资源，所以不会添加锁。 在Java中是通过使用无锁编程来实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据。\r\n\r\n如果这个数据没有被更新，当前线程将自己修改的数据成功写入。 如果这个数据已经被其它线程更新，则根据不同的实现执行不同的操作，比如放弃修改、重试抢锁等等\r\n\r\n**判断规则**\r\n\r\n- 版本号机制\r\n- CAS算法\r\n\r\n适合读频繁的场景\r\n\r\n#### synchronized\r\n\r\n**synchronized使用的三种方式：**\r\n\r\n- 作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁。\r\n\r\n  调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置。如果设置了，执行线程会将先持有monitor锁，然后再执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放monitor\r\n\r\n- 作用于代码块，对括号里配置的对象加锁。\r\n\r\n  synchronized同步代码块实现使用的是monitorenter和monitorexit指令，来保证持有锁，释放锁。会而外多加一个monitorexit，为了出现异常时也能释放锁。\r\n\r\n- 作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁。\r\n\r\n  ACC_STATIC，ACC_SYNCHRONIZED访问标志区分该方法是否静态同步方法\r\n\r\n**为什么任何一个对象都能成为一个锁呢？**\r\n\r\nobjectMonitor.java -> objectMonitor.cpp -> objectMonitor.hpp\r\n\r\n因为monitor采用objectMonitor实现的\r\n\r\n**什么是管程monitor**\r\n\r\n管程(英语: Monitors, 也称为监视器)是一种程序结构，结构内的多个子程序(对象或模块)形成的多个工作线程互斥访问共享资源。 这些共享资源一般是硬件设备或一群变量。对共享变量能够进行的所有操作集中在一个模块中。(把信号量及其操作原语“封装”在一个对象内部) 管程实现了在一个时间点， 最多只有一个线程在执行管程的某个子程序。管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。\r\n\r\n```\r\nclass Phone {\r\n    public synchronized void sendEmail() {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"----sendEmail\");\r\n    }\r\n    public synchronized void sendSMS() {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"-----sendSMS\");\r\n    }\r\n    public void hello() {\r\n        System.out.println(\"-------he11o\");\r\n    }\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Phone p1 = new Phone();\r\n        Phone p2 = new Phone();\r\n        new Thread(() -> {\r\n            p1.sendEmail();\r\n        }).start();\r\n        \r\n        new Thread(() -> {\r\n            p1.sendSMS();\r\n        }).start();\r\n    }\r\n}\r\n```\r\n\r\n先Email，后SMS\r\n\r\n一个对象里面如果有多个synchronized方法，某一个时刻内， 只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内， 只能有唯一的一 个线程去访间这些synchronized方法。\r\n\r\n锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法。\r\n\r\n```\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Phone p1 = new Phone();\r\n        Phone p2 = new Phone();\r\n        new Thread(() -> {\r\n            p1.sendEmail();\r\n        }).start();\r\n        \r\n        new Thread(() -> {\r\n            p1.hello();\r\n        }).start();\r\n    }\r\n}\r\n```\r\n\r\n先hello，后Email\r\n\r\n普通方法与同步锁无关\r\n\r\n```\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Phone p1 = new Phone();\r\n        Phone p2 = new Phone();\r\n        new Thread(() -> {\r\n            p1.sendEmail();\r\n        }).start();\r\n        new Thread(() -> {\r\n            p2.sendSMS();\r\n        }).start();\r\n    }\r\n}\r\n```\r\n\r\n先SMS，后Email\r\n\r\n不是同一把锁\r\n\r\n```\r\nclass Phone {\r\n    public static synchronized void sendEmail() {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"----sendEmail\");\r\n    }\r\n    public static synchronized void sendSMS() {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"-----sendSMS\");\r\n    }\r\n    public void hello() {\r\n        System.out.println(\"-------he11o\");\r\n    }\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Phone p1 = new Phone();\r\n        Phone p2 = new Phone();\r\n        new Thread(() -> {\r\n            p1.sendEmail();\r\n        }).start();\r\n        new Thread(() -> {\r\n            p1.sendSMS();\r\n        }).start();\r\n    }\r\n}\r\n```\r\n\r\n先Email，后SMS\r\n\r\n```\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Phone p1 = new Phone();\r\n        Phone p2 = new Phone();\r\n        new Thread(() -> {\r\n            p1.sendEmail();\r\n        }).start();\r\n        new Thread(() -> {\r\n            p2.sendSMS();\r\n        }).start();\r\n    }\r\n}\r\n```\r\n\r\n先Email，后SMS\r\n\r\n上述两种情况，加的是类锁\r\n\r\n对F普通同步方法，锁的是当前实例对象，通常指this，具体的一部部手机，所有的普通同步方法用的都是同把锁->实例对象本身，对于静态同步方法， 锁的是当前类的Class对象， 如Phone.class唯的一 个模板对于同步方法块，锁的是synchronized括号内的对象。\r\n\r\n```\r\nclass Phone {\r\n    public static synchronized void sendEmail() {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"----sendEmail\");\r\n    }\r\n    public synchronized void sendSMS() {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"-----sendSMS\");\r\n    }\r\n    public void hello() {\r\n        System.out.println(\"-------he11o\");\r\n    }\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Phone p1 = new Phone();\r\n        Phone p2 = new Phone();\r\n        new Thread(() -> {\r\n            p1.sendEmail();\r\n        }).start();\r\n        new Thread(() -> {\r\n            p1.sendSMS();\r\n        }).start();\r\n    }\r\n}\r\n```\r\n\r\n先SMS，后Email\r\n\r\n前者为类锁，后者为对象锁\r\n\r\n```\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Phone p1 = new Phone();\r\n        Phone p2 = new Phone();\r\n        new Thread(() -> {\r\n            p1.sendEmail();\r\n        }).start();\r\n        new Thread(() -> {\r\n            p2.sendSMS();\r\n        }).start();\r\n    }\r\n}\r\n```\r\n\r\n先SMS，后Email\r\n\r\n上述两种情况：当个线程试图访问同步代码时 它直先必须得到锁，正常退出或抛出异常时必须释放锁。 所有的普通同步方法用的都是同一把锁一实例对象本身，就是new出来的具体实例对象本身，本类this也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。 所有的静态同步方法用的也是同一把锁一类对象本身，就是我们说过的唯一模板Class 具体实例对象this和唯一模板class, 这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。\r\n\r\n#### 公平锁\r\n\r\n是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买后来的人在队尾排着，这是公平的。\r\n\r\nLock lock = new ReentrantLock(true)\r\n\r\n#### 非公平锁\r\n\r\n是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并 发环境下，有可能造成优先级翻转或者饥饿的状态(某个线程一直得不到锁)。\r\n\r\nLock lock = new ReentrantLock(false)\r\n\r\nLock lock = new ReentrantLock()//默认非公平锁\r\n\r\n恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU的时间片，尽量减少CPU空闲状态时间。 使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。\r\n\r\n非公平锁线程切换开销大。\r\n\r\n#### 可重入锁又名递归锁\r\n\r\nReentrantLock 和 synchronized都是可重入锁\r\n\r\n是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对 象)，不会因为之前已经获取过还没释放而阻塞。\r\n\r\n**隐式锁（synchronized）**\r\n\r\n默认就是可重入锁\r\n\r\n在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的\r\n\r\n```\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        reEntryM1();\r\n    }\r\n\r\n    private static void reEntryM1() {\r\n        final Object object = new Object();\r\n        new Thread(() -> {\r\n            synchronized (object){\r\n                System. out . println(Thread.currentThread(). getName()+\"\\t ---外层调用\");\r\n                synchronized (object){\r\n                    System. out . println(Thread. currentThread(). getName()+\"\\t ----中层调用\");\r\n                    synchronized (object){\r\n                        System. out . println( Thread.currentThread(). getName()+\"\\t ----内层调用\");\r\n                    }\r\n                }\r\n            }\r\n        }, \"t1\"). start();\r\n    }\r\n}\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        new Thread(() -> {\r\n            new JucTest().m1();\r\n        }).start();\r\n    }\r\n    public synchronized void m1() {\r\n        //指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入\r\n        System.out.println(Thread.currentThread().getName()+\"\\t ----come in\");\r\n        m2();\r\n        System.out.println(Thread.currentThread().getName()+\"\\t ----end m1\");\r\n    }\r\n    public synchronized void m2(){\r\n        System.out.println(Thread.currentThread().getName()+\"\\t ----come in\");\r\n        m3();\r\n    }\r\n    public synchronized void m3() {\r\n        System.out.println(Thread.currentThread(). getName()+\"\\t ----come in\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n**显示锁（ReentrantLock）**\r\n\r\n显示指定lock() unlock()\r\n\r\n加锁几次就要解锁几次\r\n\r\n```\r\npublic class JucTest {\r\n    static Lock lock = new ReentrantLock();\r\n    public static void main(String[] args) {\r\n        new Thread(() -> {\r\n            lock.lock();\r\n            try {\r\n                System.out.println(Thread.currentThread().getName()+\"\\t ----come in外层调用\");\r\n                lock.lock();\r\n                try {\r\n                    System.out.println(Thread.currentThread().getName()+\"\\t ----come in内层调用\");\r\n                }finally {\r\n                    lock.unlock();\r\n                }\r\n            }finally {\r\n                lock.unlock();\r\n            }\r\n        }, \"t1\").start();\r\n    }\r\n}\r\n```\r\n\r\n#### 死锁\r\n\r\n死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。\r\n\r\n```\r\n//死锁代码\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        final Object objectA = new Object();\r\n        final Object objectB = new Object();\r\n        new Thread(() -> {\r\n            synchronized (objectA) {\r\n                System.out.println(Thread.currentThread().getName() + \"\\t自己持有A锁，希望获得B锁\");\r\n                try {\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                synchronized (objectB) {\r\n                    System.out.println(Thread.currentThread().getName() + \"\\t成功获得B锁\");\r\n                }\r\n            }\r\n        }, \"A\").start();\r\n\r\n        new Thread(() -> {\r\n            synchronized (objectB) {\r\n                System.out.println(Thread.currentThread().getName() + \"\\t自己持有B锁，希望获得A锁\");\r\n                try {\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                synchronized (objectA) {\r\n                    System.out.println(Thread.currentThread().getName() + \"\\t成功获得A锁\");\r\n                }\r\n            }\r\n        }, \"B\").start();\r\n    }\r\n}\r\n```\r\n\r\n**排查死锁**\r\n\r\n1.纯命令\r\n\r\n jps -l\r\n\r\n jstack 进程编号\r\n\r\n2.jconsole图形化界面\r\n\r\n### 中断机制\r\n\r\n**协商中断**\r\n\r\n首先一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，自己来决定自己的命运。 所以，Thread.stop，Thread.suspend，Thread.resume都已经被废弃了。 其次在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。 因此，Java提供了一种用于停止线程的协商机制-----中断，也即中断标识协商机制。 中断只是一种协作协商机制，Java没 有给中断增加任何语法，中断的过程完全需要程序员自己实现。 若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true\r\n\r\n接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程请求这条线程中断，此时究竟该做什么需要你自己写代码实现。 每个线程对象中都有一个中断标识位，用于表示线程是否被中断;该标识位为true表示中断，为false表示未中断; 通过调用线程对象的interrupt方法将该线程的标识位设为true;可以在别的线程中调用，也可以在自己的线程中调用。\r\n\r\n如何实现线程中断停止\r\n\r\n```\r\n//1.使用volatile共享变量\r\npublic class JucTest {\r\n    static volatile boolean isStop = false;\r\n    public static void main(String[] args) {\r\n\r\n        new Thread(() -> {\r\n            while (true) {\r\n                if (isStop) {\r\n                    System.out.println(Thread.currentThread().getName() + \"\\t\" + \"thread stop\");\r\n                    break;\r\n                }\r\n                System.out.println(\"t1 -------hello volatile\");\r\n            }\r\n        }, \"t1\").start();\r\n\r\n        try {\r\n            TimeUnit.MICROSECONDS.sleep(20);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        new Thread(() -> {\r\n            isStop = true;\r\n        }, \"t2\").start();\r\n    }\r\n}\r\n\r\n//使用原子类\r\npublic class JucTest {\r\n    static AtomicBoolean atomicBoolean = new AtomicBoolean(false);\r\n    public static void main(String[] args) {\r\n\r\n        new Thread(() -> {\r\n            while (true) {\r\n                if (atomicBoolean.get()) {\r\n                    System.out.println(Thread.currentThread().getName() + \"\\t\" + \"thread stop\");\r\n                    break;\r\n                }\r\n                System.out.println(\"t1 -------hello volatile\");\r\n            }\r\n        }, \"t1\").start();\r\n\r\n        try {\r\n            TimeUnit.MICROSECONDS.sleep(20);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        new Thread(() -> {\r\n            atomicBoolean.set(true);\r\n        }, \"t2\").start();\r\n    }\r\n}\r\n```\r\n\r\n通过线程自带的**中断API**实列方法实现\r\n\r\n- Thread.interrupted()\r\n\r\n  返回当前线程的中断状态，测试当前线程是否已被中断 将当前线程的中断状态清零并重新设为false，清除线程的中断状态\r\n\r\n- Thread.interrupt()\r\n\r\n  没有返回值\r\n\r\n  仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程\r\n\r\n  ①如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以，interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。 ②如果线程处于被阻塞状态( 例如处于sleep， wait， join等状态)，在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，中断状态将被清除，并抛出一个InterruptedException异常。（可能程序会无限循环，解决方法须在异常catch处再调用interrupt方法）\r\n\r\n- Thread.isInterrupted()\r\n\r\n  判断当前线程是否被中断(通过检查中断标志位)，不清除线程的中断状态。\r\n\r\n```\r\n//通过线程自带的中断API实列方法实现\r\npublic class JucTest {\r\n    public static void main(String[] args) {\r\n        Thread t1 = new Thread(() -> {\r\n            while (true) {\r\n                if (Thread.currentThread().isInterrupted()) {\r\n                    System.out.println(Thread.currentThread().getName() + \"\\t\" + \"thread stop\");\r\n                    break;\r\n                }\r\n                System.out.println(\"t1 -------hello volatile\");\r\n            }\r\n        }, \"t1\");\r\n        t1.start();\r\n\r\n        try {\r\n            TimeUnit.MICROSECONDS.sleep(10);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        new Thread(() -> {\r\n            t1.interrupt();\r\n        }, \"t2\").start();\r\n    }\r\n}\r\n```\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/03.Java 锁.md b/src/java/JUC/03.Java 锁.md
--- a/src/java/JUC/03.Java 锁.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/03.Java 锁.md	(date 1682513017440)
@@ -1,12 +1,5 @@
 ---
-title: Java 锁
-date: 2023-04-17 20:20:17
-permalink: /pages/c84a96/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 ###  锁
 
Index: src/java/JUC/02.CompletableFuture.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: CompletableFuture\r\ndate: 2023-04-17 20:20:11\r\npermalink: /pages/ebcce4/\r\ncategories:\r\n  - Java\r\n  - JUC\r\ntags:\r\n  - \r\n---\r\n# CompletableFuture\r\n\r\n## Future 接口\r\n\r\n- Future 接口 (FutureTask 实现类) 定义了操作异步任务执行的一些方法，如获取异步任务的执行结果，取消任务的执行，判断任务是否被取消，判断任务是否执行完毕等。\r\n- 比如主线程让一个子线程取执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他的事情了，忙其他事情或者先执行完毕，过了一会才去获取子任务的执行结果或者变更的任务状态。\r\n- 一句话：Future 接口可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂业务。\r\n\r\n![image-20230417213330369](./assets/image-20230417213330369.png)\r\n\r\n## FutureTask 实现类\r\n\r\n### Future 接口能干什么\r\n\r\n- Future 是 java5 新加的一个接口，它提供了一种异步并行计算的功能。\r\n- 如果主线程需要执行一个很耗时的计算任务，我们就可以通过 Future 吧这个任务放到异步线程中执行。\r\n- 主线程进行处理其他任务或者先行接收，再通过 Future 获取计算结果。\r\n- 目的：异步多线程任务执行且返回结果，三个特点：`多线程，有返回，同步任务`。(班长为老师取买水作为新启动的异步线程任务且买到水有结果返回)\r\n\r\n### FutureTask 继承关系\r\n\r\n![image-20230417213859375](./assets/image-20230417213859375.png)\r\n\r\n> 在源码中可以看到，FutureTask 既继承了 RunnableFuture 接口，也在构造方法中实现了 Callable 接口和 Runnable 接口（需要传入实现的类作为构造函数的参数）\r\n\r\n![image-20230417214635836](./assets/image-20230417214635836.png)\r\n\r\n![image-20230417214338238](./assets/image-20230417214338238.png)\r\n\r\n### 代码演示\r\n\r\n```java\r\npublic class CompletableFutureDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        FutureTask<String> futureTask = new FutureTask<>(new MyThread());\r\n\r\n        Thread t1 = new Thread(futureTask, \"t1\");\r\n        t1.start();\r\n\r\n        System.out.println(futureTask.get());\r\n    }\r\n}\r\n\r\nclass MyThread implements Callable<String> {\r\n    @Override\r\n    public String call() throws Exception {\r\n        System.out.println(\"-----come in call() \");\r\n        return \"hello Callable\";\r\n    }\r\n}\r\n```\r\n\r\n### Future 编码实战\r\n\r\n> `Futrue + 线程池`异步多线程任务配合，能显著的提高城乡的执行效率\r\n\r\n```java\r\n//示例 1:3 个任务，1 个 main 线程处理，大概耗时 1140 毫秒\r\npublic class FutureThreadPoolDemo {\r\n    public static void main(String[] args) {\r\n        m1();\r\n    }\r\n    public static void m1(){\r\n        //3 个任务，只有一个 main 线程执行，耗时多少？\r\n        long startTime = System.currentTimeMillis();\r\n        //暂停毫秒\r\n        try {\r\n            TimeUnit.MILLISECONDS.sleep(500);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        try {\r\n            TimeUnit.MILLISECONDS.sleep(300);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        try {\r\n            TimeUnit.MILLISECONDS.sleep(300);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        long endTime = System.currentTimeMillis();\r\n        System.out.println(\"相差时间：\"+ (endTime - startTime) + \"毫秒\");\r\n        System.out.println(Thread.currentThread().getName()+\"线程\\t...end\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n//3 个任务 3 个线程，利用线程池（假如每次 new 一个 Thread，太浪费资源），大概 902 毫秒。\r\npublic class FutureThreadPoolDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        //3 个任务，目前开启多个异步任务线程来处理，请问耗时多少？\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        FutureTask<String> futureTask1 = new FutureTask<String>(() -> {\r\n            try {\r\n                TimeUnit.MILLISECONDS.sleep(500);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return \"task1 over\";\r\n        });\r\n        threadPool.submit(futureTask1);\r\n\r\n        FutureTask<String> futureTask2 = new FutureTask<String>(() -> {\r\n            try {\r\n                TimeUnit.MILLISECONDS.sleep(300);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return \"task2 over\";\r\n        });\r\n        threadPool.submit(futureTask2);\r\n\r\n        System.out.println(futureTask1.get()); //1000\r\n        System.out.println(futureTask2.get()); //300\r\n\r\n        try {\r\n            TimeUnit.MILLISECONDS.sleep(300);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        long endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime: \" + (endTime - startTime) + \" 毫秒\");\r\n\r\n        System.out.println(Thread.currentThread().getName() + \"\\t -----end\");\r\n        threadPool.shutdown();\r\n    }\r\n}\r\n```\r\n\r\n### Future 缺点\r\n\r\n- `get()方法阻塞`\r\n- `isDone()轮询`\r\n  - 利用`if(futureTask.isDone())`的方式使得 FutureTask 在结束之后才 get(),但是也会消耗 cpu\r\n\r\n```java\r\npublic class FutureAPIDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {\r\n        FutureTask<String> futureTask = new FutureTask<String>(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"\\t -----come in\");\r\n            try {\r\n                TimeUnit.SECONDS.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return \"task over\";\r\n        });\r\n        Thread t1 = new Thread(futureTask, \"t1\");\r\n        t1.start();\r\n\r\n        System.out.println(Thread.currentThread().getName() + \"\\t ----忙其它任务了\");\r\n\r\n        //System.out.println(futureTask.get());\r\n        //System.out.println(futureTask.get(3,TimeUnit.SECONDS));\r\n\r\n        while (true) {\r\n            if (futureTask.isDone()) {\r\n                System.out.println(futureTask.get());\r\n                break;\r\n            } else {\r\n                //暂停毫秒\r\n                try {\r\n                    TimeUnit.MILLISECONDS.sleep(500);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(\"正在处理中，不要再催了，越催越慢，再催熄火\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *1 get 容易导致阻塞，一般建议放在程序后面，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，容易程序堵塞。\r\n *2 假如我不愿意等待很长时间，我希望过时不候，可以自动离开.\r\n */\r\n```\r\n\r\n### Future 优缺点分析\r\n\r\n- Future 对于结果的获取不是很友好，只能通过阻塞或者轮询的方式的到结果\r\n- 对于简单的业务场景使用 Future 完全可以\r\n- 应对 Future 的完成时间，完成了可以告诉我们，也就是我们的回调通知，通过轮询的方式去判断是否完成这样非常占 CPU 并且代码也不优雅\r\n- 创建异步任务：使用 `Future + 线程池` 配合使用\r\n- 多个任务前后依赖可以组合处理 (水煮鱼): 想将多个异步任务的计算结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值，将两个或多个异步计算合成一个异步计算，这几个异步计算相互独立，同时后面这个又依赖前一个处理的结果 (比如买鱼 - 加料 - 烹饪)\r\n- 对计算速度选最快完成的（并返回结果）：当 Future 集合中某个任务最快结束时，返回结果，返回第一名处理结果\r\n\r\n## CompletableFuture 对 Future 改进\r\n\r\n- get() 方法在 Future 计算完成之前会一直处在阻塞状态下，isDone() 方法容易耗费 CPU 资源。\r\n\r\n- 对于真正的异步处理我们希望是可以通过传入回调函数，在 Futrue 结束时自动调用该回调函数，这样，我们就不用等待结果。\r\n\r\n- 阻塞的方式和异步编程的涉及理念相违背，而轮询的方式会耗费无谓的 CPU 资源，因此，JDK8 设计出 CompletableFuture\r\n\r\n- CompletableFuture 提供了一种观察者模式类的机制，可以让任务执行完成后通知监听的一方。\r\n\r\n- 在 Java 8 中，CompletableFuture 提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法\r\n\r\n- 它可能代表一个明确完成的 Future，也有可能代表一个完成阶段 (Completion Stage) ，它支持在计算完成以后触发一些函数或执行某些动作。\r\n\r\n```java\r\npublic class CompletableFuture<T> implements Future<T>, CompletionStage<T> {}\r\n```\r\n\r\n### CompletionStage\r\n\r\n- CompletionStage 代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。\r\n- 一个阶段的计算执行可以是一个 Function,Consumer 或者 Runnable，比如：`stage.thenApply(x - >square(x)).thenAccept(x -> System.out.print(x)).thenRun(() -> System.out.println())`\r\n\r\n- 一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发。\r\n- 代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段，有些类似 Linux 系统的管道分隔符传参数。\r\n\r\n### 核心的四个静态方法\r\n\r\n- 利用核心的四个静态方法创建一个异步操作，不建议直接 new\r\n- 关键就是有没有返回值，是否用了线程池\r\n- 参数说明：\r\n  - 没有指定 Executor 的方法，直接使用默认的 `ForkJoinPool.commPool()` 作为它的线程池执行异步代码\r\n  - 如果指定线程池，则使用我们定义的或者特别指定的线程池执行异步代码\r\n\r\n#### runAsync 无返回值\r\n\r\n```java\r\npublic static CompletableFuture<Void> runAsync(Runnable runnable) {\r\n    return asyncRunStage(asyncPool, runnable);\r\n}\r\n```\r\n\r\n```java\r\npublic static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor) {\r\n     return asyncRunStage(screenExecutor(executor), runnable);\r\n}\r\n```\r\n\r\n#### supplyAsync 有返回值\r\n\r\n```java\r\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {\r\n    return asyncSupplyStage(asyncPool, supplier);\r\n}\r\n```\r\n\r\n```java\r\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier,Executor executor) {\r\n    return asyncSupplyStage(screenExecutor(executor), supplier);\r\n}\r\n```\r\n\r\n> 上线方法中 Executor executor 参数说明：\r\n>\r\n> - 如果没有指定 Executor 的方法，直接使用默认的 `ForkJoinPool.commonPool()` 作为它的线程池执行异步代码\r\n> - 如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码\r\n\r\n### CompletableFuture 基本演示\r\n\r\n#### runAsync\r\n\r\n```java\r\npublic class CompletableFutureBuildDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        CompletableFuture<Void> completableFuture= CompletableFuture.runAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName());\r\n            //停顿几秒线程\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        });\r\n        System.out.println(completableFuture.get());\r\n    }\r\n}\r\n//ForkJoinPool.commonPool-worker-9 //默认的线程池\r\n//null --- 没有返回值\r\n```\r\n\r\n#### runAsync + 线程池\r\n\r\n```java\r\npublic class CompletableFutureBuildDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName());\r\n            //暂停几秒钟线程\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }, threadPool);\r\n        System.out.println(completableFuture.get());\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### supplyAsync + 线程池\r\n\r\n```java\r\npublic class CompletableFutureBuildDemo {\r\n\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n\r\n        ExecutorService executorService = Executors.newFixedThreadPool(3);//加入线程池\r\n\r\n        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(()->{\r\n            System.out.println(Thread.currentThread().getName());\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return \"helllo supplyasync\";\r\n        });\r\n        System.out.println(completableFuture.get());\r\n    }\r\n    //ForkJoinPool.commonPool-worker-9---------默认的线程池\r\n    //helllo supplyasync-------------supplyasync 有返回值了\r\n}\r\n```\r\n\r\n### CompletableFuture 进阶演示\r\n\r\n- 从 Java8 开始引入了 CompletableFuture，`它是Future的功能增强版,减少阻塞和轮询`，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。\r\n- 解释下为什么默认线程池关闭，自定义线程池记得关闭（默认线程池是守护线程，随着 main 主线程关闭而关闭，自定义线程池是用户线程）\r\n\r\n#### 阻塞演示\r\n\r\n`CompletableFuture 完成与 Future 相同的功能，但是使用 get() 依然阻塞`\r\n\r\n```java\r\npublic class CompletableFutureUseDemo {\r\n\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        future1();\r\n    }\r\n    private static void future1() throws ExecutionException, InterruptedException {\r\n        CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"...come in\");\r\n            int result = ThreadLocalRandom.current().nextInt(10);\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(\"1 秒钟后出结果：\" + result);\r\n            return result;\r\n        });\r\n        System.out.println(Thread.currentThread().getName()+\"线程先去忙其他任务！\");\r\n        System.out.println(completableFuture.get());\r\n    }\r\n}\r\n```\r\n\r\n#### 异步非阻塞演示\r\n\r\n`CompletableFuture 非阻塞演示`\r\n\r\n```java\r\npublic class CompletableFutureUseDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n        try {\r\n            CompletableFuture.supplyAsync(() -> {\r\n                System.out.println(Thread.currentThread().getName() + \"----come in\");\r\n                int result = ThreadLocalRandom.current().nextInt(10);\r\n                try {\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(\"-----1 秒钟后出结果：\" + result);\r\n                if (result > 2) {\r\n                    int i = 10 / 0;\r\n                }\r\n                return result;\r\n            }, threadPool).whenComplete((v, e) -> {\r\n                if (e == null) {\r\n                    System.out.println(\"-----计算完成，更新系统 UpdateValue：\" + v);\r\n                }\r\n            }).exceptionally(e -> {\r\n                e.printStackTrace();\r\n                System.out.println(\"异常情况：\" + e.getCause() + \"\\t\" + e.getMessage());\r\n                return null;\r\n            });\r\n            System.out.println(Thread.currentThread().getName() + \"线程先去忙其它任务\");\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            threadPool.shutdown();\r\n        }\r\n\r\n        //主线程不要立刻结束，否则 CompletableFuture 默认使用的线程池会立刻关闭：暂停 3 秒钟线程\r\n        //try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }\r\n    }\r\n}\r\n```\r\n\r\n### CompletableFuture 优点总结\r\n\r\n- 异步任务结束时，会`自动回调`某个对象的方法；\r\n- 主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行\r\n- 异步任务出错时，会自动回调某个对象的方法\r\n\r\n## 案例精讲 - 从电商网站的比价需求说开去\r\n\r\n### 复习 - 函数式接口\r\n\r\n>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口，对于函数式接口，我们可以通过 lambda 表达式来创建该接口的对象\r\n\r\n- `Runnable`\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Runnable {\r\n    public abstract void run();\r\n}\r\n```\r\n\r\n- `Function`\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Function<T, R> {\r\n    R apply(T t);\r\n}\r\n```\r\n\r\n- `Supplier`\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Supplier<T> {\r\n    T get();\r\n}\r\n```\r\n\r\n- `Biconsumer(Bi代表两个的意思，我们要传入两个参数，在上面的案例中是v和e)`\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface BiConsumer<T, U> {\r\n    void accept(T t, U u);\r\n}\r\n```\r\n\r\n| 函数式接口名称 | 方法名称 | 参数     | 返回值   |\r\n| -------------- | -------- | -------- | -------- |\r\n| Runnable       | run      | 无参数   | 无返回值 |\r\n| Function       | apply    | 1 个参数 | 有返回值 |\r\n| Consume        | accept   | 1 个参数 | 无返回值 |\r\n| Supplier       | get      | 没有参数 | 有返回值 |\r\n| Biconsumer     | accept   | 2 个参数 | 无返回值 |\r\n\r\n### 复习 - 链式调用写法\r\n\r\n```java\r\npublic class Chain {\r\n    public static void main(String[] args) {\r\n        //-------------------老式写法------------\r\n        //Student student = new Student();\r\n        //student.setId(1);\r\n        //student.setMajor(\"cs\");\r\n        //student.setName(\"小卡\");\r\n        new Student().setId(1).setName(\"大卡\").setMajor(\"cs\");\r\n    } \r\n}\r\n\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\n@Data\r\n@Accessors(chain = true)//开启链式编程\r\nclass Student{\r\n    private int id;\r\n    private String name;\r\n    private String major;\r\n}\r\n```\r\n\r\n### 复习-join 和 get 对比\r\n\r\njoin 和 get 功能几乎一样，区别在于编码时是否需要抛出异常\r\n\r\n- `get()`方法需要抛出异常\r\n- `join()`方法不需要抛出异常\r\n\r\n```java\r\npublic class Chain {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {//抛出异常\r\n        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n            return \"hello 12345\";\r\n        });\r\n        System.out.println(completableFuture.get());\r\n    }\r\n}\r\n\r\npublic class Chain {\r\n    public static void main(String[] args)  {//抛出异常\r\n        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n            return \"hello 12345\";\r\n        });\r\n        System.out.println(completableFuture.join());\r\n    }\r\n}\r\n```\r\n\r\n### 比价需求说明\r\n\r\n```java\r\n实战精讲-比价网站\r\n1 需求说明\r\n1.1 同一款产品，同时搜索出同款产品在各大电商平台的售价；\r\n1.2 同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少\r\n\r\n2 输出返回：\r\n出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String>\r\n《mysql》in jd price is 88.05\r\n《mysql》in dang dang price is 86.11\r\n《mysql》in tao bao price is 90.43\r\n\r\n3 解决方案，比对同一个商品在各个平台上的价格，要求获得一个清单列表\r\n1   stepbystep，按部就班，查完京东查淘宝，查完淘宝查天猫......\r\n2   all in，万箭齐发，一口气多线程异步任务同时查询......\r\n```\r\n\r\n### 代码演示\r\n\r\n```java\r\n/**\r\n *\r\n * 案例说明：电商比价需求，模拟如下情况：\r\n *\r\n * 1 需求：\r\n *  1.1 同一款产品，同时搜索出同款产品在各大电商平台的售价;\r\n *  1.2 同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少\r\n *\r\n * 2 输出：出来结果希望是同款产品的在不同地方的价格清单列表，返回一个 List<String>\r\n * 《mysql》 in jd price is 88.05\r\n * 《mysql》 in dangdang price is 86.11\r\n * 《mysql》 in taobao price is 90.43\r\n *\r\n * 3 技术要求\r\n *   3.1 函数式编程\r\n *   3.2 链式编程\r\n *   3.3 Stream 流式计算\r\n */\r\npublic class CompletableFutureMallDemo {\r\n    static List<NetMall> list = Arrays.asList(\r\n            new NetMall(\"jd\"),\r\n            new NetMall(\"dangdang\"),\r\n            new NetMall(\"taobao\"),\r\n            new NetMall(\"pdd\"),\r\n            new NetMall(\"tmall\")\r\n    );\r\n\r\n    /**\r\n     * step by step 一家家搜查\r\n     * List<NetMall> ----->map------> List<String>\r\n     * @param list\r\n     * @param productName\r\n     * @return\r\n     */\r\n    public static List<String> getPrice(List<NetMall> list, String productName) {\r\n        //《mysql》 in taobao price is 90.43\r\n        return list\r\n                .stream()\r\n                .map(netMall ->\r\n                        // 格式是 商品 in 网店 is 保留两位数\r\n                        String.format(productName + \" in %s price is %.2f\",\r\n                                netMall.getNetMallName(),\r\n                                netMall.calcPrice(productName)))\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    /**\r\n     * List<NetMall> ----->List<CompletableFuture<String>>------> List<String>\r\n     * @param list\r\n     * @param productName\r\n     * @return\r\n     */\r\n    public static List<String> getPriceByCompletableFuture(List<NetMall> list, String productName) {\r\n        return list\r\n                .stream()\r\n                .map(netMall ->\r\n                        CompletableFuture.supplyAsync(() -> String.format(productName + \" in %s price is %.2f\",\r\n                                netMall.getNetMallName(),\r\n                                netMall.calcPrice(productName))))\r\n                .collect(Collectors.toList())\r\n                .stream()\r\n                .map(s -> s.join())\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        //System.out.println(ThreadLocalRandom.current().nextDouble() * 2 + \"mysql\".charAt(0));\r\n        //System.out.println(ThreadLocalRandom.current().nextDouble()); // [0,1]\r\n        //System.out.println(ThreadLocalRandom.current().nextDouble() * 2);\r\n        //System.out.println(\"mysql\".charAt(0));\r\n        //System.out.println(1 + \"aysql\".charAt(0));\r\n\r\n        long startTime = System.currentTimeMillis();\r\n        List<String> list1 = getPrice(list, \"mysql\");\r\n        for (String element : list1) {\r\n            System.out.println(element);\r\n        }\r\n        long endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime: \" + (endTime - startTime) + \" 毫秒\");\r\n\r\n        System.out.println(\"--------------------\");\r\n\r\n        long startTime2 = System.currentTimeMillis();\r\n        List<String> list2 = getPriceByCompletableFuture(list, \"mysql\");\r\n        for (String element : list2) {\r\n            System.out.println(element);\r\n        }\r\n        long endTime2 = System.currentTimeMillis();\r\n        System.out.println(\"----costTime: \" + (endTime2 - startTime2) + \" 毫秒\");\r\n\r\n    }\r\n}\r\n\r\nclass NetMall {\r\n    @Getter\r\n    private String netMallName;\r\n\r\n    public NetMall(String netMallName) {\r\n        this.netMallName = netMallName;\r\n    }\r\n\r\n    public double calcPrice(String productName) {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 109.4065199644881 模拟了一个价格，整数位和小数位相加\r\n        return ThreadLocalRandom.current().nextDouble() * 2 + productName.charAt(0);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\nmysql in jd price is 110.29\r\nmysql in dangdang price is 110.83\r\nmysql in taobao price is 109.14\r\nmysql in pdd price is 110.87\r\nmysql in tmall price is 110.15\r\n----costTime: 5134 毫秒\r\n--------------------\r\nmysql in jd price is 110.15\r\nmysql in dangdang price is 109.70\r\nmysql in taobao price is 109.07\r\nmysql in pdd price is 110.63\r\nmysql in tmall price is 110.99\r\n----costTime: 1022 毫秒\r\n```\r\n\r\n## CompletableFuture 常用方法\r\n\r\n### 获得结果和触发计算\r\n\r\n#### 获得结果\r\n\r\n```java\r\npublic T get() 不见不散\r\npublic T get(long timeout,TimeUnit unit) 过时不候\r\npublic T join()\r\npublic T getNow(T valuelfAbsent)\r\n```\r\n\r\n#### `get`\r\n\r\n#### `join`\r\n\r\n#### `getNow`\r\n\r\n- 没有计算完成的情况下，直接返回设定的 valuelfAbsent 值\r\n- 计算完成的情况下，返回计算完成后的结果\r\n\r\n#### 主动触发计算\r\n\r\n```java\r\npublic bgolean complete(T value)\r\n```\r\n\r\n#### `complete`\r\n\r\n- 没有计算完成的情况下，打断 get 方法立即返回括号值\r\n- 计算完成的情况下，返回计算完成后的结果\r\n\r\n```java\r\npublic class CompletableFutureAPIDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        group1();\r\n    }\r\n\r\n    /**\r\n     * 获得结果和触发计算\r\n     * @throws InterruptedException\r\n     * @throws ExecutionException\r\n     */\r\n    private static void group1() throws InterruptedException, ExecutionException {\r\n        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n            //暂停几秒钟线程\r\n            try {\r\n                TimeUnit.SECONDS.sleep(2);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return \"abc\";\r\n        });\r\n\r\n        //System.out.println(completableFuture.get());\r\n        //System.out.println(completableFuture.get(2L,TimeUnit.SECONDS));\r\n        //System.out.println(completableFuture.join());\r\n\r\n        //暂停几秒钟线程\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        System.out.println(completableFuture.getNow(\"xxx\"));\r\n        //System.out.println(completableFuture.complete(\"completeValue\") + \"\\t\" + completableFuture.get());\r\n    }\r\n}\r\n```\r\n\r\n### 对计算结果进行处理\r\n\r\n#### `thenApply`\r\n\r\n- 计算结果存在依赖关系，将这两个线程串行化\r\n- 异常相关：由于存在依赖关系 (当前步错，不走下一步)，当前步骤有异常的话就叫停\r\n- 发生异常后进入 exceptionally 代码块，**但是 thenApply 中的代码不会执行，whenComplete 依旧会执行**\r\n\r\n```java\r\npublic class CompletableFutureAPI2Demo {\r\n    public static void main(String[] args) {\r\n        group1();\r\n    }\r\n\r\n    private static void group1() {\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n\r\n        CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n            //暂停几秒钟线程\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(\"111\");\r\n            return 1;\r\n        }, threadPool).thenApply((f) -> {\r\n            int i = 10 / 0;\r\n            System.out.println(\"222\");\r\n            return f + 2;\r\n        }).thenApply((f) -> {\r\n            System.out.println(\"333\");\r\n            return f + 3;\r\n        }).whenComplete((v, e) -> {\r\n            System.out.println(\"444\");\r\n            if (e == null) {\r\n                System.out.println(\"----计算结果： \" + v);\r\n            }\r\n        }).exceptionally(e -> {\r\n            e.printStackTrace();\r\n            System.out.println(e.getMessage());\r\n            return null;\r\n        });\r\n\r\n        System.out.println(Thread.currentThread().getName() + \"----主线程先去忙其它任务\");\r\n        System.out.println(completableFuture.join());\r\n\r\n        threadPool.shutdown();\r\n    }\r\n}\r\n\r\n//main----主线程先去忙其它任务\r\n//111\r\n//444\r\n//java.lang.ArithmeticException: / by zero\r\n//null\r\n//java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero\r\n```\r\n\r\n#### `handle`\r\n\r\n- 计算结果存在依赖关系，这两个线程串行化\r\n- 异常相关：有异常也可以往下一步走，根据带的异常参数可以进一步处理\r\n- 发生异常后进入 exceptionally 代码块，**但是 handle 和 whenComplete 依旧会执行**\r\n\r\n```java\r\npublic class CompletableFutureAPI2Demo {\r\n    public static void main(String[] args) {\r\n        group2();\r\n    }\r\n\r\n    private static void group2() {\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n\r\n        CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n            //暂停几秒钟线程\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(\"111\");\r\n            return 1;\r\n        }, threadPool).handle((f, e) -> {\r\n            int i = 10 / 0;\r\n            System.out.println(\"222\");\r\n            return f + 2;\r\n        }).handle((f, e) -> {\r\n            System.out.println(\"333\");\r\n            return f + 3;\r\n        }).whenComplete((v, e) -> {\r\n            System.out.println(\"444\");\r\n            if (e == null) {\r\n                System.out.println(\"----计算结果： \" + v);\r\n            }\r\n        }).exceptionally(e -> {\r\n            e.printStackTrace();\r\n            System.out.println(e.getMessage());\r\n            return null;\r\n        });\r\n\r\n        System.out.println(Thread.currentThread().getName() + \"----主线程先去忙其它任务\");\r\n        System.out.println(completableFuture.join());\r\n\r\n        threadPool.shutdown();\r\n    }\r\n}\r\n\r\n//main----主线程先去忙其它任务\r\n//111\r\n//333\r\n//444\r\n//java.lang.NullPointerException\r\n//null\r\n//java.util.concurrent.CompletionException: java.lang.NullPointerException\r\n```\r\n\r\n![image-20230418130834695](./assets/image-20230418130834695.png)\r\n\r\n### 对计算结果进行消费\r\n\r\n#### `thenAccept`\r\n\r\n- 接收任务的处理结果，并消费处理，无返回结果\r\n\r\n```\r\npublic class CompletableFutureAPI3Demo {\r\n    public static void main(String[] args) {\r\n        CompletableFuture<Void> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n            return 1;\r\n        }).thenApply(f -> {\r\n            return f + 2;\r\n        }).thenApply(f -> {\r\n            return f + 3;\r\n        }).thenAccept(System.out::println);\r\n\r\n        System.out.println(completableFuture.join());\r\n\r\n        //System.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenRun(() -> {}).join());\r\n        //System.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenAccept(r -> System.out.println(r)).join());\r\n        //System.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenApply(r -> r + \"resultB\").join());\r\n\r\n    }\r\n}\r\n\r\n//6\r\n//null\r\n```\r\n\r\n#### Code 任务之间的顺底执行\r\n\r\n- thenRun(Runnable runnable)\r\n  - 任务 A 执行完执行 B，并且 B 不需要 A 的结果\r\n- thenAccept(Consumer action)\r\n  - 任务 A 执行完执行 B，B 需要 A 的结果，但是任务 B 无返回值\r\n- thenApply(Function fn)\r\n  - 任务 A 执行完执行 B，B 需要 A 的结果，同时任务 B 有返回值\r\n\r\n```java\r\npublic class CompletableFutureAPI3Demo {\r\n    public static void main(String[] args) {\r\n        //CompletableFuture<Void> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n        //    return 1;\r\n        //}).thenApply(f -> {\r\n        //    return f + 2;\r\n        //}).thenApply(f -> {\r\n        //    return f + 3;\r\n        //}).thenAccept(System.out::println);\r\n\r\n        //System.out.println(completableFuture.join());\r\n\r\n        System.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenRun(() -> {}).join());\r\n        System.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenAccept(r -> System.out.println(r)).join());\r\n        System.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenApply(r -> r + \"resultB\").join());\r\n\r\n    }\r\n}\r\n\r\n//null\r\n//resultA\r\n//null\r\n//resultAresultB\r\n```\r\n\r\n#### CompletableFuture 和线程池说明\r\n\r\n```java\r\npublic class CompletableFutureWithThreadPoolDemo {\r\n    public static void main(String[] args) {\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(5);\r\n\r\n        try {\r\n            CompletableFuture<Void> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n                try {\r\n                    TimeUnit.MILLISECONDS.sleep(20);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(\"1 号任务\" + \"\\t\" + Thread.currentThread().getName());\r\n                return \"abcd\";\r\n            }, threadPool).thenRunAsync(() -> {\r\n                try {\r\n                    TimeUnit.MILLISECONDS.sleep(20);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(\"2 号任务\" + \"\\t\" + Thread.currentThread().getName());\r\n            }).thenRun(() -> {\r\n                try {\r\n                    TimeUnit.MILLISECONDS.sleep(10);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(\"3 号任务\" + \"\\t\" + Thread.currentThread().getName());\r\n            }).thenRun(() -> {\r\n                try {\r\n                    TimeUnit.MILLISECONDS.sleep(10);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(\"4 号任务\" + \"\\t\" + Thread.currentThread().getName());\r\n            });\r\n            System.out.println(completableFuture.get(2L, TimeUnit.SECONDS));\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            threadPool.shutdown();\r\n        }\r\n    }\r\n}\r\n\r\n//1 号任务\tpool-1-thread-1\r\n//2 号任务\tForkJoinPool.commonPool-worker-25\r\n//3 号任务\tForkJoinPool.commonPool-worker-25\r\n//4 号任务\tForkJoinPool.commonPool-worker-25\r\n//null\r\n```\r\n\r\n以 thenRun 和 thenRunAsync 为例，有什么区别？\r\n\r\n- 没有传入自定义线程池，都用默认线程池 ForkJoinPool;\r\n\r\n- 传入了一个自定义线程池，\r\n- 如果你执行第一个任务的时候，传入了一个自定义线程池：\r\n- 调用 thenRun 方法执行第二个任务时，则第二个任务和第一个任务是共用同一个线程池。\r\n- 调用 thenRunAsync 执行第二个任务时，则第一个任务使用的是你自己传入的线程池，第二个任务使用的是 ForkJoin 线程池\r\n\r\n有可能处理太快，系统优化切换原则，直接使用 main 线程处理\r\n其它如：thenAccept 和 thenAcceptAsync，thenApply 和 thenApplyAsync 等，它们之间的区别也是同理\r\n\r\n```java\r\npublic CompletableFuture<Void> thenRunAsync(Runnable action) {\r\n    return uniRunStage(asyncPool, action);\r\n}\r\n```\r\n\r\n`asyncPool`\r\n\r\n![image-20230418134453077](./assets/image-20230418134453077.png)\r\n\r\n### 对计算速度进行选用\r\n\r\n#### `applyToEither` \r\n\r\n比较异步线程谁快并且就使用谁\r\n\r\n```java\r\npublic class CompletableFutureFastDemo {\r\n    public static void main(String[] args) {\r\n        CompletableFuture<String> playA = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(\"A come in\");\r\n            try {\r\n                TimeUnit.SECONDS.sleep(3);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return \"playA\";\r\n        });\r\n\r\n        CompletableFuture<String> playB = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(\"B come in\");\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return \"playB\";\r\n        });\r\n\r\n        CompletableFuture<String> result = playA.applyToEither(playB, f -> {\r\n            return f + \" is winer\";\r\n        });\r\n\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"-----: \" + result.join());\r\n    }\r\n}\r\n\r\n//A come in\r\n//B come in\r\n//main\t-----: playB is winer\r\n```\r\n\r\n### 对计算结果进行合并\r\n\r\n#### `thenCombine`\r\n\r\n两个 completionStage 任务都完成后，最终能把两个任务的结果一起交给 thenCombine 来处理。先完成的先等着，等待其它分支任务\r\n\r\n```java\r\npublic class CompletableFutureCombineDemo {\r\n    public static void main(String[] args) {\r\n        CompletableFuture<Integer> completableFuture1 = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"\\t ---启动\");\r\n            //暂停几秒钟线程\r\n            try {\r\n                TimeUnit.SECONDS.sleep(1);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return 10;\r\n        });\r\n\r\n        CompletableFuture<Integer> completableFuture2 = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"\\t ---启动\");\r\n            //暂停几秒钟线程\r\n            try {\r\n                TimeUnit.SECONDS.sleep(2);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return 20;\r\n        });\r\n\r\n        CompletableFuture<Integer> result = completableFuture1.thenCombine(completableFuture2, (x, y) -> {\r\n            System.out.println(\"-----开始两个结果合并\");\r\n            return x + y;\r\n        });\r\n\r\n        System.out.println(result.join());\r\n\r\n    }\r\n}\r\n\r\n//ForkJoinPool.commonPool-worker-25\t ---启动\r\n//ForkJoinPool.commonPool-worker-18\t ---启动\r\n//-----开始两个结果合并\r\n//30\r\n```\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JUC/02.CompletableFuture.md b/src/java/JUC/02.CompletableFuture.md
--- a/src/java/JUC/02.CompletableFuture.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JUC/02.CompletableFuture.md	(date 1682513016288)
@@ -1,12 +1,5 @@
 ---
-title: CompletableFuture
-date: 2023-04-17 20:20:11
-permalink: /pages/ebcce4/
-categories:
-  - Java
-  - JUC
-tags:
-  - 
+
 ---
 # CompletableFuture
 
Index: src/java/JDK/01.✨JDK8.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: ✨JDK8\r\ndate: 2023-04-20 21:15:59\r\npermalink: /pages/10ebea/\r\ncategories:\r\n  - Java\r\n  - JDK\r\ntags:\r\n  - \r\n---\r\n# JDK8\r\n\r\n![image-20230420211627687](./assets/image-20230420211627687.png)\r\n\r\n## Lambda 表达式\r\n\r\n```txt\r\n左侧：指定了 Lambda 表达式需要的参数列表\r\n右侧：指定了 Lambda 体，是抽象方法的实现逻辑，是 Lambda 表达式要执行的功能\r\n\r\n`（） -> {}`\r\n上联：左右遇一括号省 下联：左侧推断类型省 横批：能省就省\r\nLambda 表达式基于函数式接口实现 \r\n\r\n\r\n类型推断 L：Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。\r\n```\r\n\r\n## 函数式接口\r\n\r\n> 接口中只有一个抽象方法的接口叫做函数式接口，通过`@FunctionalInterface`修饰判断是否是函数式接口\r\n\r\n> 四大主要的函数式接口\r\n\r\n![image-20230420211631344](./assets/image-20230420211631344.png)\r\n\r\n## 方法引用与构造器引用\r\n\r\n> 方法引用：Lambda 实现体的代码已经有实现，则可以直接使用方法引用\r\n\r\n```txt\r\n对象::实例方法名\r\n类::静态方法名\r\n类::实例方法名\r\n```\r\n\r\n> 构造器引用\r\n\r\n```java\r\n// 构造器引用\r\nSystem.out.println(\"-----------------------------\");\r\nSupplier<Emp> supplier3 = () -> new Emp();\r\nSupplier<Emp> supplier4 = Emp::new;\r\n```\r\n\r\n## Stream API\r\n\r\n> 源数据->流操作->新数据\r\n\r\n```txt\r\nStream 自己不会存储元素。\r\nStream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream。\r\nStream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。\r\n```\r\n\r\n![image-20230420211638209](./assets/image-20230420211638209.png)\r\n\r\n### 创建流\r\n\r\n```txt\r\n-- 通过集合\r\nnew stream() : 返回一个顺序流\r\nnew parallelStream() : 返回一个并行流\r\n-- 通过数组\r\nArrays.stream()\r\n-- 通过 Stream 的 of()\r\nStream.of()\r\n-- 创建无限流\r\nStream.iterate()\r\nStream.generate()\r\n```\r\n\r\n### 中间操作\r\n\r\n![image-20230420211642557](./assets/image-20230420211642557.png)\r\n\r\n![image-20230420211645238](./assets/image-20230420211645238.png)\r\n\r\n![image-20230420211647771](./assets/image-20230420211647771.png)\r\n\r\n### 终止操作\r\n\r\n![image-20230420211650273](./assets/image-20230420211650273.png)\r\n\r\n![image-20230420211652322](./assets/image-20230420211652322.png)\r\n\r\n![image-20230420211654609](./assets/image-20230420211654609.png)\r\n\r\n![image-20230420211656509](./assets/image-20230420211656509.png)\r\n\r\n### Collectors\r\n\r\n![image-20230420211658540](./assets/image-20230420211658540.png)\r\n\r\n![image-20230420211701408](./assets/image-20230420211701408.png)\r\n\r\n## Optional 类\r\n\r\n```txt\r\nOptional<T> 类 (java.util.Optional) 是一个容器类，它可以保存类型 T 的值，代表这个值存在。或者仅仅保存 null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常\r\n```\r\n\r\n![image-20230420211703320](./assets/image-20230420211703320.png)\r\n\r\n## 接口中的默认方法与静态方法\r\n\r\n```java\r\npublic interface DefaultMethodDemo {\r\n    default String getName() {\r\n        return \"接口中实现的默认方法\";\r\n    }\r\n\r\n    public static String getTitle() {\r\n        return \"接口中的静态方法\";\r\n    }\r\n}\r\n\r\nclass Demo {\r\n    public String getName() {\r\n        return \"父类中实现的方法\";\r\n    }\r\n}\r\n\r\nclass Test extends Demo implements DefaultMethodDemo {\r\n    public static void main(String[] args) {\r\n        // 父类优先原则\r\n        System.out.println(new Test().getName());\r\n        // 接口中的静态方法\r\n        System.out.println(DefaultMethodDemo.getTitle());\r\n    }\r\n}\r\n//父类中实现的方法\r\n//接口中的静态方法\r\n```\r\n\r\n## 新时间日期 API\r\n\r\n> 旧时间 API 线程不安全，新时间 API 线程安全\r\n\r\n```java\r\njava.time - 包含值对象的基础包\r\njava.time.chrono - 提供对不同的日历系统的访问\r\njava.time.format - 格式化和解析时间和日期\r\njava.time.temporal - 包括底层框架和拓展特性\r\njava.time.zone - 包含时区支持的类\r\n```\r\n\r\n```java\r\nLocalDateTime localDateTime = LocalDateTime.now();\r\nDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd hh:mm:ss\");\r\nlog.info(\"=====>\" + dtf.format(localDateTime));\r\n```\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JDK/01.✨JDK8.md b/src/java/JDK/01.✨JDK8.md
--- a/src/java/JDK/01.✨JDK8.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JDK/01.✨JDK8.md	(date 1682519463953)
@@ -1,12 +1,5 @@
 ---
-title: ✨JDK8
-date: 2023-04-20 21:15:59
-permalink: /pages/10ebea/
-categories:
-  - Java
-  - JDK
-tags:
-  - 
+
 ---
 # JDK8
 
Index: src/java/JDBC/02.使用 JDBC 连接数据库.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 使用 JDBC 连接数据库\r\ndate: 2023-04-09 22:47:41\r\npermalink: /pages/456ef3/\r\ncategories:\r\n  - Java\r\n  - JDBC\r\ntags:\r\n  - \r\n---\r\n\r\n# 使用 JDBC 连接数据库\r\n\r\n## 完整代码\r\n\r\n```java\r\nimport java.sql.*;\r\n\r\npublic class JDBCDemo {\r\n\r\n    public static void main(String[] args) {\r\n        Connection conn = null;\r\n        Statement stmt = null;\r\n        ResultSet rs = null;\r\n\r\n        try {\r\n            // 加载驱动程序\r\n            Class.forName(\"com.mysql.jdbc.Driver\");\r\n\r\n            // 建立数据库连接\r\n            String url = \"jdbc:mysql://localhost:3306/test\";\r\n            String user = \"root\";\r\n            String password = \"password\";\r\n            conn = DriverManager.getConnection(url, user, password);\r\n\r\n            // 创建 Statement 对象\r\n            stmt = conn.createStatement();\r\n\r\n            // 执行 SQL 查询语句\r\n            String sql = \"SELECT * FROM user\";\r\n            rs = stmt.executeQuery(sql);\r\n\r\n            // 处理查询结果集\r\n            while (rs.next()) {\r\n                int id = rs.getInt(\"id\");\r\n                String name = rs.getString(\"name\");\r\n                int age = rs.getInt(\"age\");\r\n                System.out.println(\"id: \" + id + \", name: \" + name + \", age: \" + age);\r\n            }\r\n\r\n        } catch (ClassNotFoundException e) {\r\n            e.printStackTrace();\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            // 关闭连接和释放资源\r\n            try {\r\n                if (rs != null) rs.close();\r\n                if (stmt != null) stmt.close();\r\n                if (conn != null) conn.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JDBC/02.使用 JDBC 连接数据库.md b/src/java/JDBC/02.使用 JDBC 连接数据库.md
--- a/src/java/JDBC/02.使用 JDBC 连接数据库.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JDBC/02.使用 JDBC 连接数据库.md	(date 1682512998492)
@@ -1,12 +1,5 @@
 ---
-title: 使用 JDBC 连接数据库
-date: 2023-04-09 22:47:41
-permalink: /pages/456ef3/
-categories:
-  - Java
-  - JDBC
-tags:
-  - 
+
 ---
 
 # 使用 JDBC 连接数据库
Index: src/java/JDBC/01.JDBC 概述.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: JDBC 概述\r\ndate: 2023-04-09 22:36:56\r\npermalink: /pages/04d465/\r\ncategories:\r\n  - Java\r\n  - JDBC\r\ntags:\r\n  - \r\n---\r\n\r\n# JDBC 概述\r\n\r\n## JDBC 介绍\r\n\r\nJDBC（Java Database Connectivity）是 Java 语言操作关系型数据库的一套标准 API。它提供了一种标准的方法来访问不同的关系型数据库（如 Oracle、MySQL、PostgreSQL 等），从而使 Java 应用程序可以与这些数据库进行交互和通信。\r\n\r\nJDBC API 提供了一组类和接口，使 Java 应用程序可以执行以下操作：\r\n\r\n1. 连接数据库\r\n2. 执行 SQL 语句\r\n3. 处理查询结果\r\n4. 事务处理\r\n\r\nJDBC API 的基本思想是，将 Java 程序与数据库之间的连接和交互分离开来，使得程序员可以使用标准的 Java 语言来访问数据库，而不需要关心底层数据库的实现细节。\r\n\r\n使用 JDBC，程序员可以通过以下步骤来连接数据库、执行 SQL 语句和处理查询结果：\r\n\r\n1. 加载驱动程序\r\n2. 建立连接\r\n3. 创建 Statement 或 PreparedStatement 对象\r\n4. 执行 SQL 语句\r\n5. 处理查询结果\r\n6. 关闭连接\r\n\r\nJDBC 是 Java 开发中常用的技术之一，它提供了一种灵活、可靠、跨平台的访问数据库的方式。\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JDBC/01.JDBC 概述.md b/src/java/JDBC/01.JDBC 概述.md
--- a/src/java/JDBC/01.JDBC 概述.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JDBC/01.JDBC 概述.md	(date 1682512996221)
@@ -1,12 +1,5 @@
 ---
-title: JDBC 概述
-date: 2023-04-09 22:36:56
-permalink: /pages/04d465/
-categories:
-  - Java
-  - JDBC
-tags:
-  - 
+
 ---
 
 # JDBC 概述
Index: src/java/JDK/01.Java8 新特性.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: Java8 新特性\r\ndate: 2023-03-07 14:59:21\r\npermalink: /pages/3005e2/\r\ncategories:\r\n  - Java\r\n  - JDK\r\ntags:\r\n  - \r\n---\r\n# Java8 新特性\r\n\r\n![image-20230420211221237](./../../.vuepress/public/JVM/image-20230420211221237.png)\r\n\r\n## Java8 概述\r\n\r\n- Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。\r\n- Java 8 是 oracle 公司于 2014 年 3 月发布，可以看成是自 Java 5 以来最具革命性的版本。Java 8 为 Java 语言、编译器、类库、开发工具与 JVM 带来了大量新特性。\r\n\r\n![image-20230417133611586](./assets/image-20230417133611586.png)\r\n\r\n## Java8 新特性的好处\r\n\r\n- 速度更快\r\n- 代码更少 (增加了新的语法：Lambda 表达式)\r\n- 强大的 Stream API\r\n- 便于并行\r\n- 最大化减少空指针异常：Optional\r\n- Nashorn 引擎，允许在 JVM 上运行 JS 应用\r\n\r\n## 并行流与串行流\r\n\r\n并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。\r\n\r\nJava 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。\r\n\r\n## Lambda 表达式\r\n\r\n### Lambda 表达式使用举例\r\n\r\n```java\r\npublic class LambdaTest {\r\n\r\n    @Test\r\n    public void test1(){\r\n        Runnable r1 = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(\"我爱北京天安门\");\r\n            }\r\n        };\r\n\r\n        r1.run();\r\n        System.out.println(\"---------------------使用 Lambda 表达式--------------------\");\r\n\r\n        Runnable r2 = () -> System.out.println(\"我爱北京故宫\");\r\n        r2.run();\r\n\r\n    }\r\n\r\n    @Test\r\n    public void test2(){\r\n        Comparator<Integer> comparator = new Comparator() {\r\n            @Override\r\n            public int compare(Object o1, Object o2) {\r\n                return Integer.compare((Integer) o1,(Integer)o2);\r\n            }\r\n        };\r\n        int compare1 = comparator.compare(12, 21);\r\n        System.out.println(compare1);\r\n\r\n        System.out.println(\"---------------------使用 Lambda 表达式--------------------\");\r\n        //Lambda 表达式\r\n        Comparator<Integer> comparator2 = (o1, o2) -> Integer.compare(o1,o2);\r\n        int compare2 = comparator2.compare(12, 1);\r\n        System.out.println(compare2);\r\n\r\n        System.out.println(\"---------------------方法引用写法--------------------\");\r\n        //方法应用\r\n        Comparator<Integer> comparator3 = Integer::compareTo;\r\n        int compare3 = comparator3.compare(12, 1);\r\n        System.out.println(compare3);\r\n        \r\n    }\r\n}\r\n```\r\n\r\n### Lambda 表达式的使用\r\n\r\n1. 举例：(o1,o2) -> `Integer.compare(o1,o2)`;\r\n2. 格式：\r\n   + `->` :<mark>lambda 操作符</mark> 或 <mark>箭头操作符 </mark>\r\n   + ->`左`边：<mark>lambda 形参列表</mark> （其实就是接口中的抽象方法的形参列表）\r\n   + ->`右`边：<mark>lambda 体</mark> （其实就是重写的抽象方法的方法体）\r\n\r\n3. Lamdba 表达式的使用分 6 种情况介绍\r\n\r\n> Lamdba 表达式的本质，作为接口的实例\r\n\r\n`cache-lifetime=\"5\" :options=\"{ useUrlFragment: false }\"`\r\n\r\n`语法格式一`\r\n\r\n```java {14}\r\n//无参，无返回值\r\n@Test\r\npublic void test1(){\r\n    Runnable r1 = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            System.out.println(\"我爱北京天安门\");\r\n        }\r\n    };\r\n\r\n    r1.run();\r\n    System.out.println(\"---------------------使用 Lambda 表达式--------------------\");\r\n\r\n    Runnable r2 = () -> System.out.println(\"我爱北京故宫\");\r\n    r2.run();\r\n}\r\n```\r\n\r\n`语法格式二`\r\n\r\n```java {14-16}\r\n//Lambda 表达式需要一个参数，但是没有返回值\r\n@Test\r\npublic void test02(){\r\n    Consumer<String> consumer = new Consumer<String>() {\r\n\r\n        @Override\r\n        public void accept(String s) {\r\n            System.out.println(s);\r\n        }\r\n    };\r\n    consumer.accept(\"学习新思想，争做新青年\");\r\n    System.out.println(\"---------------------使用 Lambda 表达式--------------------\");\r\n\r\n    Consumer<String> consumer1 = (String s)->{\r\n        System.out.println(s);\r\n    };\r\n    consumer1.accept(\"欢迎来到青年大学习\");\r\n\r\n}\r\n```\r\n\r\n`语法格式三`\r\n\r\n```java {9-11}\r\n//数据类型可以省略，因为可由编译器推断得出，成为“类型判断”\r\n@Test\r\npublic void test03(){\r\n    Consumer<String> consumer1 = (String s)->{\r\n        System.out.println(s);\r\n    };\r\n    consumer1.accept(\"欢迎来到青年大学习\");\r\n    System.out.println(\"---------------------优化--------------------\");\r\n    Consumer<String> consumer2 = (s)->{\r\n        System.out.println(s);\r\n    };\r\n    consumer2.accept(\"欢迎来到青年大学习\");\r\n}\r\n```\r\n\r\n`语法格式四`\r\n\r\n```java {9}\r\n//Lamdba 若只有一个参数时，参数的小括号可以省略\r\n@Test\r\npublic void test04(){\r\n    Consumer<String> consumer1 = (s)->{\r\n        System.out.println(s);\r\n    };\r\n    consumer1.accept(\"欢迎来到青年大学习\");\r\n    System.out.println(\"---------------------优化--------------------\");\r\n    Consumer<String> consumer2 = s->{\r\n        System.out.println(s);\r\n    };\r\n    consumer2.accept(\"欢迎来到青年大学习\");\r\n}\r\n```\r\n\r\n`语法格式五`\r\n\r\n```java {10}\r\n//Lamdba 需要两个或以上的参数，多条执行语句，并且可以有返回值\r\n@Test\r\npublic void test6(){\r\n    Comparator<Integer> comparator1 = (o1,o2) -> {\r\n        return o1.compareTo(o2);\r\n    };\r\n\r\n    System.out.println(comparator1.compare(12,21));\r\n    System.out.println(\"---------------------优化--------------------\");\r\n    Comparator<Integer> comparator2 = (o1,o2) -> o1.compareTo(o2);\r\n    System.out.println(comparator2.compare(12,21));\r\n\r\n}\r\n```\r\n\r\n`总结`\r\n\r\n->左边：lambda 形参列表的参数类型可以省略 (类型推断)；如果 lambda 形参列表只有一个参数，其一对 () 也可以省略\r\n\r\n->右边：lambda 体应该使用一对{}包裹；如果 lambda 体只有一条执行语句（可能是 return 语句），省略这一对{}和 return 关键字\r\n\r\n## 函数式 (Functional) 接口\r\n\r\n### 函数式接口的介绍\r\n\r\n如果一个<mark>接口</mark>中，<mark>只声明了一个抽象方法</mark>，则此接口就称为函数式接口。我们可以在一个接口上使用 `@FunctionalInterface `注解，这样做可以检查它是否是一个函数式接口。\r\n\r\n ```java\r\n@FunctionalInterface\r\npublic interface MyInterface {\r\n\r\n    void method1();\r\n}\r\n ```\r\n\r\n+ 在 java.util.function 包下定义了 Java 8 的丰富的函数式接口\r\n+ Java 从诞生日起就是一直倡导“一切皆对象”，在 Java 里面面向对象 (OOP) 编程是一切。但是随着 python、scala 等语言的兴起和新技术的挑战，Java 不得不做出调整以便支持更加广泛的技术要求，也即**java 不但可以支持 OOP 还可以支持 OOF（面向函数编程）**\r\n+ 在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda 表达式的类型是函数。但是在 Java8 中，有所不同。在 Java8 中，Lambda 表达式是对象，而不是函数，它们必须依附于\r\n+ 一类特别的对象类型——函数式接口。\r\n+ 简单的说，在 Java8 中，Lambda 表达式就是一个函数式接口的实例。这就是 Lambda 表达式和函数式接口的关系。也就是说，**只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示**。\r\n+ **所以以前用匿名实现类表示的现在都可以用 Lambda 表达式来写**。\r\n\r\n### Java 内置的函数式接口介绍及使用举例\r\n\r\n#### Java 内置四大核心函数式接口\r\n\r\n![image-20230417133714014](./assets/image-20230417133714014.png)\r\n\r\n```java\r\n/**\r\n * java 内置的四大核心函数式接口\r\n *\r\n * 消费型接口 Consumer<T>    void accept(T t)\r\n * 供给型接口 Supplier<T>    T get()\r\n * 函数型接口 Function<T,R>  apply(T t)\r\n * 断定型接口 Predicate<T>   boolean test(T t)\r\n */\r\npublic class LambdaTest2 {\r\n\r\n    /**\r\n     * 消费型接口 Consumer<T>    void accept(T t)\r\n     */\r\n    @Test\r\n    public void test1(){\r\n        happyTime(500, new Consumer<Double>() {\r\n            @Override\r\n            public void accept(Double aDouble) {\r\n                System.out.println(\"学习很开心，买了瓶快乐水，价格为：\"+aDouble);\r\n            }\r\n        });\r\n\r\n        System.out.println(\"---------------------使用 Lambda 表达式--------------------\");\r\n        happyTime(400,money -> System.out.println(\"学习很开心，买了瓶快乐水，价格为：\"+money));\r\n    }\r\n\r\n    public void happyTime(double money, Consumer<Double> consumer){\r\n        consumer.accept(money);\r\n    }\r\n\r\n    /**\r\n     * 供给型接口 Supplier<T>    T get()\r\n     */\r\n    @Test\r\n    public void test2(){\r\n        List<String> list = Arrays.asList(\"北京\", \"南京\", \"天津\", \"东京\", \"普京\");\r\n        List<String> filterStrs=filterString(list, new Predicate<String>() {\r\n            @Override\r\n            public boolean test(String s) {\r\n                return s.contains(\"京\");\r\n            }\r\n        });\r\n        System.out.println(filterStrs);\r\n        System.out.println(\"---------------------使用 Lambda 表达式--------------------\");\r\n        List<String> filterStrs1=filterString(list,s -> s.contains(\"京\"));\r\n        System.out.println(filterStrs1);\r\n    }\r\n\r\n    //根据给定的规则，过滤集合中的字符串，此规则是由 Predicate 的方法决定\r\n    public List<String> filterString(List<String> list, Predicate<String> pre){\r\n\r\n        ArrayList<String> filterList = new ArrayList<>();\r\n        for (String s : list) {\r\n            if(pre.test(s)){\r\n                filterList.add(s);\r\n            }\r\n        }\r\n\r\n        return filterList;\r\n\r\n    }\r\n}\r\n```\r\n\r\n#### 其他函数式接口\r\n\r\n![image-20230417135324769](./assets/image-20230417135324769.png)\r\n\r\n+ **何时使用 lambda 表达式？**\r\n\r\n当需要对一个函数式接口实例化的时候，可以使用 lambda 表达式。\r\n\r\n+ **何时使用给定的函数式接口？**\r\n\r\n如果我们开发中需要定义一个函数式接口，首先看看在已有的 jdk 提供的函数式接口是否提供了能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再自定义了。\r\n\r\n## 方法引用与构造器引用\r\n\r\n+ 当要传递给 Lambda 体的操作，已经有实现的方法了，可以使用方法引用！\r\n+ 方法引用可以看做是 Lambda 表达式深层次的表达。换句话说，方法引用就是 Lambda 表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是 Lambda 表达式的一个语法糖。\r\n+ 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！\r\n+ 格式：使用操作符“::”将类 (或对象) 与方法名分隔开来。\r\n+ 如下三种主要使用情况：\r\n  + **对象::实例方法名**\r\n  + **类::静态方法名**\r\n  + **类::实例方法名**\r\n\r\n```java \r\n/**\r\n * 1. 使用情况：当要传递给 Lambda 体的操作，已经有实现的方法了，可以使用方法引用\r\n *\r\n * 2. 方法引用，本质就是 Lambda 表达式，而 Lambda 表达式作为函数式接口的实例出现的。所以\r\n *      方法引用，也是函数式接口的实例。\r\n *\r\n * 3. 使用格式：类 (或对象) :: 方法名\r\n *\r\n * 4. 具体分为如下的三种情况：\r\n *      对象 :: 非静态方法\r\n *      类  :: 静态方法\r\n *      类  :: 非静态方法\r\n *\r\n * 5. 方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表\r\n *      和返回值类型相同！(针对情况一和情况二)\r\n */\r\npublic class MethodRefTest {\r\n\r\n    //情况一，对象 :: 实例方法\r\n    //Consumer 中的 void accept(T t)\r\n    //PrintStream 中的 void println(T t)\r\n    @Test\r\n    public void test1(){\r\n        Consumer<String> con1= str -> System.out.println(str);\r\n        con1.accept(\"北京\");\r\n\r\n        System.out.println(\"----------------------------方法引用-------------------------------\");\r\n        PrintStream ps=System.out;\r\n        Consumer<String> con2=ps :: println;\r\n        con2.accept(\"beijing\");\r\n    }\r\n\r\n    //Supplier 中的 T get()\r\n    //Employee 中的 String getName()\r\n    @Test\r\n    public void test2(){\r\n        Employee emp = new Employee(1001, \"Tom\", 23, 5600);\r\n        Supplier<String> sup1= ()-> emp.getName();\r\n        System.out.println(sup1.get());\r\n        System.out.println(\"----------------------------方法引用-------------------------------\");\r\n        Supplier<String> sup2= emp :: getName;\r\n        System.out.println(sup2.get());\r\n    }\r\n\r\n    //情况二：类 :: 静态方法\r\n    //Comparator 中的 int compare(T t1,T t2)\r\n    //Integer 中的 int compare(T t1,T t2)\r\n    @Test\r\n    public void test3(){\r\n        Comparator<Integer> com1=(t1, t2) -> Integer.compare(t1,t2);\r\n        System.out.println(com1.compare(12, 21));\r\n\r\n        System.out.println(\"----------------------------方法引用-------------------------------\");\r\n\r\n        Comparator<Integer> com2=Integer::compare;\r\n        System.out.println(com2.compare(12,21));\r\n\r\n    }\r\n\r\n    //Function 中的 R apply(T t)\r\n    //Math 中的 Long round(Double d)\r\n    @Test\r\n    public void test4(){\r\n        Function<Double,Long> func1 = d -> Math.round(d);\r\n        System.out.println(func1.apply(12.4));\r\n\r\n        System.out.println(\"----------------------------方法引用-------------------------------\");\r\n        Function<Double,Long> func2 = Math::round;\r\n        System.out.println(func2.apply(12.7));\r\n\r\n    }\r\n\r\n    //情况三：类::实例方法\r\n    //Comparator 中的 int compare(T t1,T t2)\r\n    //String 中的 int t1.compareTo(t2)\r\n    @Test\r\n    public void test5(){\r\n        Comparator<String> com1 = (s1,s2) ->s1.compareTo(s2);\r\n        System.out.println(com1.compare(\"abc\", \"abd\"));\r\n\r\n        System.out.println(\"----------------------------方法引用-------------------------------\");\r\n\r\n        Comparator<String> com2=String::compareTo;//类型\r\n        System.out.println(com2.compare(\"abc\",\"aba\"));\r\n\r\n    }\r\n\r\n    //BiPredicate 中的 boolean test(T t1,T t2);\r\n    //String 中的 boolean t1.equals(t2)\r\n    @Test\r\n    public void test6(){\r\n        BiPredicate<String,String> pre1 = (s1,s2) ->s1.equals(s2);\r\n        System.out.println(pre1.test(\"abc\",\"abc\"));\r\n        System.out.println(\"----------------------------方法引用-------------------------------\");\r\n        BiPredicate<String,String> pre2 = String::equals;\r\n        System.out.println(pre2.test(\"abc\", \"abcd\"));\r\n\r\n    }\r\n\r\n    //Function 中的 R apply(T t)\r\n    //Employee 中的 String getName();\r\n    @Test\r\n    public void test7(){\r\n\r\n        Employee emp = new Employee(1001,\"Jack\", 23, 6666);\r\n        Function<Employee,String> func1 = e -> e.getName();\r\n        System.out.println(func1.apply(emp));\r\n\r\n        System.out.println(\"----------------------------方法引用-------------------------------\");\r\n\r\n        Function<Employee,String> func2 = Employee::getName;\r\n        System.out.println(func2.apply(emp));\r\n    }\r\n}\r\n```\r\n\r\n### 构造器引用与数组引用的使用\r\n\r\n格式：`ClassName::new`\r\n\r\n与函数式接口相结合，自动与函数式接口中方法兼容。\r\n\r\n可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。\r\n\r\n```java\r\n/**\r\n * 一、构造器引用\r\n *          和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致\r\n *          抽象方法的返回值类型即为构造器所属的类的类型\r\n * 二、数组引用\r\n *          大家可以把数组看成是一个特殊的类，则写法与构造器引用一致\r\n */\r\npublic class ConstructorRefTest {\r\n\r\n    //构造器引用\r\n    //Supplier 中的 T get()\r\n    //Employee 的空参构造器，Employee()\r\n    @Test\r\n    public void test1(){\r\n        Supplier<Employee> sup1 = () -> new Employee();\r\n        System.out.println(sup1.get());\r\n\r\n        System.out.println(\"---------------------构造器 new---------------------\");\r\n\r\n        Supplier<Employee> sup2 = Employee::new;\r\n        System.out.println(sup2.get());\r\n    }\r\n\r\n    //Function 中的 apply(T t)\r\n    @Test\r\n    public void test2(){\r\n        Function<Integer,Employee> func1 = id -> new Employee(id);\r\n        Employee employee = func1.apply(1001);\r\n        System.out.println(employee);\r\n\r\n        System.out.println(\"---------------------构造器 new---------------------\");\r\n\r\n\r\n        Function<Integer,Employee> fun2 = Employee::new;\r\n        Employee employee1 = fun2.apply(1001);\r\n        System.out.println(employee1);\r\n    }\r\n\r\n    //BiFunction 中的 R apply(T t,U u)\r\n    @Test\r\n    public void test3(){\r\n        BiFunction<Integer,String,Employee> func1=(id,name) -> new Employee(id,name);\r\n        System.out.println(func1.apply(1001,\"Lucy\"));\r\n        System.out.println(\"---------------------构造器 new---------------------\");\r\n        BiFunction<Integer,String,Employee> func2 =Employee::new;\r\n        System.out.println(func2.apply(1001,\"Lucy\"));\r\n    }\r\n\r\n    //数组引用\r\n    //Function 中的 apply(T t)\r\n    @Test\r\n    public void test4(){\r\n        Function<Integer,String[]> func1 = length -> new String[length];\r\n        String[] arr1 = func1.apply(5);\r\n        System.out.println(Arrays.toString(arr1));\r\n        System.out.println(\"---------------------数组引用---------------------\");\r\n        Function<Integer,String[]> func2 = String[]::new;\r\n        String[] arr2 = func2.apply(10);\r\n        System.out.println(Arrays.toString(arr2));\r\n        \r\n    }\r\n    \r\n}\r\n```\r\n\r\n## 强大的 Stream API\r\n\r\n### Stream API 的概述\r\n\r\n+ Java8 中有两大最为重要的改变。第一个是<mark>Lambda 表达式</mark>；另外一个则是<mark>Stream API</mark>。\r\n+ Stream API ( `java.util.stream`) 把真正的函数式编程风格引入到 Java 中。这是目前为止对 Java 类库最好的补充，因为 Stream API 可以极大提供 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。\r\n+ Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。\r\n+ 为什么要使用 Stream API\r\n+ **实际开发中，项目中多数数据源都来自于 Mysql，Oracle 等。但现在数据源可以更多了，有 MongDB，Radis 等，而这些 NoSQL 的数据就需要 Java 层面去处理**。\r\n+ **Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算**。\r\n\r\n1.Stream 关注的是对数据的运算，与 CPU 打交道\r\n * 集合关注的是数据的存储，与内存打交道\r\n\r\n2.\r\n\r\n+ ①Stream 自己不会存储元素。\r\n+ ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream。\r\n+ ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行\r\n\r\n3.Stream 执行流程\r\n\r\n+ ① Stream 的实例化\r\n+ ② 一系列的中间操作（过滤、映射、...)\r\n+ ③ 终止操作\r\n\r\n\r\n 4.说明：\r\n\r\n+  4.1 一个中间操作链，对数据源的数据进行处理\r\n\r\n+  4.2 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用\r\n\r\n![image-20230417135342040](./assets/image-20230417135342040.png)\r\n\r\n### Stream 实例化方式\r\n\r\n+ 提供用于测试的数据\r\n\r\n```java\r\npublic class EmployeeData {\r\n\r\n    public static List<Employee> getEmployees(){\r\n        List<Employee> list = new ArrayList<>();\r\n\r\n        list.add(new Employee(1001, \"马化腾\", 34, 6000.38));\r\n        list.add(new Employee(1002, \"马云\", 12, 9876.12));\r\n        list.add(new Employee(1003, \"刘强东\", 33, 3000.82));\r\n        list.add(new Employee(1004, \"雷军\", 26, 7657.37));\r\n        list.add(new Employee(1005, \"李彦宏\", 65, 5555.32));\r\n        list.add(new Employee(1006, \"比尔盖茨\", 42, 9500.43));\r\n        list.add(new Employee(1007, \"任正非\", 26, 4333.32));\r\n        list.add(new Employee(1008, \"扎克伯格\", 35, 2500.32));\r\n\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n`cache-lifetime=\"5\" :options=\"{ useUrlFragment: false }\"`\r\n\r\n`通过集合`\r\n\r\n```java\r\n    //创建 Stream 方式一：通过集合\r\n    @Test\r\n    public void test1(){\r\n\r\n        List<Employee> employees = EmployeeData.getEmployees();\r\n\r\n        //default Stream<E> stream();返回一个顺序流\r\n        Stream<Employee> stream = employees.stream();\r\n\r\n        //default Stream<E> parallelStream(); 返回一个并行流\r\n        Stream<Employee> parallelStream = employees.parallelStream();\r\n        \r\n    }\r\n```\r\n\r\n`通过数组`\r\n\r\n```java\r\n    //创建 Stream 方式二：通过数组\r\n    @Test\r\n    public void test2(){\r\n\r\n        int[] arr = new int[]{1,2,3,4,5,6};\r\n        //调用 Arrays 类的 static<T> Stream<T> stream(T[] array)：返回一个流\r\n        IntStream stream = Arrays.stream(arr);\r\n\r\n        Employee e1 = new Employee(1001,\"Tom\");\r\n        Employee e2 = new Employee(1002,\"Jerry\");\r\n        Employee[] arr1 = new Employee[]{e1,e2};\r\n        Stream<Employee> stream1 = Arrays.stream(arr1);\r\n        \r\n    }\r\n```\r\n\r\n`通过 Stream 的 of()`\r\n\r\n```java\r\n// 创建 Stream 方式三：通过 Stream 的 of()\r\n@Test\r\npublic void test3(){\r\n\r\n    Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);\r\n\r\n}\r\n```\r\n\r\n`创建无限流`\r\n\r\n```java\r\n    //创建 Stream 方式四：创建无限流\r\n    @Test\r\n    public void test4(){\r\n\r\n        //迭代\r\n        //public static<T> Stream<T> iterate(final T seed,final UnaryOperator<T> f)\r\n        //遍历前 10 个偶数\r\n        Stream.iterate(0,t -> t+2).limit(10).forEach(System.out::println);\r\n\r\n        //生成\r\n        //public static<T> Stream<T> generate(Supplier<T> s)\r\n        Stream.generate(Math::random).limit(10).forEach(System.out::println);\r\n    }\r\n```\r\n\r\n### Stream 的中间操作：筛选与切片\r\n\r\n多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。\r\n\r\n| 方法                  | 描述                                                                                           |\r\n| --------------------- | ---------------------------------------------------------------------------------------------- |\r\n| `filter(Predicate p)` | 接收 Lambda，从流中排除某些元素                                                                |\r\n| `distinct()`          | 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素                                   |\r\n| `limit(long maxSize)` | 截断流，使其元素不超过给定数量                                                                 |\r\n| `skip(long n)`        | 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 |\r\n\r\n```java {18,23,28,39}\r\n/**\r\n * @author frx\r\n * @version 1.0\r\n * @date 2022/7/12  12:59\r\n * desc:测试 Stream 的中间操作\r\n */\r\npublic class StreamAPITest1 {\r\n\r\n    //1.筛选与分片\r\n    @Test\r\n    public void test1(){\r\n\r\n        List<Employee> list = EmployeeData.getEmployees();\r\n\r\n        //filter(Predicate p)--接收 Lambda, 从流中排除某些元素\r\n        Stream<Employee> stream = list.stream();\r\n        //查询员工表中薪资大于 7000 的员工\r\n        stream.filter(e -> e.getSalary()>7000).forEach(System.out::println);\r\n        System.out.println();\r\n\r\n        //limit(n)--使其元素不超过给定数量\r\n        stream = list.stream();\r\n        stream.limit(3).forEach(System.out::println);\r\n        System.out.println();\r\n\r\n        //skip(n)--跳过元素，返回一个扔掉了 n 个元素的流，若流中不足 n 个，侧返回一个空流。与 limit(n) 互补\r\n        stream = list.stream();\r\n        stream.skip(3).forEach(System.out::println);\r\n        System.out.println();\r\n\r\n        //distinct()--筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素\r\n        stream = list.stream();\r\n        list.add(new Employee(1010, \"xustudyxu\", 40, 8000));\r\n        list.add(new Employee(1010, \"xustudyxu\", 40, 8000));\r\n        list.add(new Employee(1010, \"xustudyxu\", 40, 8000));\r\n        list.add(new Employee(1010, \"xustudyxu\", 40, 8000));\r\n        list.add(new Employee(1010, \"xustudyxu\", 40, 8000));\r\n//        System.out.println(list);\r\n        list.stream().distinct().forEach(System.out::println);\r\n        stream.close();\r\n    }\r\n}\r\n```\r\n\r\n### Stream 的中间操作：映射\r\n\r\n| 方法                              | 描述                                                                           |\r\n| --------------------------------- | ------------------------------------------------------------------------------ |\r\n| `map(Function f)`                 | 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。   |\r\n| `mapToDouble(ToDoubleFunction f)` | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。  |\r\n| `mapToInt(ToIntFunction f)`       | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。     |\r\n| `mapToLong(ToLongFunction f)`     | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。    |\r\n| `flatMap(Function f)`             | 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 |\r\n\r\n```java {9,13,14,18-21,25}\r\npublic class StreamAPITest2 {\r\n\r\n    //映射\r\n    @Test\r\n    public void test2(){\r\n\r\n        //map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。\r\n        List<String> list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\");\r\n        list.stream().map(str -> str.toUpperCase()).forEach(System.out::println);\r\n\r\n        //练习：1：获取员工姓名长度大于 3 的员工的姓名。\r\n        List<Employee> employees = EmployeeData.getEmployees();\r\n        Stream<String> namesStream = employees.stream().map(Employee::getName);\r\n        namesStream.filter(name -> name.length()>3).forEach(System.out::println);\r\n        System.out.println();\r\n\r\n        //练习：2：\r\n        Stream<Stream<Character>> streamStream = list.stream().map(StreamAPITest2::fromStringToStream);\r\n        streamStream.forEach(s -> {\r\n            s.forEach(System.out::println);\r\n        });\r\n        System.out.println();\r\n\r\n        //flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。\r\n        Stream<Character> characterStream = list.stream().flatMap(StreamAPITest2::fromStringToStream);\r\n        characterStream.forEach(System.out::println);\r\n    }\r\n\r\n    //将字符串中的多个字符构成的集合转换成对应的 Stream 的实例\r\n    public static Stream<Character> fromStringToStream(String str){\r\n        ArrayList<Character> list = new ArrayList<>();\r\n        for (Character c : str.toCharArray()) {\r\n            list.add(c);\r\n        }\r\n        return list.stream();\r\n    }\r\n\r\n    @Test\r\n    public void test3(){\r\n        ArrayList list1 = new ArrayList();\r\n        list1.add(1);\r\n        list1.add(2);\r\n        list1.add(3);\r\n\r\n        ArrayList list2 = new ArrayList();\r\n        list2.add(1);\r\n        list2.add(2);\r\n        list2.add(3);\r\n\r\n        list1.add(list2);\r\n        list1.addAll(list2);\r\n        System.out.println(list1);\r\n\r\n    }\r\n}\r\n```\r\n\r\n### Stream 的中间操作：排序\r\n\r\n| 方法                     | 描述                               |\r\n| ------------------------ | ---------------------------------- |\r\n| `sorted()`               | 产生一个新流，其中按自然顺序排序   |\r\n| `sorted(Comparator com)` | 产生一个新流，其中按比较器顺序排序 |\r\n\r\n```java {11,19-26}\r\n/**\r\n * 排序\r\n */\r\npublic class StreamAPITest3 {\r\n\r\n    @Test\r\n    public void test1(){\r\n\r\n        //sorted()--自然排序\r\n        List<Integer> list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);\r\n        list.stream().sorted().forEach(System.out::println);\r\n\r\n        //List<Employee> employees = EmployeeData.getEmployees();\r\n        //employees.stream().sorted().forEach(System.out::println);\r\n        //抛异常，没有去实现 Comparable 接口\r\n\r\n        //sorted(Comparator com)--定制排序，年龄从小到大，薪水从小到大\r\n        List<Employee> employees = EmployeeData.getEmployees();\r\n        employees.stream().sorted((e1,e2) -> {\r\n            int ageValue = Integer.compare(e1.getAge(),e2.getAge());\r\n            if(ageValue!=0){\r\n                return ageValue;\r\n            }else {\r\n                return Double.compare(e1.getSalary(),e2.getSalary());//从大到小 加-\r\n            }\r\n        }).forEach(System.out::println);\r\n        \r\n    }\r\n}\r\n```\r\n\r\n### Stream 的终止操作：匹配与查找\r\n\r\n- 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。\r\n- 流进行了终止操作后，不能再次使用。\r\n\r\n| 方法                     | 描述                                                                                                           |\r\n| ------------------------ | -------------------------------------------------------------------------------------------------------------- |\r\n| `allMatch(Predicate p)`  | 检查是否匹配所有元素                                                                                           |\r\n| `anyMatch(Predicate p)`  | 检查是否至少匹配一个元素                                                                                       |\r\n| `noneMatch(Predicate p)` | 检查是否没有匹配所有元素                                                                                       |\r\n| `findFirst()`            | 返回第一个元素                                                                                                 |\r\n| `findAny()`              | 返回当前流中的任意元素                                                                                         |\r\n| `count()`                | 返回流中元素总数                                                                                               |\r\n| `max(Comparator c)`      | 返回流中最大值                                                                                                 |\r\n| `min(Comparator c)`      | 返回流中最小值                                                                                                 |\r\n| `forEach(Consumer c)`    | 内部迭代 (使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了) |\r\n\r\n```java {13,18,23,27,31,36,41,42,47,52,55}\r\n/**\r\n * 测试 Stream 的终止操作\r\n */\r\npublic class StreamAPITest4 {\r\n\r\n    //1.匹配与查找\r\n    @Test\r\n    public void test1() {\r\n        List<Employee> employees = EmployeeData.getEmployees();\r\n\r\n        //allMatch(Predicate p)——检查是否匹配所有元素。\r\n        //练习；是否所有的员工的年龄都大于 18\r\n        boolean allMatch = employees.stream().allMatch(e -> e.getAge() > 18);\r\n        System.out.println(allMatch);\r\n\r\n        //anyMatch(Predicate p)——检查是否至少匹配一个元素。\r\n        //练习：是否存在员工的工资大于 10000\r\n        boolean anyMatch = employees.stream().anyMatch(e -> e.getSalary() > 10000);\r\n        System.out.println(anyMatch);\r\n\r\n        //noneMatch(Predicate p)——检查是否没有匹配的元素。\r\n        //练习：是否存在员工姓“马”\r\n        boolean noneMatch = employees.stream().noneMatch(e -> e.getName().startsWith(\"马\"));\r\n        System.out.println(noneMatch);\r\n\r\n        //findFirst——返回第一个元素\r\n        Optional<Employee> employee = employees.stream().findFirst();\r\n        System.out.println(employee);\r\n\r\n        //findAny——返回当前流中的任意元素\r\n        Optional<Employee> employee1 = employees.stream().findAny();\r\n        System.out.println(employee1);\r\n\r\n        // count——返回流中元素的总个数\r\n        //工资大于 4500 的\r\n        long count = employees.stream().filter(e -> e.getSalary() > 4500).count();\r\n        System.out.println(count);\r\n\r\n        //max(Comparator c)——返回流中最大值\r\n        //返回最高的工资\r\n        Stream<Double> salaryStream = employees.stream().map(e -> e.getSalary());\r\n        Optional<Double> maxSalary = salaryStream.max(Double::compare);\r\n        System.out.println(maxSalary);\r\n\r\n        //min(Comparator c)——返回流中最小值\r\n        //返回最低的工资的员工\r\n        Optional<Employee> employee2 = employees.stream().min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()));\r\n        System.out.println(employee2);\r\n        System.out.println();\r\n\r\n        //forEach(Consumer c)——内部迭代\r\n        employees.stream().forEach(System.out::println);\r\n\r\n        //使用集合遍历的操作\r\n        employees.forEach(System.out::println);\r\n        \r\n    }\r\n}\r\n```\r\n\r\n### Stream 的终止操作：归约\r\n\r\n| 方法                               | 描述                                                  |\r\n| ---------------------------------- | ----------------------------------------------------- |\r\n| `reduce(T iden, BinaryOperator b)` | 可以将流中元素反复结合起来，得到一个值。返回 T        |\r\n| `reduce(BinaryOperator b)`         | 可以将流中元素反复结合起来，得到一个值。返回 Optional |\r\n\r\n> 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。\r\n\r\n```java {9,15-17}\r\npublic class StreamAPITest5 {\r\n\r\n    @Test\r\n    public void test1(){\r\n\r\n        //reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T\r\n        //练习 1：计算 1-10 的自然数的和\r\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7,8,9,10);\r\n        Integer sum = list.stream().reduce(0, Integer::sum);//0 是初始值\r\n        System.out.println(sum);\r\n\r\n        //reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T>\r\n        //练习 2：计算公司所有员工工资的总和\r\n        List<Employee> employees = EmployeeData.getEmployees();\r\n        Stream<Double> salaryStream = employees.stream().map(e -> e.getSalary());\r\n        //Optional<Double> sumMoney = salaryStream.reduce(Double::sum);\r\n        Optional<Double> sumMoney = salaryStream.reduce((d1, d2) -> d1 + d2);\r\n        System.out.println(sumMoney);\r\n\r\n    }\r\n}\r\n```\r\n\r\n### Stream 的终止操作：收集\r\n\r\n| 方法                   | 描述                                                                                |\r\n| ---------------------- | ----------------------------------------------------------------------------------- |\r\n| `collect(Collector c)` | 将流转换为其他形式。接收一个 Collector 接口的实现，用于给 Stream 中元素做汇总的方法 |\r\n\r\n```java {12,16}\r\n/**\r\n * 收集\r\n */\r\npublic class StreamAPITest6 {\r\n\r\n    @Test\r\n    public void test1(){\r\n\r\n        //collect(Collector c)——将流转换为其他形式。接收一个 Collector 接口的实现，用于给 Stream 中元素做汇总的方法\r\n        //练习 1：查找工资大于 6000 的员工，结果返回为一个 List 或 Set\r\n        List<Employee> employees = EmployeeData.getEmployees();\r\n        List<Employee> employeeList = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toList());\r\n        employeeList.forEach(System.out::println);\r\n        System.out.println();\r\n\r\n        Set<Employee> employeeSet = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toSet());\r\n        employeeSet.forEach(System.out::println);\r\n    }\r\n\r\n}\r\n```\r\n\r\n> `Collector` 接口中方法的实现决定了如何对流执行收集的操作 (如收集到`List、Set、Map`)。\r\n>\r\n> `Collectors`实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：\r\n\r\n![image-20230417135358957](./assets/image-20230417135358957.png)\r\n\r\n![image-20230417135406621](./assets/image-20230417135406621.png)\r\n\r\n## Optional 类\r\n\r\n### Optional 类的介绍\r\n\r\n到目前为止，臭名昭著的空指针异常是导致 Java 应用程序失败的最常见原因。以前，为了解决空指针异常，Google 公司著名的 Guava 项目引入了 Optional 类，Guava 通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到 Google Guava 的启发，Optional 类已经成为 Java 8 类库的一部分。\r\n\r\n+ `Optional` 类 (`java.util.Optional`) 是一个容器类，它可以保存类型 T 的值，代表这个值存在。或者仅仅保存`null`，表示这个值不存在。原来用 null 表示一个值不存在，现`在Optional` 可以更好的表达这个概念。并且可以避免空指针异常。\r\n+ Optional 类的 Javadoc 描述如下：这是一个可以为 null 的容器对象。如果值存在则`isPresent()`方法会返回`true`，调用`get()`方法会返回该对象。\r\n+ Optional 提供很多有用的方法，这样我们就不用显式进行空值检测。\r\n+ 创建 Optional 类对象的方法：\r\n  + `Optional.of(T t)`: 创建一个 Optional 实例，<mark>t 必须非空</mark>；\r\n  + `Optional.empty()` : 创建一个空的 Optional 实例\r\n  + `Optional.ofNullable(T t)`：<mark>t 可以为 null</mark>\r\n+ 判断 Optional 容器中是否包含对象：\r\n    + `boolean isPresent() `: 判断是否包含对象\r\n    + `void ifPresent(Consumer<? super T> consumer)` ：如果有值，就执行 Consumer 接口的实现代码，并且该值会作为参数传给它。\r\n+ 获取 Optional 容器的对象：\r\n    + `T get()`: 如果调用对象包含值，返回该值，否则抛异常\r\n    +  `T orElse(T other)` ：如果有值则将其返回，否则返回指定的 other 对象。\r\n    + `T orElseGet(Supplier<? extends T> other)` ：如果有值则将其返回，否则返回由 Supplier 接口实现提供的对象。\r\n    +  `T orElseThrow(Supplier<? extends X> exceptionSupplier) `：如果有值则将其返回，否则抛出由 Supplier 接口实现提供的异常。\r\n\r\n> Girl 类\r\n\r\n```java\r\npublic class Girl {\r\n\r\n    private String name;\r\n\r\n    public Girl() {\r\n    }\r\n\r\n    public Girl(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Girl{\" +\r\n                \"name='\" + name + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n```\r\n\r\n> Boy 类\r\n\r\n```java\r\npublic class Boy {\r\n\r\n    private Girl girl;\r\n\r\n    public Boy() {\r\n    }\r\n\r\n    public Boy(Girl girl) {\r\n        this.girl = girl;\r\n    }\r\n\r\n    public Girl getGirl() {\r\n        return girl;\r\n    }\r\n\r\n    public void setGirl(Girl girl) {\r\n        this.girl = girl;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Boy{\" +\r\n                \"girl=\" + girl +\r\n                '}';\r\n    }\r\n}\r\n```\r\n\r\n> 测试类\r\n\r\n```java {14,24,27}\r\npublic class OptionalTest {\r\n\r\n    /**\r\n     * Optional.of(T t) : 创建一个 Optional 实例，t 必须非空；\r\n     * Optional.empty() : 创建一个空的 Optional 实例\r\n     * Optional.ofNullable(T t)：t 可以为 null\r\n     */\r\n\r\n    @Test\r\n    public void test(){\r\n\r\n        Girl girl = new Girl();\r\n        //girl=null;//报空指针异常 of(T t) 方法 必须保证 t 非空\r\n        Optional<Girl> optionalGirl = Optional.of(girl);\r\n\r\n    }\r\n\r\n    @Test\r\n    public void test1(){\r\n\r\n        Girl girl = new Girl();\r\n        girl=null;\r\n        //ofNullable(T t) //t 可以为 null\r\n        Optional<Girl> optionalGirl = Optional.ofNullable(girl);\r\n        //orElse(T t1):如果当前的 Optional 内部封装的 t 是非空的，则返回内部的 t\r\n        //如果内部的 t 是空的，则返回 orElse() 方法中的参数 t1\r\n        Girl lucy = optionalGirl.orElse(new Girl(\"Lucy\"));\r\n        System.out.println(lucy);\r\n\r\n    }\r\n}\r\n```\r\n\r\n### Optional 类的使用举例\r\n\r\n> 测试类\r\n\r\n```java\r\n/**\r\n * Optional 类：为了在程序中避免出现空指针异常而创建的。\r\n *\r\n * 常用的方法：ofNullable(T t)\r\n *           orElse(T t)\r\n */\r\npublic class OptionTest1 {\r\n\r\n    public String getGirlName(Boy boy){\r\n        return boy.getGirl().getName();\r\n    }\r\n\r\n    @Test\r\n    public void test2(){\r\n        //让 boy.getGirl() 为 null\r\n        Boy boy = new Boy();\r\n        String girlName = getGirlName(boy);\r\n        System.out.println(girlName);\r\n    }\r\n\r\n    //优化以后的 getGirlName():\r\n    //没有 Optional\r\n    /*public String getGirlName1(Boy boy){\r\n        if(boy !=null){\r\n            Girl girl = boy.getGirl();\r\n            if(girl!=null){\r\n                return girl.getName();\r\n            }\r\n        }\r\n        return null;\r\n    }*/\r\n\r\n    //优化以后的 getGirlName():\r\n    //有 Optional\r\n    //使用 Optional 类的 getGirlName()\r\n    public String getGirlName2(Boy boy){\r\n        Optional<Boy> boyOptional = Optional.ofNullable(boy);\r\n        //此时的 boy1 一定非空\r\n        Boy boy1 = boyOptional.orElse(new Boy(new Girl(\"Smith\")));\r\n        Girl girl = boy1.getGirl();\r\n        Optional<Girl> girlOptional = Optional.ofNullable(girl);\r\n        //此时的 girl1 一定非空\r\n        Girl girl1 = girlOptional.orElse(new Girl(\"Mary\"));\r\n        return girl1.getName();\r\n    }\r\n\r\n    @Test\r\n    public void test3(){\r\n        Boy boy = null;//boy 为 null\r\n        String girlName2 = getGirlName2(boy);\r\n        System.out.println(girlName2);//Smith\r\n        boy=new Boy();//girl 为 null\r\n        String girlName3= getGirlName2(boy);\r\n        System.out.println(girlName3);//Mary\r\n\r\n        Boy boy1 = new Boy(new Girl(\"Lucy\"));\r\n        String girlName4 = getGirlName2(boy1);\r\n        System.out.println(girlName4);//Lucy\r\n\r\n    }\r\n}\r\n```\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JDK/01.Java8 新特性.md b/src/java/JDK/01.Java8 新特性.md
--- a/src/java/JDK/01.Java8 新特性.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JDK/01.Java8 新特性.md	(date 1682519463951)
@@ -1,16 +1,9 @@
 ---
-title: Java8 新特性
-date: 2023-03-07 14:59:21
-permalink: /pages/3005e2/
-categories:
-  - Java
-  - JDK
-tags:
-  - 
+
 ---
 # Java8 新特性
 
-![image-20230420211221237](./../../.vuepress/public/JVM/image-20230420211221237.png)
+![image-20230420211221237](./assets/image-20230420211221237.png)
 
 ## Java8 概述
 
Index: src/java/JDBC/10.JDBC 总结.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: \r\ndate: 2023-04-09 23:01:30\r\npermalink: /pages/f9d713/\r\ncategories:\r\n  - Java\r\n  - JDBC\r\ntags:\r\n  - \r\n---\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JDBC/10.JDBC 总结.md b/src/java/JDBC/10.JDBC 总结.md
--- a/src/java/JDBC/10.JDBC 总结.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JDBC/10.JDBC 总结.md	(date 1682513002235)
@@ -1,10 +1,3 @@
 ---
-title: 
-date: 2023-04-09 23:01:30
-permalink: /pages/f9d713/
-categories:
-  - Java
-  - JDBC
-tags:
-  - 
+
 ---
Index: src/java/JDK/03.JDK8-17 新特性下.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: JDK8-17 新特性下\r\ndate: 2023-04-17 13:28:30\r\npermalink: /pages/e9766f/\r\ncategories:\r\n  - Java\r\n  - JDK\r\ntags:\r\n  - \r\n---\r\n# JDK8-17 新特性下\r\n\r\n官网：[http://www.atguigu.com](http://www.atguigu.com/)\r\n\r\n***\r\n\r\n## 新语法结构\r\n\r\n新的语法结构，为我们勾勒出了 Java 语法进化的一个趋势，将开发者从`复杂、繁琐`的低层次抽象中逐渐解放出来，以更高层次、更优雅的抽象，既`降低代码量`，又避免意外编程错误的出现，进而提高代码质量和开发效率。\r\n\r\n### Java 的 REPL 工具：jShell 命令\r\n\r\n**JDK9 的新特性**\r\n\r\nJava 终于拥有了像 Python 和 Scala 之类语言的 REPL 工具（交互式编程环境，read - evaluate - print - loop）：`jShell`。以交互式的方式对语句和表达式进行求值。`即写即得`、`快速运行`。\r\n\r\n利用 jShell 在没有创建类的情况下，在命令行里直接声明变量，计算表达式，执行语句。无需跟人解释”public static void main(String[] args)”这句\"废话\"。\r\n\r\n**使用举例**\r\n\r\n- 调出 jShell\r\n\r\n\r\n![image-20230417134617871](./assets/image-20230417134617871.png)\r\n\r\n- 获取帮助\r\n\r\n\r\n![image-20230417134621949](./assets/image-20230417134621949.png)\r\n\r\n- 基本使用\r\n\r\n\r\n![image-20230417134631970](./assets/image-20230417134631970.png)\r\n\r\n- 导入指定的包\r\n\r\n\r\n![image-20230417134657714](./assets/image-20230417134657714.png)\r\n\r\n- 默认已经导入如下的所有包：（包含 java.lang 包）\r\n\r\n\r\n![image-20230417134702257](./assets/image-20230417134702257.png)\r\n\r\n- 只需按下 Tab 键，就能自动补全代码\r\n\r\n\r\n![image-20230417134706269](./assets/image-20230417134706269.png)\r\n\r\n- 列出当前 session 里所有有效的代码片段\r\n\r\n\r\n![image-20230417134711432](./assets/image-20230417134711432.png)\r\n\r\n- 查看当前 session 下所有创建过的变量\r\n\r\n\r\n![image-20230417134724331](./assets/image-20230417134724331.png)\r\n\r\n- 查看当前 session 下所有创建过的方法\r\n\r\n\r\n![image-20220527205513459](./assets/image-20230417134728303.png)\r\n\r\n> Tips：我们还可以重新定义相同方法名和参数列表的方法，即对现有方法的修改（或覆盖）。\r\n\r\n- 使用外部代码编辑器来编写 Java 代码\r\n\r\n\r\n![image-20230417134733916](./assets/image-20230417134733916.png)\r\n\r\n从外部文件加载源代码【HelloWorld.java】\r\n\r\n```java\r\n/**\r\n * Created by songhongkang\r\n */\r\npublic void printHello() {\r\n    System.out.println(\"马上 2023 年了，尚硅谷祝所有的谷粉元旦快乐！\");\r\n}\r\nprintHello();\r\n\r\n```\r\n\r\n- 使用/open命令调用\r\n\r\n\r\n![image-20230417134754308](./assets/image-20230417134754308.png)\r\n\r\n- 退出 jShell\r\n\r\n\r\n![image-20230417134800172](./assets/image-20230417134800172.png)\r\n\r\n### 异常处理之 try-catch 资源关闭\r\n\r\n在 JDK7 之前，我们这样处理资源的关闭：\r\n\r\n```java\r\n@Test\r\npublic void test01() {\r\n    FileWriter fw = null;\r\n    BufferedWriter bw = null;\r\n    try {\r\n        fw = new FileWriter(\"d:/1.txt\");\r\n        bw = new BufferedWriter(fw);\r\n\r\n        bw.write(\"hello\");\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        try {\r\n            if (bw != null) {\r\n                bw.close();\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        try {\r\n            if (fw != null) {\r\n                fw.close();\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n**JDK7 的新特性**\r\n\r\n在 try 的后面可以增加一个 ()，在括号中可以声明流对象并初始化。try 中的代码执行完毕，会自动把流对象释放，就不用写 finally 了。\r\n\r\n格式：\r\n\r\n```java\r\ntry(资源对象的声明和初始化){\r\n    业务逻辑代码,可能会产生异常\r\n}catch(异常类型1 e){\r\n    处理异常代码\r\n}catch(异常类型2 e){\r\n    处理异常代码\r\n}\r\n```\r\n\r\n说明：\r\n\r\n1、在 try() 中声明的资源，无论是否发生异常，无论是否处理异常，都会自动关闭资源对象，不用手动关闭了。\r\n\r\n2、这些资源实现类必须实现 AutoCloseable 或 Closeable 接口，实现其中的 close() 方法。Closeable 是 AutoCloseable 的子接口。Java7 几乎把所有的“资源类”（包括文件 IO 的各种类、JDBC 编程的 Connection、Statement 等接口…）都进行了改写，改写后资源类都实现了 AutoCloseable 或 Closeable 接口，并实现了 close() 方法。\r\n\r\n3、写到 try() 中的资源类的变量默认是 final 声明的，不能修改。\r\n\r\n举例：\r\n\r\n```java\r\n//举例 1\r\n@Test\r\npublic void test02() {\r\n    try (\r\n        FileWriter fw = new FileWriter(\"d:/1.txt\");\r\n        BufferedWriter bw = new BufferedWriter(fw);\r\n    ) {\r\n        bw.write(\"hello\");\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\r\n\r\n//举例 2\r\n@Test\r\npublic void test03() {\r\n    //从 d:/1.txt(utf-8) 文件中，读取内容，写到项目根目录下 1.txt(gbk) 文件中\r\n    try (\r\n        FileInputStream fis = new FileInputStream(\"d:/1.txt\");\r\n        InputStreamReader isr = new InputStreamReader(fis, \"utf-8\");\r\n        BufferedReader br = new BufferedReader(isr);\r\n\r\n        FileOutputStream fos = new FileOutputStream(\"1.txt\");\r\n        OutputStreamWriter osw = new OutputStreamWriter(fos, \"gbk\");\r\n        BufferedWriter bw = new BufferedWriter(osw);\r\n    ) {\r\n        String str;\r\n        while ((str = br.readLine()) != null) {\r\n            bw.write(str);\r\n            bw.newLine();\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        e.printStackTrace();\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\r\n```\r\n\r\n**JDK9 的新特性**\r\n\r\ntry 的前面可以定义流对象，try 后面的 () 中可以直接引用流对象的名称。在 try 代码执行完毕后，流对象也可以释放掉，也不用写 finally 了。\r\n\r\n格式：\r\n\r\n```java\r\nA a = new A();\r\nB b = new B();\r\ntry(a;b){\r\n    可能产生的异常代码\r\n}catch(异常类名 变量名){\r\n    异常处理的逻辑\r\n}\r\n```\r\n\r\n举例：\r\n\r\n```java\r\n@Test\r\npublic void test04() {\r\n    InputStreamReader reader = new InputStreamReader(System.in);\r\n    OutputStreamWriter writer = new OutputStreamWriter(System.out);\r\n    try (reader; writer) {\r\n        //reader 是 final 的，不可再被赋值\r\n        //   reader = null;\r\n\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\r\n```\r\n\r\n### 局部变量类型推断\r\n\r\n**JDK 10 的新特性**\r\n\r\n局部变量的显示类型声明，常常被认为是不必须的，给一个好听的名字反而可以很清楚的表达出下面应该怎样继续。本新特性允许开发人员省略通常不必要的局部变量类型声明，以增强 Java 语言的体验性、可读性。\r\n\r\n- 使用举例\r\n\r\n\r\n```java\r\n//1.局部变量的实例化\r\nvar list = new ArrayList<String>();\r\n\r\nvar set = new LinkedHashSet<Integer>();\r\n\r\n//2.增强 for 循环中的索引\r\nfor (var v : list) {\r\n    System.out.println(v);\r\n}\r\n\r\n//3.传统 for 循环中\r\nfor (var i = 0; i < 100; i++) {\r\n    System.out.println(i);\r\n}\r\n\r\n//4. 返回值类型含复杂泛型结构\r\nvar iterator = set.iterator();\r\n//Iterator<Map.Entry<Integer, Student>> iterator = set.iterator();\r\n\r\n```\r\n\r\n- 不适用场景\r\n  - 声明一个成员变量\r\n  - 声明一个数组变量，并为数组静态初始化（省略 new 的情况下）\r\n  - 方法的返回值类型\r\n  - 方法的参数类型\r\n  - 没有初始化的方法内的局部变量声明\r\n  - 作为 catch 块中异常类型\r\n  - Lambda 表达式中函数式接口的类型\r\n  - 方法引用中函数式接口的类型\r\n\r\n代码举例：\r\n\r\n声明一个成员变量，并初始化值为 null\r\n\r\n![image-20230417134811326](./assets/image-20230417134811326.png)\r\n\r\n声明一个数组变量，并为数组静态初始化（省略 new 的情况下）\r\n\r\n![image-20230417134814009](./assets/image-20230417134814009.png)\r\n\r\n没有初始化的方法内的局部变量声明\r\n\r\n![image-20230417134818419](./assets/image-20230417134818419.png)\r\n\r\n方法的返回值类型\r\n\r\n![image-20230417134825807](./assets/image-20230417134825807.png)\r\n\r\n方法的参数类型\r\n\r\n![image-20230417134832414](./assets/image-20230417134832414.png)\r\n\r\n构造器的参数类型\r\n\r\n![image-20230417134837238](./assets/image-20230417134837238.png)\r\n\r\n作为 catch 块中异常类型\r\n\r\n![image-20230417134842240](./assets/image-20230417134842240.png)\r\n\r\nLambda 表达式中函数式接口的类型\r\n\r\n![image-20220528155423180](./assets/image-20230417134847064.png)\r\n\r\n方法引用中函数式接口的类型\r\n\r\n![image-20230417134851471](./assets/image-20230417134851471.png)\r\n\r\n**注意：**\r\n\r\n- var 不是一个关键字，而是一个类型名，将它作为变量的类型。不能使用 var 作为类名。\r\n\r\n- 这不是 JavaScript。var 并不会改变 Java 是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。\r\n\r\n### instanceof 的模式匹配\r\n\r\n**JDK14 中预览特性：**\r\n\r\ninstanceof 模式匹配通过提供更为简便的语法，来提高生产力。有了该功能，可以减少 Java 程序中显式强制转换的数量，实现更精确、简洁的类型安全的代码。\r\n\r\nJava 14 之前旧写法：\r\n\r\n```java\r\nif(obj instanceof String){\r\n    String str = (String)obj; //需要强转\r\n    .. str.contains(..)..\r\n}else{\r\n    ...\r\n}\r\n```\r\n\r\nJava 14 新特性写法：\r\n\r\n```java\r\nif(obj instanceof String str){\r\n    .. str.contains(..)..\r\n}else{\r\n    ...\r\n}\r\n```\r\n\r\n举例：\r\n\r\n```java\r\n/**\r\n * instanceof 的模式匹配（预览）\r\n *\r\n * @author shkstart\r\n * @create 上午 11:32\r\n */\r\npublic class Feature01 {\r\n    @Test\r\n    public void test1(){\r\n\r\n        Object obj = new String(\"hello,Java14\");\r\n        obj = null;//在使用 null 匹配 instanceof 时，返回都是 false.\r\n        if(obj instanceof String){\r\n            String str = (String) obj;\r\n            System.out.println(str.contains(\"Java\"));\r\n        }else{\r\n            System.out.println(\"非 String 类型\");\r\n        }\r\n\r\n        //举例 1：\r\n        if(obj instanceof String str){ //新特性：省去了强制类型转换的过程\r\n            System.out.println(str.contains(\"Java\"));\r\n        }else{\r\n            System.out.println(\"非 String 类型\");\r\n        }\r\n    }\r\n}\r\n\r\n// 举例 2\r\nclass InstanceOf{\r\n\r\n    String str = \"abc\";\r\n\r\n    public void test(Object obj){\r\n\r\n        if(obj instanceof String str){//此时的 str 的作用域仅限于 if 结构内。\r\n            System.out.println(str.toUpperCase());\r\n        }else{\r\n            System.out.println(str.toLowerCase());\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n//举例 3：\r\nclass Monitor{\r\n    private String model;\r\n    private double price;\r\n\r\n//    public boolean equals(Object o){\r\n//        if(o instanceof Monitor other){\r\n//            if(model.equals(other.model) && price == other.price){\r\n//                return true;\r\n//            }\r\n//        }\r\n//        return false;\r\n//    }\r\n\r\n\r\n    public boolean equals(Object o){\r\n        return o instanceof Monitor other && model.equals(other.model) && price == other.price;\r\n    }\r\n\r\n}\r\n```\r\n\r\n**JDK15 中第二次预览：**\r\n\r\n没有任何更改。\r\n\r\n**JDK16 中转正特性：**\r\n\r\n在 Java16 中转正。\r\n\r\n### switch 表达式\r\n\r\n传统 switch 声明语句的弊端：\r\n\r\n- 匹配是自上而下的，如果忘记写 break，后面的 case 语句不论匹配与否都会执行； --->case 穿透\r\n- 所有的 case 语句共用一个块范围，在不同的 case 语句定义的变量名不能重复；\r\n- 不能在一个 case 里写多个执行结果一致的条件；\r\n- 整个 switch 不能作为表达式返回值；\r\n\r\n```java\r\n//常见错误实现\r\nswitch(month){\r\n    case 3|4|5://3|4|5 用了位运算符，11 | 100 | 101 结果是 111 是 7\r\n        System.out.println(\"春季\");\r\n        break;\r\n    case 6|7|8://6|7|8 用了位运算符，110 | 111 | 1000 结果是 1111 是 15\r\n        System.out.println(\"夏季\");\r\n        break;\r\n    case 9|10|11://9|10|11 用了位运算符，1001 | 1010 | 1011 结果是 1011 是 11\r\n        System.out.println(\"秋季\");\r\n        break;\r\n    case 12|1|2://12|1|2 用了位运算符，1100 | 1 | 10 结果是 1111，是 15\r\n        System.out.println(\"冬季\");\r\n        break;\r\n    default:\r\n        System.out.println(\"输入有误\");\r\n}\r\n```\r\n\r\n**JDK12 中预览特性：**\r\n\r\n- Java 12 将会对 switch 声明语句进行扩展，使用`case L ->`来替代以前的`break;`，省去了 break 语句，避免了因少写 break 而出错。\r\n\r\n- 同时将多个 case 合并到一行，显得简洁、清晰，也更加优雅的表达逻辑分支。\r\n\r\n- 为了保持兼容性，case 条件语句中依然可以使用字符` :` ，但是同一个 switch 结构里不能混用` ->` 和` :` ，否则编译错误。\r\n\r\n\r\n举例：\r\n\r\nJava 12 之前\r\n\r\n```java\r\n/**\r\n * @author shkstart\r\n * @create 下午 4:47\r\n */\r\npublic class SwitchTest {\r\n    public static void main(String[] args) {\r\n        int numberOfLetters;\r\n        Fruit fruit = Fruit.APPLE;\r\n        switch (fruit) {\r\n            case PEAR:\r\n                numberOfLetters = 4;\r\n                break;\r\n            case APPLE:\r\n            case GRAPE:\r\n            case MANGO:\r\n                numberOfLetters = 5;\r\n                break;\r\n            case ORANGE:\r\n            case PAPAYA:\r\n                numberOfLetters = 6;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"No Such Fruit:\" + fruit);\r\n        }\r\n        System.out.println(numberOfLetters);\r\n\r\n    }\r\n}\r\nenum Fruit {\r\n    PEAR, APPLE, GRAPE, MANGO, ORANGE, PAPAYA;\r\n}\r\n```\r\n\r\nswitch 语句如果漏写了一个 break，那么逻辑往往就跑偏了，这种方式既繁琐，又容易出错。\r\n\r\nJava 12 中：\r\n\r\n```java\r\n/**\r\n * @author shkstart\r\n * @create 下午 10:38\r\n */\r\npublic class SwitchTest1 {\r\n    public static void main(String[] args) {\r\n        Fruit fruit = Fruit.GRAPE;\r\n        switch(fruit){\r\n            case PEAR -> System.out.println(4);\r\n            case APPLE,MANGO,GRAPE -> System.out.println(5);\r\n            case ORANGE,PAPAYA -> System.out.println(6);\r\n            default -> throw new IllegalStateException(\"No Such Fruit:\" + fruit);\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n更进一步：\r\n\r\n```java\r\n/**\r\n * @author shkstart\r\n * @create 2019 下午 10:44\r\n */\r\npublic class SwitchTest2 {\r\n    public static void main(String[] args) {\r\n        Fruit fruit = Fruit.GRAPE;\r\n        int numberOfLetters = switch(fruit){\r\n            case PEAR -> 4;\r\n            case APPLE,MANGO,GRAPE -> 5;\r\n            case ORANGE,PAPAYA -> 6;\r\n            default -> throw new IllegalStateException(\"No Such Fruit:\" + fruit);\r\n        };\r\n        System.out.println(numberOfLetters);\r\n    }\r\n}\r\n```\r\n\r\n**JDK13 中二次预览特性：**\r\n\r\nJDK13 中引入了 yield 语句，用于返回值。这意味着，switch 表达式 (返回值) 应该使用 yield，switch 语句 (不返回值) 应该使用 break。\r\n\r\nyield 和 return 的区别在于：return 会直接跳出当前循环或者方法，而 yield 只会跳出当前 switch 块。\r\n\r\n在以前：\r\n\r\n```java\r\n@Test\r\npublic void testSwitch1(){\r\n    String x = \"3\";\r\n    int i;\r\n    switch (x) {\r\n        case \"1\":\r\n            i=1;\r\n            break;\r\n        case \"2\":\r\n            i=2;\r\n            break;\r\n        default:\r\n            i = x.length();\r\n            break;\r\n    }\r\n    System.out.println(i);\r\n}\r\n```\r\n\r\n在 JDK13 中：\r\n\r\n```java\r\n@Test\r\npublic void testSwitch2(){\r\n    String x = \"3\";\r\n    int i = switch (x) {\r\n        case \"1\" -> 1;\r\n        case \"2\" -> 2;\r\n        default -> {\r\n            yield 3;\r\n        }\r\n    };\r\n    System.out.println(i);\r\n}\r\n```\r\n\r\n或者\r\n\r\n```java\r\n@Test\r\npublic void testSwitch3() {\r\n    String x = \"3\";\r\n    int i = switch (x) {\r\n        case \"1\":\r\n            yield 1;\r\n        case \"2\":\r\n            yield 2;\r\n        default:\r\n            yield 3;\r\n    };\r\n    System.out.println(i);\r\n}\r\n```\r\n\r\n**JDK14 中转正特性：**\r\n\r\n这是 JDK 12 和 JDK 13 中的预览特性，现在是正式特性了。\r\n\r\n**JDK17 的预览特性：switch 的模式匹配**\r\n\r\n旧写法：\r\n\r\n```java\r\nstatic String formatter(Object o) {\r\n    String formatted = \"unknown\";\r\n    if (o instanceof Integer i) {\r\n        formatted = String.format(\"int %d\", i);\r\n    } else if (o instanceof Long l) {\r\n        formatted = String.format(\"long %d\", l);\r\n    } else if (o instanceof Double d) {\r\n        formatted = String.format(\"double %f\", d);\r\n    } else if (o instanceof String s) {\r\n        formatted = String.format(\"String %s\", s);\r\n    }\r\n    return formatted;\r\n}\r\n```\r\n\r\n模式匹配新写法：\r\n\r\n```java\r\nstatic String formatterPatternSwitch(Object o) {\r\n    return switch (o) {\r\n        case Integer i -> String.format(\"int %d\", i);\r\n        case Long l    -> String.format(\"long %d\", l);\r\n        case Double d  -> String.format(\"double %f\", d);\r\n        case String s  -> String.format(\"String %s\", s);\r\n        default        -> o.toString();\r\n    };\r\n}\r\n```\r\n\r\n直接在 switch 上支持 Object 类型，这就等于同时支持多种类型，使用模式匹配得到具体类型，大大简化了语法量，这个功能很实用。\r\n\r\n### 文本块\r\n\r\n现实问题：\r\n\r\n在 Java 中，通常需要使用 String 类型表达 HTML，XML，SQL 或 JSON 等格式的字符串，在进行字符串赋值时需要进行转义和连接操作，然后才能编译该代码，这种表达方式难以阅读并且难以维护。\r\n\r\n**JDK13 的新特性**\r\n\r\n使用\"\"\"作为文本块的开始符和结束符，在其中就可以放置多行的字符串，不需要进行任何转义。因此，文本块将提高 Java 程序的可读性和可写性。\r\n\r\n基本使用：\r\n\r\n```java\r\n\"\"\"\r\nline1\r\nline2\r\nline3\r\n\"\"\"\r\n```\r\n\r\n相当于：\r\n\r\n```java\r\n\"line1\\nline2\\nline3\\n\"\r\n```\r\n\r\n或者一个连接的字符串：\r\n\r\n```java\r\n\"line1\\n\" +\r\n\"line2\\n\" +\r\n\"line3\\n\"\r\n```\r\n\r\n如果字符串末尾不需要行终止符，则结束分隔符可以放在最后一行内容上。例如：\r\n\r\n```java\r\n\"\"\"\r\nline1\r\nline2\r\nline3\"\"\"\r\n```\r\n\r\n相当于\r\n\r\n```java\r\n\"line1\\nline2\\nline3\"\r\n```\r\n\r\n文本块可以表示空字符串，但不建议这样做，因为它需要两行源代码：\r\n\r\n```java\r\nString empty = \"\"\"\r\n\"\"\";\r\n```\r\n\r\n举例 1：普通文本\r\n\r\n原有写法：\r\n\r\n```java\r\n String text1 = \"The Sound of silence\\n\" +\r\n                \"Hello darkness, my old friend\\n\" +\r\n                \"I've come to talk with you again\\n\" +\r\n                \"Because a vision softly creeping\\n\" +\r\n                \"Left its seeds while I was sleeping\\n\" +\r\n                \"And the vision that was planted in my brain\\n\" +\r\n                \"Still remains\\n\" +\r\n                \"Within the sound of silence\";\r\n\r\nSystem.out.println(text1);\r\n```\r\n\r\n使用新特性：\r\n\r\n```java\r\nString text2 = \"\"\"\r\n                The Sound of silence\r\n                Hello darkness, my old friend\r\n                I've come to talk with you again\r\n                Because a vision softly creeping\r\n                Left its seeds while I was sleeping\r\n                And the vision that was planted in my brain\r\n                Still remains\r\n                Within the sound of silence\r\n                \"\"\";\r\nSystem.out.println(text2);\r\n```\r\n\r\n举例 2：HTML 语句\r\n\r\n```html\r\n<html>\r\n  <body>\r\n      <p>Hello, 尚硅谷</p>\r\n  </body>\r\n</html>\r\n```\r\n\r\n将其复制到 Java 的字符串中，会展示成以下内容：\r\n\r\n```java\r\n\"<html>\\n\" +\r\n\"    <body>\\n\" +\r\n\"        <p>Hello, 尚硅谷</p>\\n\" +\r\n\"    </body>\\n\" +\r\n\"</html>\\n\";\r\n```\r\n\r\n即被自动进行了转义，这样的字符串看起来不是很直观，在 JDK 13 中：\r\n\r\n```java\r\n\"\"\"\r\n<html>\r\n  <body>\r\n      <p>Hello, world</p>\r\n  </body>\r\n</html>\r\n\"\"\";\r\n```\r\n\r\n举例 3：SQL 语句\r\n\r\n```sql\r\nselect employee_id,last_name,salary,department_id\r\nfrom employees\r\nwhere department_id in (40,50,60)\r\norder by department_id asc\r\n```\r\n\r\n原有方式：\r\n\r\n```java\r\nString sql = \"SELECT id,NAME,email\\n\" +\r\n                \"FROM customers\\n\" +\r\n                \"WHERE id > 4\\n\" +\r\n                \"ORDER BY email DESC\";\r\n```\r\n\r\n使用新特性：\r\n\r\n```java\r\nString sql1 = \"\"\"\r\n                SELECT id,NAME,email\r\n                FROM customers\r\n                WHERE id > 4\r\n                ORDER BY email DESC\r\n                \"\"\";\r\n```\r\n\r\n举例 4：JSON 字符串\r\n\r\n原有方式：\r\n\r\n```java\r\nString myJson = \"{\\n\" +\r\n                \"    \\\"name\\\":\\\"Song Hongkang\\\",\\n\" +\r\n                \"     \\\"address\\\":\\\"www.atguigu.com\\\",\\n\" +\r\n                \"    \\\"email\\\":\\\"shkstart@126.com\\\"\\n\" +\r\n                \"}\";\r\nSystem.out.println(myJson);\r\n```\r\n\r\n使用新特性：\r\n\r\n```java\r\nString myJson1 = \"\"\"\r\n                {\r\n                    \"name\":\"Song Hongkang\",\r\n                     \"address\":\"www.atguigu.com\",\r\n                    \"email\":\"shkstart@126.com\"\r\n                }\"\"\";\r\nSystem.out.println(myJson1);\r\n```\r\n\r\n**JDK14 中二次预览特性**\r\n\r\nJDK14 的版本主要增加了两个 escape sequences，分别是` \\ <line-terminator>`与`\\s  escape sequence`。\r\n\r\n举例：\r\n\r\n```java\r\n/**\r\n * @author shkstart\r\n * @create 下午 7:13\r\n */\r\npublic class Feature05 {\r\n    //jdk14 新特性\r\n    @Test\r\n    public void test5(){\r\n        String sql1 = \"\"\"\r\n                SELECT id,NAME,email\r\n                FROM customers\r\n                WHERE id > 4\r\n                ORDER BY email DESC\r\n                \"\"\";\r\n        System.out.println(sql1);\r\n\r\n        // \\:取消换行操作\r\n        // \\s:表示一个空格\r\n        String sql2 = \"\"\"\r\n                SELECT id,NAME,email \\\r\n                FROM customers\\s\\\r\n                WHERE id > 4 \\\r\n                ORDER BY email DESC\r\n                \"\"\";\r\n        System.out.println(sql2);\r\n    }\r\n}\r\n```\r\n\r\n**JDK15 中功能转正**\r\n\r\n### Record\r\n\r\n`背景`\r\n\r\n早在 2019 年 2 月份，Java 语言架构师 Brian Goetz，曾写文抱怨“`Java太啰嗦`”或有太多的“繁文缛节”。他提到：开发人员想要创建纯数据载体类（plain data carriers）通常都必须编写大量低价值、重复的、容易出错的代码。如：构造函数、getter/setter、equals()、hashCode() 以及 toString() 等。\r\n\r\n以至于很多人选择使用 IDE 的功能来自动生成这些代码。还有一些开发会选择使用一些第三方类库，如 Lombok 等来生成这些方法。\r\n\r\n**JDK14 中预览特性：神说要用 record，于是就有了。**实现一个简单的数据载体类，为了避免编写：构造函数，访问器，equals()，hashCode () ，toString () 等，Java 14 推出 record。\r\n\r\n`record` 是一种全新的类型，它本质上是一个 `final` 类，同时所有的属性都是 `final` 修饰，它会自动编译出 `public get` 、`hashcode` 、`equals`、`toString`、构造器等结构，减少了代码编写量。\r\n\r\n具体来说：当你用`record` 声明一个类时，该类将自动拥有以下功能：\r\n\r\n- 获取成员变量的简单方法，比如例题中的 name() 和 partner() 。注意区别于我们平常 getter() 的写法。\r\n- 一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。\r\n- 重写 hashCode() 方法。\r\n- 一个可以打印该类所有成员属性的 toString() 方法。\r\n- 只有一个构造方法。\r\n\r\n此外：\r\n\r\n- 还可以在 record 声明的类中定义静态字段、静态方法、构造器或实例方法。\r\n\r\n- 不能在 record 声明的类中定义实例字段；类不能声明为 abstract；不能声明显式的父类等。\r\n\r\n\r\n举例 1（旧写法）：\r\n\r\n```java\r\nclass Point {\r\n    private final int x;\r\n    private final int y;\r\n\r\n    Point(int x, int y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    int x() {\r\n        return x;\r\n    }\r\n\r\n    int y() {\r\n        return y;\r\n    }\r\n\r\n    public boolean equals(Object o) {\r\n        if (!(o instanceof Point)) return false;\r\n        Point other = (Point) o;\r\n        return other.x == x && other.y == y;\r\n    }\r\n\r\n    public int hashCode() {\r\n        return Objects.hash(x, y);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Point{\" +\r\n                \"x=\" + x +\r\n                \", y=\" + y +\r\n                '}';\r\n    }\r\n}\r\n```\r\n\r\n举例 1（新写法）：\r\n\r\n```java\r\nrecord Point(int x, int y) { }\r\n```\r\n\r\n举例 1：\r\n\r\n```java\r\npublic record Dog(String name, Integer age) {\r\n}\r\n```\r\n\r\n```java\r\npublic class Java14Record {\r\n\r\n    public static void main(String[] args) {\r\n        Dog dog1 = new Dog(\"牧羊犬\", 1);\r\n        Dog dog2 = new Dog(\"田园犬\", 2);\r\n        Dog dog3 = new Dog(\"哈士奇\", 3);\r\n        System.out.println(dog1);\r\n        System.out.println(dog2);\r\n        System.out.println(dog3);\r\n    }\r\n}\r\n```\r\n\r\n举例 2：\r\n\r\n```java\r\n/**\r\n *  Record 类型的演示\r\n *\r\n * @author shkstart\r\n * @create 下午 6:13\r\n */\r\npublic class Feature07 {\r\n    @Test\r\n    public void test1(){\r\n        //测试构造器\r\n        Person p1 = new Person(\"罗密欧\",new Person(\"zhuliye\",null));\r\n        //测试 toString()\r\n        System.out.println(p1);\r\n        //测试 equals():\r\n        Person p2 = new Person(\"罗密欧\",new Person(\"zhuliye\",null));\r\n        System.out.println(p1.equals(p2));\r\n\r\n        //测试 hashCode() 和 equals()\r\n        HashSet<Person> set = new HashSet<>();\r\n        set.add(p1);\r\n        set.add(p2);\r\n\r\n        for (Person person : set) {\r\n            System.out.println(person);\r\n        }\r\n\r\n        //测试 name() 和 partner():类似于 getName() 和 getPartner()\r\n        System.out.println(p1.name());\r\n        System.out.println(p1.partner());\r\n\r\n    }\r\n\r\n    @Test\r\n    public void test2(){\r\n        Person p1 = new Person(\"zhuyingtai\");\r\n\r\n        System.out.println(p1.getNameInUpperCase());\r\n\r\n        Person.nation = \"CHN\";\r\n        System.out.println(Person.showNation());\r\n\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n/**\r\n * @author shkstart\r\n * @create 下午 6:20\r\n */\r\npublic record Person(String name,Person partner) {\r\n\r\n    //还可以声明静态的属性、静态的方法、构造器、实例方法\r\n\r\n    public static String nation;\r\n\r\n    public static String showNation(){\r\n        return nation;\r\n    }\r\n\r\n    public Person(String name){\r\n        this(name,null);\r\n    }\r\n\r\n    public String getNameInUpperCase(){\r\n        return name.toUpperCase();\r\n    }\r\n    //不可以声明非静态的属性\r\n//    private int id;//报错\r\n}\r\n\r\n//不可以将 record 定义的类声明为 abstract 的\r\n//abstract record Order(){\r\n//\r\n//}\r\n\r\n//不可以给 record 定义的类声明显式的父类（非 Record 类）\r\n//record Order() extends Thread{\r\n//\r\n//}\r\n```\r\n\r\n**JDK15 中第二次预览特性**\r\n\r\n**JDK16 中转正特性**\r\n\r\n最终到 JDK16 中转正。\r\n\r\n`记录不适合哪些场景`\r\n\r\nrecord 的设计目标是提供一种将数据建模为数据的好方法。它也不是 JavaBeans 的直接替代品，因为 record 的方法不符合 JavaBeans 的 get 标准。另外 JavaBeans 通常是可变的，而记录是不可变的。尽管它们的用途有点像，但记录并不会以某种方式取代 JavaBean。\r\n\r\n### 密封类\r\n\r\n背景：\r\n\r\n在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 `final` 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 `sealed` 类，被 `sealed` 修饰的类可以指定子类。这样这个类就只能被指定的类继承。\r\n\r\n**JDK15 的预览特性：**\r\n\r\n通过密封的类和接口来限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其它类或接口。\r\n\r\n具体使用：\r\n\r\n- 使用修饰符`sealed`，可以将一个类声明为密封类。密封的类使用保留关键字`permits`列出可以直接扩展（即 extends）它的类。\r\n\r\n\r\n-  `sealed` 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 `final`、`sealed`、`non-sealed` 三者之一。\r\n\r\n\r\n举例：\r\n\r\n```java\r\npackage com.atguigu.java;\r\npublic abstract sealed class Shape permits Circle, Rectangle, Square {...}\r\n\r\npublic final class Circle extends Shape {...} //final 表示 Circle 不能再被继承了\r\n\r\npublic sealed class Rectangle extends Shape permits TransparentRectangle, FilledRectangle {...}\r\n\r\npublic final class TransparentRectangle extends Rectangle {...}\r\n\r\npublic final class FilledRectangle extends Rectangle {...}\r\n\r\npublic non-sealed class Square extends Shape {...} //non-sealed 表示可以允许任何类继承\r\n```\r\n\r\n**JDK16 二次预览特性**\r\n\r\n**JDK17 中转正特性**\r\n\r\n## API 的变化\r\n\r\n### Optional 类\r\n\r\n**JDK8 的新特性**\r\n\r\n到目前为止，臭名昭著的空指针异常是导致 Java 应用程序失败的最常见原因。以前，为了解决空指针异常，Google 在著名的 Guava 项目引入了 Optional 类，通过检查空值的方式避免空指针异常。受到 Google 的启发，Optional 类已经成为 Java 8 类库的一部分。\r\n\r\n`Optional<T>` 类 (java.util.Optional) 是一个容器类，它可以保存类型 T 的值，代表这个值存在。或者仅仅保存 null，表示这个值不存在。如果值存在，则 isPresent() 方法会返回 true，调用 get() 方法会返回该对象。\r\n\r\nOptional 提供很多有用的方法，这样我们就不用显式进行空值检测。\r\n\r\n- `创建Optional类对象的方法：`\r\n- `static <T> Optional<T> empty()` ：用来创建一个空的 Optional 实例\r\n  - `static <T> Optional<T> of(T value)` ：用来创建一个 Optional 实例，value 必须非空\r\n  - `static <T> Optional<T> ofNullable(T value)` ：用来创建一个 Optional 实例，value 可能是空，也可能非空\r\n\r\n- `判断Optional容器中是否包含对象：`\r\n\r\n  - `boolean isPresent()` : 判断 Optional 容器中的值是否存在\r\n  - `void ifPresent(Consumer<? super T> consumer)` ：判断 Optional 容器中的值是否存在，如果存在，就对它进行 Consumer 指定的操作，如果不存在就不做\r\n\r\n- `获取Optional容器的对象：`\r\n- T get(): 如果调用对象包含值，返回该值。否则抛异常。T get() 与 of(T value) 配合使用\r\n\r\n- `T orElse(T other) `：orElse(T other) 与 ofNullable(T value) 配合使用，如果 Optional 容器中非空，就返回所包装值，如果为空，就用 orElse(T other)other 指定的默认值（备胎）代替\r\n\r\n- `T orElseGet(Supplier<? extends T> other)` ：如果 Optional 容器中非空，就返回所包装值，如果为空，就用 Supplier 接口的 Lambda 表达式提供的值代替\r\n\r\n- `T orElseThrow(Supplier<? extends X> exceptionSupplier)` ：如果 Optional 容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的 NoSuchElementException\r\n\r\n举例：\r\n\r\n```java\r\npublic class TestOptional {\r\n\t@Test\r\n    public void test1(){\r\n        String str = \"hello\";\r\n        Optional<String> opt = Optional.of(str);\r\n        System.out.println(opt);\r\n    }\r\n    @Test\r\n    public void test2(){\r\n        Optional<String> opt = Optional.empty();\r\n        System.out.println(opt);\r\n    }\r\n    @Test\r\n    public void test3(){\r\n        String str = null;\r\n        Optional<String> opt = Optional.ofNullable(str);\r\n        System.out.println(opt);\r\n    }\r\n    @Test\r\n    public void test4(){\r\n        String str = \"hello\";\r\n        Optional<String> opt = Optional.of(str);\r\n\r\n        String string = opt.get();\r\n        System.out.println(string);\r\n    }\r\n    @Test\r\n    public void test5(){\r\n        String str = null;\r\n        Optional<String> opt = Optional.ofNullable(str);\r\n//\t\tSystem.out.println(opt.get());//java.util.NoSuchElementException: No value present\r\n    }\r\n    @Test\r\n    public void test6(){\r\n        String str = \"hello\";\r\n        Optional<String> opt = Optional.ofNullable(str);\r\n        String string = opt.orElse(\"atguigu\");\r\n        System.out.println(string);\r\n    }\r\n    @Test\r\n    public void test7(){\r\n        String str = null;\r\n        Optional<String> opt = Optional.ofNullable(str);\r\n        String string = opt.orElseGet(String::new);\r\n        System.out.println(string);\r\n    }\r\n    @Test\r\n    public void test8(){\r\n        String str = null;\r\n        Optional<String> opt = Optional.ofNullable(str);\r\n        String string = opt.orElseThrow(()->new RuntimeException(\"值不存在\"));\r\n        System.out.println(string);\r\n    }\r\n    @Test\r\n    public void test9(){\r\n        String str = \"Hello1\";\r\n        Optional<String> opt = Optional.ofNullable(str);\r\n        //判断是否是纯字母单词，如果是，转为大写，否则保持不变\r\n        String result = opt.filter(s->s.matches(\"[a-zA-Z]+\"))\r\n                .map(s -> s.toUpperCase()).orElse(str);\r\n        System.out.println(result);\r\n    }\r\n}\r\n\r\n```\r\n\r\n**这是 JDK9-11 的新特性**\r\n\r\n| **新增方法**                                                         | **描述**                                                             | **新增的版本** |\r\n| -------------------------------------------------------------------- | -------------------------------------------------------------------- | -------------- |\r\n| `boolean isEmpty()`                                                  | 判断 value 是否为空                                                  | JDK  11        |\r\n| `ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`  | value 非空，执行参数 1 功能；如果 value 为空，执行参数 2 功能        | JDK  9         |\r\n| `Optional<T> or(Supplier<? extends Optional<? extends T>> supplier)` | value 非空，返回对应的 Optional；value 为空，返回形参封装的 Optional | JDK  9         |\r\n| `Stream<T> stream()`                                                 | value 非空，返回仅包含此 value 的 Stream；否则，返回一个空的 Stream  | JDK  9         |\r\n| `T orElseThrow()`                                                    | value 非空，返回 value；否则抛异常 NoSuchElementException            | JDK  10        |\r\n\r\n### String 存储结构和 API 变更\r\n\r\n**这是 JDK9 的新特性。**\r\n\r\n产生背景：\r\n\r\n> Motivation\r\n>\r\n> The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.\r\n\r\n使用说明：\r\n\r\n> ## Description\r\n>\r\n> We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.\r\n\r\n结论：String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。\r\n\r\n```java\r\npublic final class String\r\n    implements java.io.Serializable, Comparable<String>, CharSequence {\r\n    @Stable\r\n    private final byte[] value;\r\n\t...\r\n}\r\n```\r\n\r\n拓展：StringBuffer 与 StringBuilder\r\n\r\n那 StringBuffer 和 StringBuilder 是否仍无动于衷呢？\r\n\r\n> String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM's intrinsic string operations.\r\n\r\n**JDK11 新特性：新增了一系列字符串处理方法**\r\n\r\n| **描述**             | **举例**                                        |\r\n| -------------------- | ----------------------------------------------- |\r\n| 判断字符串是否为空白 | \"  \".isBlank(); // true                         |\r\n| 去除首尾空白         | \"  Javastack \".strip(); // \"Javastack\"          |\r\n| 去除尾部空格         | \"  Javastack \".stripTrailing(); // \" Javastack\" |\r\n| 去除首部空格         | \"  Javastack \".stripLeading(); // \"Javastack \"  |\r\n| 复制字符串           | \"Java\".repeat(3);//  \"JavaJavaJava\"             |\r\n| 行数统计             | \"A\\nB\\nC\".lines().count();  // 3                |\r\n\r\n**JDK12 新特性：String 实现了 Constable 接口**\r\n\r\nString 源码：\r\n\r\n```java\r\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence,Constable, ConstantDesc {\r\n    \r\n}\r\n```\r\n\r\njava.lang.constant.Constable 接口定义了抽象方法：\r\n\r\n```java\r\npublic interface Constable {\r\n\tOptional<? extends ConstantDesc> describeConstable();\r\n}\r\n```\r\n\r\nJava 12 String 的实现源码：\r\n\r\n```java\r\n/**\r\n * Returns an {@link Optional} containing the nominal descriptor for this\r\n * instance, which is the instance itself.\r\n *\r\n * @return an {@link Optional} describing the {@linkplain String} instance\r\n * @since 12\r\n */\r\n@Override\r\npublic Optional<String> describeConstable() {\r\n\treturn Optional.of(this);\r\n}\r\n```\r\n\r\n很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型。\r\n\r\n举例：\r\n\r\n```java\r\nprivate static void testDescribeConstable() {\r\n\tString name = \"尚硅谷 Java 高级工程师\";\r\n\tOptional<String> optional = name.describeConstable();\r\n\tSystem.out.println(optional.get());\r\n}\r\n```\r\n\r\n结果输出：\r\n\r\n```\r\n尚硅谷Java高级工程师\r\n```\r\n\r\n**JDK12 新特性：String 新增方法**\r\n\r\nString 的 transform(Function)\r\n\r\n```java\r\nvar result = \"foo\".transform(input -> input + \" bar\");\r\nSystem.out.println(result); //foo bar\r\n```\r\n\r\n或者\r\n\r\n```java\r\nvar result = \"foo\".transform(input -> input + \" bar\").transform(String::toUpperCase)\r\nSystem.out.println(result); //FOO BAR\r\n```\r\n\r\n对应的源码：\r\n\r\n```java\r\n/**\r\n* This method allows the application of a function to {@code this}\r\n* string. The function should expect a single String argument\r\n* and produce an {@code R} result.\r\n* @since 12\r\n*/\r\npublic <R> R transform(Function<? super String, ? extends R> f) {\r\n return f.apply(this);\r\n}\r\n```\r\n\r\n在某种情况下，该方法应该被称为 map()。\r\n\r\n举例：\r\n\r\n```java\r\nprivate static void testTransform() {\r\n\tSystem.out.println(\"======test java 12 transform======\");\r\n\tList<String> list1 = List.of(\"Java\", \" Python\", \" C++ \");\r\n\tList<String> list2 = new ArrayList<>();\r\n\tlist1.forEach(element -> list2.add(element.transform(String::strip)\r\n\t\t\t\t\t\t\t\t  .transform(String::toUpperCase)\r\n\t\t\t\t\t\t\t\t  .transform((e) -> \"Hi,\" + e))\r\n\t\t\t\t );\r\n\tlist2.forEach(System.out::println);\r\n}\r\n```\r\n\r\n结果输出：\r\n\r\n```java\r\n======test java 12 transform======\r\nHi,JAVA\r\nHi,PYTHON\r\nHi,C++\r\n```\r\n\r\n如果使用 Java 8 的 Stream 特性，可以如下实现：\r\n\r\n```java\r\nprivate static void testTransform1() {\r\n        System.out.println(\"======test before java 12 ======\");\r\n        List<String> list1 = List.of(\"Java  \", \" Python\", \" C++ \");\r\n\r\n        Stream<String> stringStream = list1.stream().map(element -> element.strip()).map(String::toUpperCase).map(element -> \"Hello,\" + element);\r\n        List<String> list2 = stringStream.collect(Collectors.toList());\r\n        list2.forEach(System.out::println);\r\n    }\r\n```\r\n\r\n### JDK17：标记删除 Applet API\r\n\r\nApplet API 提供了一种将 Java AWT/Swing 控件嵌入到浏览器网页中的方法。不过，目前 Applet 已经被淘汰。大部分人可能压根就没有用过 Applet。\r\n\r\nApplet API 实际上是无用的，因为所有 Web 浏览器供应商都已删除或透露计划放弃对 Java 浏览器插件的支持。Java 9 的时候，Applet API 已经被标记为过时，Java 17 的时候终于标记为删除了。\r\n\r\n具体如下：\r\n\r\n```java\r\njava.applet.Applet\r\njava.applet.AppletStub\r\njava.applet.AppletContext\r\njava.applet.AudioClip\r\njavax.swing.JApplet\r\njava.beans.AppletInitializer\r\n```\r\n\r\n## 其它结构变化\r\n\r\n### JDK9：UnderScore(下划线) 使用的限制\r\n\r\n在 java 8 中，标识符可以独立使用“_”来命名：\r\n\r\n```java\r\nString _ = \"hello\";\r\nSystem.out.println(_);\r\n```\r\n\r\n但是，在 java 9 中规定“_”不再可以单独命名标识符了，如果使用，会报错：\r\n\r\n![image-20230417134931764](./assets/image-20230417134931764.png)\r\n\r\n\r\n\r\n### JDK11：更简化的编译运行程序\r\n\r\n看下面的代码。\r\n\r\n```java\r\n// 编译\r\njavac JavaStack.java\r\n\r\n// 运行\r\njava JavaStack\r\n```\r\n\r\n我们的认知里，要运行一个 Java 源代码必须先编译，再运行。而在 Java 11 版本中，通过一个 java 命令就直接搞定了，如下所示：\r\n\r\n```\r\njava JavaStack.java\r\n```\r\n\r\n注意点：\r\n\r\n- 执行源文件中的第一个类，第一个类必须包含主方法。\r\n\r\n\r\n### GC 方面新特性\r\n\r\nGC 是 Java 主要优势之一。然而，当 GC 停顿太长，就会开始影响应用的响应时间。随着现代系统中内存不断增长，用户和程序员希望 JVM 能够以高效的方式充分利用这些内存，并且无需长时间的 GC 暂停时间。\r\n\r\n#### G1 GC\r\n\r\nJDK9 以后默认的垃圾回收器是 G1GC。\r\n\r\n**JDK10 : 为 G1 提供并行的 Full GC**\r\n\r\nG1 最大的亮点就是可以尽量的避免 full gc。但毕竟是“尽量”，在有些情况下，G1 就要进行 full gc 了，比如如果它无法足够快的回收内存的时候，它就会强制停止所有的应用线程然后清理。\r\n\r\n在 Java10 之前，一个单线程版的标记 - 清除 - 压缩算法被用于 full gc。为了尽量减少 full gc 带来的影响，在 Java10 中，就把之前的那个单线程版的标记 - 清除 - 压缩的 full gc 算法改成了支持多个线程同时 full gc。这样也算是减少了 full gc 所带来的停顿，从而提高性能。\r\n\r\n你可以通过`-XX:ParallelGCThreads`参数来指定用于并行 GC 的线程数。\r\n\r\n**JDK12：可中断的 G1 Mixed GC**\r\n\r\n**JDK12：增强 G1，自动返回未用堆内存给操作系统**\r\n\r\n#### Shenandoah GC\r\n\r\n**JDK12：Shenandoah GC：低停顿时间的 GC**\r\n\r\n![image-20230417134942033](./assets/image-20230417134942033.png)\r\n\r\nShenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在**针对 JVM 上的内存收回实现低停顿的需求**。\r\n\r\n据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。\r\n\r\nShenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。\r\n\r\n这是一个实验性功能，不包含在默认（Oracle）的 OpenJDK 版本中。\r\n\r\nShenandoah 开发团队在实际应用中的测试数据：\r\n\r\n![image-20230417134947936](./assets/image-20230417134947936.png)\r\n\r\n**JDK15：Shenandoah 垃圾回收算法转正**\r\n\r\nShenandoah 垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。\r\n\r\nShenandoah 在 JDK12 被作为 experimental 引入，在 JDK15 变为 Production；之前需要通过`-XX:+UnlockExperimentalVMOptions` `-XX:+UseShenandoahGC`来启用，现在只需要`-XX:+UseShenandoahGC`即可启用\r\n\r\n#### 革命性的 ZGC\r\n\r\n**JDK11：引入革命性的 ZGC**\r\n\r\nZGC，这应该是 JDK11 最为瞩目的特性，没有之一。 \r\n\r\nZGC 是一个并发、基于 region、压缩型的垃圾收集器。\r\n\r\nZGC 的设计目标是：支持 TB 级内存容量，暂停时间低（<10ms），对整个程序吞吐量的影响小于 15%。将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于 DRAM 和冷对象置于 NVMe 闪存），或压缩堆。\r\n\r\n**JDK13：ZGC:将未使用的堆内存归还给操作系统**\r\n\r\n**JDK14：ZGC on macOS 和 windows**\r\n\r\n- JDK14 之前，ZGC 仅 Linux 才支持。现在 mac 或 Windows 上也能使用 ZGC 了，示例如下：\r\n\r\n  ```\r\n  -XX:+UnlockExperimentalVMOptions -XX:+UseZGC\r\n  ```\r\n\r\n- ZGC 与 Shenandoah 目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在`十毫秒以内`的低延迟。\r\n\r\n\r\n![image-20230417134954402](./assets/image-20230417134954402.png)\r\n\r\n![image-20230417134958629](./assets/image-20230417134958629.png)\r\n\r\n**JDK15：ZGC 功能转正**\r\n\r\nZGC 是 Java 11 引入的新的垃圾收集器，经过了多个实验阶段，自此终于成为正式特性。\r\n\r\n但是这并不是替换默认的 GC，默认的 GC 仍然还是 G1；之前需要通过`-XX:+UnlockExperimentalVMOptions`、` -XX:+UseZGC`来启用 ZGC，现在只需要`-XX:+UseZGC`就可以。相信不久的将来它必将成为默认的垃圾回收器。\r\n\r\n> ZGC 的性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将成为服务端、大内存、低延迟应用的首选垃圾收集器。\r\n\r\n怎么形容 Shenandoah 和 ZGC 的关系呢？异同点大概如下：\r\n\r\n- 相同点：性能几乎可认为是相同的\r\n- 不同点：ZGC 是 Oracle JDK 的，根正苗红。而 Shenandoah 只存在于 OpenJDK 中，因此使用时需注意你的 JDK 版本\r\n\r\n**JDK16：ZGC 并发线程处理**\r\n\r\n在线程的堆栈处理过程中，总有一个制约因素就是 safepoints。在 safepoints 这个点，Java 的线程是要暂停执行的，从而限制了 GC 的效率。\r\n\r\n> 回顾：\r\n>\r\n> 我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们称为 **Stop The World**。\r\n>\r\n> 而为了实现 STW 这个操作，JVM 需要为每个线程选择一个点停止运行，这个点就叫做**安全点（Safepoints）**。\r\n\r\n而 ZGC 的并发线程堆栈处理可以保证 Java 线程可以在 GC safepoints 的同时可以并发执行。它有助于提高所开发的 Java 软件应用程序的性能和效率。\r\n\r\n## 小结与展望\r\n\r\n随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展方向。**传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微服务甚至是函数 (FaaS，Function-as-a-Service) 所替代。**\r\n\r\n**Java 需要在新的计算场景下，改进开发效率。**比如，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向。\r\n\r\nJava 虽然标榜面向对象编程，却毫不顾忌的加入`面向接口编程思想`，又扯出`匿名对象`的概念，每增加一个新的东西，对 Java 的根本（面向对象思想）的一次冲击。\r\n\r\n> 士，不可不弘毅，任重而道远。\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JDK/03.JDK8-17 新特性下.md b/src/java/JDK/03.JDK8-17 新特性下.md
--- a/src/java/JDK/03.JDK8-17 新特性下.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JDK/03.JDK8-17 新特性下.md	(date 1682519463976)
@@ -1,12 +1,5 @@
 ---
-title: JDK8-17 新特性下
-date: 2023-04-17 13:28:30
-permalink: /pages/e9766f/
-categories:
-  - Java
-  - JDK
-tags:
-  - 
+
 ---
 # JDK8-17 新特性下
 
Index: src/java/JDBC/08.数据库连接池.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 数据库连接池\r\ndate: 2023-04-09 22:42:11\r\npermalink: /pages/8ef52b/\r\ncategories:\r\n  - Java\r\n  - JDBC\r\ntags:\r\n  - \r\n---\r\n\r\n# 数据库连接池\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JDBC/08.数据库连接池.md b/src/java/JDBC/08.数据库连接池.md
--- a/src/java/JDBC/08.数据库连接池.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JDBC/08.数据库连接池.md	(date 1682512999785)
@@ -1,12 +1,5 @@
 ---
-title: 数据库连接池
-date: 2023-04-09 22:42:11
-permalink: /pages/8ef52b/
-categories:
-  - Java
-  - JDBC
-tags:
-  - 
+
 ---
 
 # 数据库连接池
Index: src/java/JDK/02.JDK8-17 新特性上.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: JDK8-17 新特性上\r\ndate: 2023-04-17 13:28:04\r\npermalink: /pages/fdec07/\r\ncategories:\r\n  - Java\r\n  - JDK\r\ntags:\r\n  - \r\n---\r\n# JDK8-17 新特性上\r\n\r\n官网：[http://www.atguigu.com](http://www.atguigu.com/)\r\n\r\n![image-20230417132933952](./assets/image-20230417132933952.png)\r\n\r\n***\r\n\r\n## Java 版本迭代概述\r\n\r\n### 发布特点（小步快跑，快速迭代）\r\n\r\n| 发行版本  |  发行时间  |                               备注                               |\r\n| :-------: | :--------: | :--------------------------------------------------------------: |\r\n| Java 1.0  | 1996.01.23 |              Sun 公司发布了 Java 的第一个开发工具包              |\r\n| Java 5.0  | 2004.09.30 | ①版本号从 1.4 直接更新至 5.0；②平台更名为 JavaSE、JavaEE、JavaME |\r\n| Java 8.0  | 2014.03.18 | 此版本是继 Java 5.0 以来变化最大的版本。是长期支持版本（`LTS`）  |\r\n| Java 9.0  | 2017.09.22 |                  **此版本开始，每半年更新一次**                  |\r\n| Java 10.0 | 2018.03.21 |                                                                  |\r\n| Java 11.0 | 2018.09.25 |      JDK 安装包取消独立 JRE 安装包，是长期支持版本（`LTS`）      |\r\n| Java 12.0 | 2019.03.19 |                                                                  |\r\n|    ...    |    ...     |                                                                  |\r\n| Java17.0  |  2021.09   |    发布 Java 17.0，版本号也称为 21.9，是长期支持版本（`LTS`）    |\r\n|    ...    |    ...     |                                                                  |\r\n| Java19.0  |  2022.09   |                发布 Java19.0，版本号也称为 22.9。                |\r\n\r\n从 Java 9 这个版本开始，Java 的计划发布周期是 `6个月`。\r\n\r\n这意味着 Java 的更新从传统的以`特性驱动`的发布周期，转变为以`时间驱动`的发布模式，并且承诺不会跳票。通过这样的方式，开发团队可以把一些关键特性尽早合并到 JDK 之中，以快速得到开发者反馈，在一定程度上避免出现像 Java 9 两次被迫延迟发布的窘况。\r\n\r\n针对企业客户的需求，Oracle 将以`三年`为周期发布长期支持版本（long term support）。\r\n\r\nOracle 的官方观点认为：**与 Java 7->8->9 相比，Java 9->10->11 的升级和 8->8u20->8u40 更相似。**\r\n\r\n新模式下的 Java 版本发布都会包含许多变更，包括`语言变更`和 `JVM 变更`，这两者都会对 IDE、字节码库和框架产生重大影响。此外，不仅会新增其他 API，还会有 `API被删除`（这在 Java 8 之前没有发生过）。\r\n\r\n目前看这种发布策略是非常成功的，**解开了 Java/JVM 演进的许多枷锁，至关重要的是，OpenJDK 的权力中心，正在转移到开发社区和开发者手中。**在新的模式中，既可以利用 LTS 满足企业长期可靠支持的需求，也可以满足各种开发者对于新特性迭代的诉求。因为用 2-3 年的最小间隔粒度来试验一个特性，基本是不现实的。\r\n\r\n### 名词解释\r\n\r\n#### 名词解释：Oracle JDK 和 Open JDK\r\n\r\n这两个 JDK 最大不同就是许可证不一样。**但是对于个人用户来讲，没区别。**\r\n\r\n|              | Oracle JDK                                                                                        | Open JDK                     |\r\n| ------------ | ------------------------------------------------------------------------------------------------- | ---------------------------- |\r\n| 来源         | Oracle 团队维护                                                                                   | Oracle 和 Open Java 社区     |\r\n| 授权协议     | Java 17 及更高版本 Oracle Java SE 许可证<br>Java16 及更低版本甲骨文免费条款和条件（NFTC）许可协议 | GPL v2 许可证                |\r\n| 关系         | 由 Open JDK 构建，增加了少许内容                                                                  |                              |\r\n| 是否收费     | 2021 年 9 月起 Java17 及更高版本所有用户免费。16 及更低版本，个人用户、开发用户免费。             | 2017 年 9 月起，所有版本免费 |\r\n| 对语法的支持 | 一致                                                                                              | 一致                         |\r\n\r\n#### 名词解释：JEP\r\n\r\nJEP(JDK Enhancement Proposals)：jdk 改进提案，每当需要有新的设想时候，JEP 可以提出非正式的规范 (specification)，被正式认可的 JEP 正式写进 JDK 的发展路线图并分配版本号。\r\n\r\n#### 名词解释：LTS\r\n\r\nLTS（Long-term Support）即长期支持。Oracle 官网提供了对 Oracle JDK 个别版本的长期支持，即使发发行了新版本，比如目前最新的 JDK19，在结束日期前，LTS 版本都会被长期支持。（出了 bug，会被修复，非 LTS 则不会再有补丁发布）所以，一定要选一个 LTS 版本，不然出了漏洞没人修复了。\r\n\r\n| 版本      | 开始日期     | 结束日期     | 延期结束日期  |\r\n| --------- | ------------ | ------------ | ------------- |\r\n| 7（LTS）  | 2011 年 7 月 | 2019 年 7 月 | 2022 年 7 月  |\r\n| 8（LTS）  | 2014 年 3 月 | 2022 年 3 月 | 2030 年 12 月 |\r\n| 11（LTS） | 2018 年 9 月 | 2023 年 9 月 | 2026 年 9 月  |\r\n| 17（LTS） | 2021 年 9 月 | 2026 年 9 月 | 2029 年 9 月  |\r\n| 21（LTS） | 2023 年 9 月 | 2028 年 9 月 | 2031 年 9 月  |\r\n\r\n如果要选择 Oracle JDK，目前可选的 LTS 版本为 8、11、17 三个。\r\n\r\n### 各版本支持时间路线图\r\n\r\n![image-20230417133915411](./assets/image-20230417133915411.png)\r\n\r\n### 各版本介绍\r\n\r\n![image-20230417133918961](./assets/image-20230417133918961.png)\r\n\r\n#### jdk 9\r\n\r\nJava 9 提供了`超过150项`新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。\r\n\r\n特性太多，查看链接：\r\n\r\nhttps://openjdk.java.net/projects/jdk9/\r\n\r\n#### jdk 10\r\n\r\nhttps://openjdk.java.net/projects/jdk/10/\r\n\r\n> - 286: [Local-Variable Type Inference](http://openjdk.java.net/jeps/286) 局部变量类型推断\r\n> - 296: [Consolidate the JDK Forest into a Single Repository](http://openjdk.java.net/jeps/296) JDK 库的合并\r\n> - 304: [Garbage-Collector Interface](http://openjdk.java.net/jeps/304) 统一的垃圾回收接口\r\n> - 307: [Parallel Full GC for G1](http://openjdk.java.net/jeps/307) 为 G1 提供并行的 Full GC\r\n> - 310: [Application Class-Data Sharing](http://openjdk.java.net/jeps/310) 应用程序类数据（AppCDS）共享\r\n> - 312: [Thread-Local Handshakes](http://openjdk.java.net/jeps/312) ThreadLocal 握手交互\r\n> - 313: [Remove the Native-Header Generation Tool (javah)](http://openjdk.java.net/jeps/313) 移除 JDK 中附带的 javah 工具\r\n> - 314: [Additional Unicode Language-Tag Extensions](http://openjdk.java.net/jeps/314) 使用附加的 Unicode 语言标记扩展\r\n> - 316: [Heap Allocation on Alternative Memory Devices](http://openjdk.java.net/jeps/316) 能将堆内存占用分配给用户指定的备用内存设备\r\n> - 317: [Experimental Java-Based JIT Compiler](http://openjdk.java.net/jeps/317) 使用 Graal 基于 Java 的编译器\r\n>- 319: [Root Certificates](http://openjdk.java.net/jeps/319) 根证书\r\n> - 322: [Time-Based Release Versioning](http://openjdk.java.net/jeps/322) 基于时间定于的发布版本\r\n\r\n#### jdk 11\r\n\r\nhttps://openjdk.java.net/projects/jdk/11/\r\n\r\n> - 181: [Nest-Based Access Control](https://openjdk.java.net/jeps/181)  基于嵌套的访问控制\r\n> - 309: [Dynamic Class-File Constants](https://openjdk.java.net/jeps/309) 动态类文件常量\r\n> - 315: [Improve Aarch64 Intrinsics](https://openjdk.java.net/jeps/315) 改进 Aarch64 Intrinsics\r\n> - 318: [Epsilon: A No-Op Garbage Collector](https://openjdk.java.net/jeps/318) Epsilon — 一个 No-Op（无操作）的垃圾收集器\r\n> - 320: [Remove the Java EE and CORBA Modules](https://openjdk.java.net/jeps/320) 删除 Java EE 和 CORBA 模块\r\n> - 321: [HTTP Client (Standard)](https://openjdk.java.net/jeps/321)  HTTPClient API\r\n> - 323: [Local-Variable Syntax for Lambda Parameters](https://openjdk.java.net/jeps/323)  用于 Lambda 参数的局部变量语法\r\n> - 324: [Key Agreement with Curve25519 and Curve448](https://openjdk.java.net/jeps/324) Curve25519 和 Curve448 算法的密钥协议\r\n> - 327: [Unicode 10](https://openjdk.java.net/jeps/327)\r\n> - 328: [Flight Recorder](https://openjdk.java.net/jeps/328) 飞行记录仪\r\n> - 329: [ChaCha20 and Poly1305 Cryptographic Algorithms](https://openjdk.java.net/jeps/329) ChaCha20 和 Poly1305 加密算法\r\n> - 330: [Launch Single-File Source-Code Programs](https://openjdk.java.net/jeps/330) 启动单一文件的源代码程序\r\n> - 331: [Low-Overhead Heap Profiling](https://openjdk.java.net/jeps/331) 低开销的 Heap Profiling\r\n> - 332: [Transport Layer Security (TLS) 1.3](https://openjdk.java.net/jeps/332) 支持 TLS 1.3\r\n> - 333: [ZGC: A Scalable Low-Latency Garbage Collector (Experimental)](https://openjdk.java.net/jeps/333) 可伸缩低延迟垃圾收集器\r\n> - 335: [Deprecate the Nashorn JavaScript Engine](https://openjdk.java.net/jeps/335) 弃用 Nashorn JavaScript 引擎\r\n> - 336: [Deprecate the Pack200 Tools and API](https://openjdk.java.net/jeps/336)  弃用 Pack200 工具和 API\r\n\r\n#### jdk 12\r\n\r\nhttps://openjdk.java.net/projects/jdk/12/\r\n\r\n> - 189：[Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)](https://openjdk.java.net/jeps/189) 低暂停时间的 GC\r\n> - 230: [Microbenchmark Suite](https://openjdk.java.net/jeps/230) 微基准测试套件\r\n> - 325: [Switch Expressions (Preview)](https://openjdk.java.net/jeps/325) switch 表达式\r\n> - 334: [JVM Constants API ](https://openjdk.java.net/jeps/334) JVM 常量 API\r\n> - 340: [One AArch64 Port, Not Two](https://openjdk.java.net/jeps/340) 只保留一个 AArch64 实现\r\n> - 341: [Default CDS Archives](https://openjdk.java.net/jeps/341) 默认类数据共享归档文件\r\n> - 344: [Abortable Mixed Collections for G1](https://openjdk.java.net/jeps/344) 可中止的 G1 Mixed GC\r\n> - 346: [Promptly Return Unused Committed Memory from G1](https://openjdk.java.net/jeps/346) G1 及时返回未使用的已分配内存\r\n\r\n#### jdk 13\r\n\r\nhttps://openjdk.java.net/projects/jdk/13/\r\n\r\n> - 350: [Dynamic CDS Archives](https://openjdk.java.net/jeps/350) 动态 CDS 档案\r\n> - 351: [ZGC: Uncommit Unused Memory](https://openjdk.java.net/jeps/351) ZGC:取消使用未使用的内存\r\n> - 353: [Reimplement the Legacy Socket API](https://openjdk.java.net/jeps/353) 重新实现旧版套接字 API\r\n> - 354: [Switch Expressions (Preview)](https://openjdk.java.net/jeps/354) switch 表达式（预览）\r\n> - 355: [Text Blocks (Preview)](https://openjdk.java.net/jeps/355) 文本块（预览）\r\n\r\n#### jdk 14\r\n\r\nhttps://openjdk.java.net/projects/jdk/14/\r\n\r\n> - 305: [Pattern Matching for instanceof (Preview)](https://openjdk.java.net/jeps/305) instanceof 的模式匹配\r\n> - 343: [Packaging Tool (Incubator)](https://openjdk.java.net/jeps/343) 打包工具\r\n> - 345: [NUMA-Aware Memory Allocation for G1](https://openjdk.java.net/jeps/345) G1 的 NUMA-Aware 内存分配\r\n> - 349: [JFR Event Streaming](https://openjdk.java.net/jeps/349) JFR 事件流\r\n> - 352: [Non-Volatile Mapped Byte Buffers](https://openjdk.java.net/jeps/352) 非易失性映射字节缓冲区\r\n> - 358: [Helpful NullPointerExceptions](https://openjdk.java.net/jeps/358) 实用的 NullPointerExceptions\r\n> - 359: [Records (Preview)](https://openjdk.java.net/jeps/359) \r\n> - 361: [Switch Expressions (Standard)](https://openjdk.java.net/jeps/361) Switch 表达式\r\n> - 362: [Deprecate the Solaris and SPARC Ports](https://openjdk.java.net/jeps/362) 弃用 Solaris 和 SPARC 端口\r\n> - 363: [Remove the Concurrent Mark Sweep (CMS) Garbage Collector](https://openjdk.java.net/jeps/363) 删除并发标记扫描（CMS）垃圾回收器\r\n> - 364: [ZGC on macOS](https://openjdk.java.net/jeps/364) \r\n> - 365: [ZGC on Windows](https://openjdk.java.net/jeps/365) \r\n> - 366: [Deprecate the ParallelScavenge + SerialOld GC Combination](https://openjdk.java.net/jeps/366) 弃用 ParallelScavenge + SerialOld GC 组合\r\n> - 367: [Remove the Pack200 Tools and API](https://openjdk.java.net/jeps/367) 删除 Pack200 工具和 API\r\n> - 368: [Text Blocks (Second Preview)](https://openjdk.java.net/jeps/368) 文本块\r\n> - 370: [Foreign-Memory Access API (Incubator)](https://openjdk.java.net/jeps/370) 外部存储器访问 API\r\n\r\n#### jdk 15\r\n\r\nhttps://openjdk.java.net/projects/jdk/15/\r\n\r\n> - 339: [Edwards-Curve Digital Signature Algorithm (EdDSA)](https://openjdk.java.net/jeps/339) EdDSA 数字签名算法\r\n> - 360: [Sealed Classes (Preview)](https://openjdk.java.net/jeps/360) 密封类（预览）\r\n> - 371: [Hidden Classes](https://openjdk.java.net/jeps/371) 隐藏类\r\n> - 372: [Remove the Nashorn JavaScript Engine](https://openjdk.java.net/jeps/372) 移除 Nashorn JavaScript 引擎\r\n> - 373: [Reimplement the Legacy DatagramSocket API](https://openjdk.java.net/jeps/373) 重新实现 Legacy DatagramSocket API\r\n> - 374: [Disable and Deprecate Biased Locking](https://openjdk.java.net/jeps/374) 禁用偏向锁定\r\n> - 375: [Pattern Matching for instanceof (Second Preview)](https://openjdk.java.net/jeps/375) instanceof 模式匹配（第二次预览）\r\n> - 377: [ZGC: A Scalable Low-Latency Garbage Collector](https://openjdk.java.net/jeps/377) ZGC：一个可扩展的低延迟垃圾收集器\r\n> - 378: [Text Blocks](https://openjdk.java.net/jeps/378) 文本块\r\n> - 379: [Shenandoah: A Low-Pause-Time Garbage Collector](https://openjdk.java.net/jeps/379) Shenandoah:低暂停时间垃圾收集器\r\n> - 381: [Remove the Solaris and SPARC Ports](https://openjdk.java.net/jeps/381) 移除 Solaris 和 SPARC 端口\r\n> - 383: [Foreign-Memory Access API (Second Incubator)](https://openjdk.java.net/jeps/383) 外部存储器访问 API（第二次孵化版）\r\n> - 384: [Records (Second Preview)](https://openjdk.java.net/jeps/384) Records（第二次预览）\r\n> - 385: [Deprecate RMI Activation for Removal](https://openjdk.java.net/jeps/385) 废弃 RMI 激活机制\r\n\r\n#### jdk 16\r\n\r\nhttps://openjdk.java.net/projects/jdk/16/\r\n\r\n> - 338: [Vector API (Incubator)](https://openjdk.java.net/jeps/338) Vector API（孵化器）\r\n> - 347: [Enable C++14 Language Features](https://openjdk.java.net/jeps/347) JDK C++的源码中允许使用 C++14 的语言特性\r\n> - 357: [Migrate from Mercurial to Git](https://openjdk.java.net/jeps/357) OpenJDK 源码的版本控制从 Mercurial (hg) 迁移到 git\r\n> - 369: [Migrate to GitHub](https://openjdk.java.net/jeps/369) OpenJDK 源码的版本控制迁移到 github 上\r\n> - 376: [ZGC: Concurrent Thread-Stack Processing](https://openjdk.java.net/jeps/376) ZGC：并发线程处理\r\n> - 380: [Unix-Domain Socket Channels](https://openjdk.java.net/jeps/380) Unix 域套接字通道\r\n> - 386: [Alpine Linux Port](https://openjdk.java.net/jeps/386) 将 glibc 的 jdk 移植到使用 musl 的 alpine linux 上\r\n> - 387: [Elastic Metaspace](https://openjdk.java.net/jeps/387) 弹性元空间\r\n> - 388: [Windows/AArch64 Port](https://openjdk.java.net/jeps/388) 移植JDK到Windows/AArch64\r\n> - 389: [Foreign Linker API (Incubator)](https://openjdk.java.net/jeps/389) 提供 jdk.incubator.foreign 来简化 native code 的调用\r\n> - 390: [Warnings for Value-Based Classes](https://openjdk.java.net/jeps/390) 提供基于值的类的警告\r\n> - 392: [Packaging Tool](https://openjdk.java.net/jeps/392) jpackage 打包工具转正\r\n> - 393: [Foreign-Memory Access API (Third Incubator)](https://openjdk.java.net/jeps/393) \r\n> - 394: [Pattern Matching for instanceof](https://openjdk.java.net/jeps/394) Instanceof 的模式匹配转正\r\n> - 395: [Records](https://openjdk.java.net/jeps/395) Records 转正\r\n> - 396: [Strongly Encapsulate JDK Internals by Default](https://openjdk.java.net/jeps/396) 默认情况下，封装了 JDK 内部构件\r\n> - 397: [Sealed Classes (Second Preview)](https://openjdk.java.net/jeps/397) 密封类\r\n\r\n#### jdk 17\r\n\r\nhttps://openjdk.java.net/projects/jdk/17/\r\n\r\n> - 306: [Restore Always-Strict Floating-Point Semantics](https://openjdk.java.net/jeps/306) 恢复始终严格的浮点语义\r\n> - 356: [Enhanced Pseudo-Random Number Generators](https://openjdk.java.net/jeps/356) 增强型伪随机数生成器\r\n> - 382: [New macOS Rendering Pipeline](https://openjdk.java.net/jeps/382) 新的 macOS 渲染管道\r\n> - 391: [macOS/AArch64 Port](https://openjdk.java.net/jeps/391) macOS/AArch64端口\r\n> - 398: [Deprecate the Applet API for Removal](https://openjdk.java.net/jeps/398) 弃用 Applet API 后续将进行删除\r\n> - 403: [Strongly Encapsulate JDK Internals](https://openjdk.java.net/jeps/403) 强封装 JDK 的内部 API\r\n> - 406: [Pattern Matching for switch (Preview)](https://openjdk.java.net/jeps/406) switch 模式匹配（预览）\r\n> - 407: [Remove RMI Activation](https://openjdk.java.net/jeps/407) 删除 RMI 激活机制\r\n> - 409: [Sealed Classes](https://openjdk.java.net/jeps/409) 密封类转正\r\n> - 410: [Remove the Experimental AOT and JIT Compiler](https://openjdk.java.net/jeps/410) 删除实验性的 AOT 和 JIT 编译器\r\n> - 411: [Deprecate the Security Manager for Removal](https://openjdk.java.net/jeps/411) 弃用即将删除的安全管理器\r\n> - 412: [Foreign Function & Memory API (Incubator)](https://openjdk.java.net/jeps/412) 外部函数和内存 API（孵化特性）\r\n> - 414: [Vector API (Second Incubator)](https://openjdk.java.net/jeps/414) Vector API（第二次孵化特性）\r\n> - 415: [Context-Specific Deserialization Filters](https://openjdk.java.net/jeps/415) 上下文特定的反序列化过滤器\r\n\r\n### JDK 各版本下载链接\r\n\r\n```http\r\nhttps://www.oracle.com/java/technologies/downloads/archive/\r\n```\r\n\r\n![image-20230417134030451](./assets/image-20230417134030451.png)\r\n\r\n> - 链接：https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg \r\n> - 提取码：yyds \r\n\r\n![image-20230417134035422](./assets/image-20230417134035422.png)\r\n\r\n### 如何学习新特性\r\n\r\n对于新特性，我们应该从哪几个角度学习新特性呢？\r\n\r\n- 语法层面：\r\n\r\n  - 比如 JDK5 中的自动拆箱、自动装箱、enum、泛型\r\n  - 比如 JDK8 中的 lambda 表达式、接口中的默认方法、静态方法\r\n  - 比如 JDK10 中局部变量的类型推断\r\n  - 比如 JDK12 中的 switch\r\n  - 比如 JDK13 中的文本块\r\n\r\n- API 层面：\r\n\r\n  - 比如 JDK8 中的 Stream、Optional、新的日期时间、HashMap 的底层结构\r\n  - 比如 JDK9 中 String 的底层结构\r\n  - 新的 / 过时的 API\r\n\r\n- 底层优化\r\n\r\n  - 比如 JDK8 中永久代被元空间替代、新的 JS 执行引擎\r\n\r\n  - 比如新的垃圾回收器、GC 参数、JVM 的优化\r\n\r\n\r\n## Java8 新特性：Lambda 表达式\r\n\r\n### 关于 Java8 新特性简介\r\n\r\nJava 8 (又称为 JDK 8 或 JDK1.8) 是 Java 语言开发的一个主要版本。Java 8 是 oracle 公司于 2014 年 3 月发布，可以看成是自 Java 5 以来最具革命性的版本。Java 8 为 Java 语言、编译器、类库、开发工具与 JVM 带来了大量新特性。\r\n\r\n![image-20230417134046492](./assets/image-20230417134046492.png)\r\n\r\n- 速度更快\r\n\r\n- 代码更少 (增加了新的语法：**Lambda** **表达式**)\r\n\r\n- 强大的 **Stream API**\r\n\r\n- 便于并行\r\n  - **并行流**就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。\r\n  - Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。\r\n\r\n- 最大化减少空指针异常：Optional\r\n\r\n- Nashorn 引擎，允许在 JVM 上运行 JS 应用\r\n  - 发音“nass-horn”，是德国二战时一个坦克的命名\r\n  - javascript 运行在 jvm 已经不是新鲜事了，Rhino 早在 jdk6 的时候已经存在。现在替代 Rhino，官方的解释是 Rhino 相比其他 JavaScript 引擎（比如 google 的 V8）实在太慢了，改造 Rhino 还不如重写。所以 Nashorn 的性能也是其一个亮点。\r\n  - Nashorn 项目在 JDK 9 中得到改进；在 JDK11 中`Deprecated`，后续 JDK15 版本中`remove`。在 JDK11 中取以代之的是 GraalVM。（GraalVM 是一个运行时平台，它支持 Java 和其他基于 Java 字节码的语言，但也支持其他语言，如 JavaScript，Ruby，Python 或 LLVM。性能是 Nashorn 的 2 倍以上。）\r\n\r\n### 冗余的匿名内部类\r\n\r\n当需要启动一个线程去完成任务时，通常会通过`java.lang.Runnable`接口来定义任务内容，并使用`java.lang.Thread`类来启动该线程。代码如下：\r\n\r\n```java\r\npublic class UseFunctionalProgramming {\r\n    public static void main(String[] args) {\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(\"多线程任务执行！\");\r\n            }\r\n        }).start(); // 启动线程\r\n    }\r\n}\r\n```\r\n\r\n本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个`Runnable`接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。\r\n\r\n**代码分析：**\r\n\r\n对于`Runnable`的匿名内部类用法，可以分析出几点内容：\r\n\r\n* `Thread`类需要`Runnable`接口作为参数，其中的抽象`run`方法是用来指定线程任务内容的核心；\r\n* 为了指定`run`的方法体，**不得不**需要`Runnable`接口的实现类；\r\n* 为了省去定义一个`RunnableImpl`实现类的麻烦，**不得不**使用匿名内部类；\r\n* 必须覆盖重写抽象`run`方法，所以方法名称、方法参数、方法返回值**不得不**再写一遍，且不能写错；\r\n* 而实际上，**似乎只有方法体才是关键所在**。\r\n\r\n### 好用的 lambda 表达式\r\n\r\n![image-20230417134120319](./assets/image-20230417134120319.png)\r\n\r\n![image-20230417134136458](./assets/image-20230417134136458.png)\r\n\r\n### Lambda 及其使用举例\r\n\r\nLambda 是一个**匿名函数**，我们可以把 Lambda 表达式理解为是**一段可以传递的代码**（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java 的语言表达能力得到了提升。\r\n\r\n- 从匿名类到 Lambda 的转换举例 1\r\n\r\n![image-20230417134145691](./assets/image-20230417134145691.png)\r\n\r\n- 从匿名类到 Lambda 的转换举例 2\r\n\r\n![image-20230417134151284](./assets/image-20230417134151284.png)\r\n\r\n### 语法\r\n\r\nLambda 表达式：在 Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为“`->`” ，该操作符被称为 `Lambda 操作符`或`箭头操作符`。它将 Lambda 分为两个部分：\r\n\r\n- 左侧：指定了 Lambda 表达式需要的参数列表\r\n- 右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。\r\n\r\n**语法格式一：**无参，无返回值\r\n\r\n```java\r\n@Test\r\npublic void test1(){\r\n    //未使用 Lambda 表达式\r\n    Runnable r1 = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            System.out.println(\"我爱北京天安门\");\r\n        }\r\n    };\r\n\r\n    r1.run();\r\n\r\n    System.out.println(\"***********************\");\r\n\r\n    //使用 Lambda 表达式\r\n    Runnable r2 = () -> {\r\n        System.out.println(\"我爱北京故宫\");\r\n    };\r\n\r\n    r2.run();\r\n}\r\n```\r\n\r\n**语法格式二：**Lambda 需要一个参数，但是没有返回值。\r\n\r\n```java\r\n@Test\r\npublic void test2(){\r\n    //未使用 Lambda 表达式\r\n    Consumer<String> con = new Consumer<String>() {\r\n        @Override\r\n        public void accept(String s) {\r\n            System.out.println(s);\r\n        }\r\n    };\r\n    con.accept(\"谎言和誓言的区别是什么？\");\r\n\r\n    System.out.println(\"*******************\");\r\n\r\n    //使用 Lambda 表达式\r\n    Consumer<String> con1 = (String s) -> {\r\n        System.out.println(s);\r\n    };\r\n    con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\r\n\r\n}\r\n```\r\n\r\n**语法格式三：**数据类型可以省略，因为可由编译器推断得出，称为“类型推断”\r\n\r\n```java\r\n@Test\r\npublic void test3(){\r\n    //语法格式三使用前\r\n    Consumer<String> con1 = (String s) -> {\r\n        System.out.println(s);\r\n    };\r\n    con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\r\n\r\n    System.out.println(\"*******************\");\r\n    //语法格式三使用后\r\n    Consumer<String> con2 = (s) -> {\r\n        System.out.println(s);\r\n    };\r\n    con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\r\n\r\n}\r\n```\r\n\r\n**语法格式四：**Lambda 若只需要一个参数时，参数的小括号可以省略\r\n\r\n```java\r\n@Test\r\npublic void test4(){\r\n    //语法格式四使用前\r\n    Consumer<String> con1 = (s) -> {\r\n        System.out.println(s);\r\n    };\r\n    con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\r\n\r\n    System.out.println(\"*******************\");\r\n    //语法格式四使用后\r\n    Consumer<String> con2 = s -> {\r\n        System.out.println(s);\r\n    };\r\n    con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\r\n\r\n\r\n}\r\n```\r\n\r\n**语法格式五：**Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值\r\n\r\n```java\r\n@Test\r\npublic void test5(){\r\n    //语法格式五使用前\r\n    Comparator<Integer> com1 = new Comparator<Integer>() {\r\n        @Override\r\n        public int compare(Integer o1, Integer o2) {\r\n            System.out.println(o1);\r\n            System.out.println(o2);\r\n            return o1.compareTo(o2);\r\n        }\r\n    };\r\n\r\n    System.out.println(com1.compare(12,21));\r\n    System.out.println(\"*****************************\");\r\n    //语法格式五使用后\r\n    Comparator<Integer> com2 = (o1,o2) -> {\r\n        System.out.println(o1);\r\n        System.out.println(o2);\r\n        return o1.compareTo(o2);\r\n    };\r\n\r\n    System.out.println(com2.compare(12,6));\r\n\r\n\r\n}\r\n```\r\n\r\n**语法格式六：**当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略\r\n\r\n```java\r\n@Test\r\npublic void test6(){\r\n    //语法格式六使用前\r\n    Comparator<Integer> com1 = (o1,o2) -> {\r\n        return o1.compareTo(o2);\r\n    };\r\n\r\n    System.out.println(com1.compare(12,6));\r\n\r\n    System.out.println(\"*****************************\");\r\n    //语法格式六使用后\r\n    Comparator<Integer> com2 = (o1,o2) -> o1.compareTo(o2);\r\n\r\n    System.out.println(com2.compare(12,21));\r\n\r\n}\r\n\r\n@Test\r\npublic void test7(){\r\n    //语法格式六使用前\r\n    Consumer<String> con1 = s -> {\r\n        System.out.println(s);\r\n    };\r\n    con1.accept(\"一个是听得人当真了，一个是说的人当真了\");\r\n\r\n    System.out.println(\"*****************************\");\r\n    //语法格式六使用后\r\n    Consumer<String> con2 = s -> System.out.println(s);\r\n\r\n    con2.accept(\"一个是听得人当真了，一个是说的人当真了\");\r\n\r\n}\r\n```\r\n\r\n### 关于类型推断\r\n\r\n在语法格式三 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“`类型推断`”。\r\n\r\n![image-20230417134212081](./assets/image-20230417134212081.png)\r\n\r\n举例：\r\n\r\n```java\r\n@Test\r\npublic void test() {\r\n    //类型推断 1\r\n    ArrayList<String> list = new ArrayList<>();\r\n    //类型推断 2\r\n    int[] arr = {1, 2, 3};\r\n\r\n}\r\n```\r\n\r\n## Java8 新特性：函数式 (Functional) 接口\r\n\r\n### 什么是函数式接口\r\n\r\n- 只包含`一个抽象方法`（Single Abstract Method，简称 SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法。\r\n- 你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常 (即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。\r\n- 我们可以在一个接口上使用 `@FunctionalInterface` 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。\r\n- 在`java.util.function`包下定义了 Java 8 的丰富的函数式接口\r\n\r\n### 如何理解函数式接口\r\n\r\n![image-20230417134219903](./assets/image-20230417134219903.png)\r\n\r\n- Java 从诞生日起就是一直倡导“一切皆对象”，在 Java 里面面向对象 (OOP) 编程是一切。但是随着 python、scala 等语言的兴起和新技术的挑战，Java 不得不做出调整以便支持更加广泛的技术要求，即 Java 不但可以支持 OOP 还可以支持 OOF（面向函数编程）\r\n  - Java8 引入了 Lambda 表达式之后，Java 也开始支持函数式编程。\r\n  - Lambda 表达式不是 Java 最早使用的。目前 C++，C#，Python，Scala 等均支持 Lambda 表达式。\r\n- 面向对象的思想：\r\n  * 做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情。\r\n- 函数式编程思想：\r\n  * 只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程。\r\n- 在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda 表达式的类型是函数。但是在 Java8 中，有所不同。在 Java8 中，Lambda 表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。\r\n- 简单的说，在 Java8 中，Lambda 表达式就是一个函数式接口的实例。这就是 Lambda 表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示。\r\n\r\n### 举例\r\n\r\n举例 1：\r\n\r\n![image-20230417134224985](./assets/image-20230417134224985.png)\r\n\r\n举例 2：\r\n\r\n![image-20230417134229261](./assets/image-20230417134229261.png)\r\n\r\n作为参数传递 Lambda 表达式：\r\n\r\n![image-20230417134234241](./assets/image-20230417134234241.png)\r\n\r\n> 作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收 Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。\r\n\r\n### Java 内置函数式接口\r\n\r\n#### 之前的函数式接口\r\n\r\n之前学过的接口，有些就是函数式接口，比如：\r\n\r\n- `java.lang.Runnable`\r\n  - `public void run()`\r\n- `java.lang.Iterable<T>`\r\n  - `public Iterator<T> iterate()`\r\n- `java.lang.Comparable<T>`\r\n  - `public int compareTo(T t)`\r\n- `java.util.Comparator<T>`\r\n  - `public int compare(T t1, T t2)`\r\n\r\n#### 四大核心函数式接口\r\n\r\n| 函数式接口         | 称谓       | 参数类型 | 用途                                                                                   |\r\n| ------------------ | ---------- | -------- | -------------------------------------------------------------------------------------- |\r\n| `Consumer<T>  `    | 消费型接口 | T        | 对类型为 T 的对象应用操作，包含方法：  `void accept(T t)  `                            |\r\n| `Supplier<T>  `    | 供给型接口 | 无       | 返回类型为 T 的对象，包含方法：`T get()  `                                             |\r\n| `Function<T, R>  ` | 函数型接口 | T        | 对类型为 T 的对象应用操作，并返回结果。结果是 R 类型的对象。包含方法：`R apply(T t)  ` |\r\n| `Predicate<T>  `   | 判断型接口 | T        | 确定类型为 T 的对象是否满足某约束，并返回 boolean 值。包含方法：`boolean test(T t)  `  |\r\n\r\n#### 其它接口\r\n\r\n**类型 1：消费型接口**\r\n\r\n消费型接口的抽象方法特点：有形参，但是返回值类型是 void\r\n\r\n| 接口名                 | 抽象方法                       | 描述                         |\r\n| ---------------------- | ------------------------------ | ---------------------------- |\r\n| `BiConsumer<T,U>`      | void accept(T t, U u)          | 接收两个对象用于完成功能     |\r\n| DoubleConsumer         | void accept(double value)      | 接收一个 double 值           |\r\n| IntConsumer            | void accept(int value)         | 接收一个 int 值              |\r\n| LongConsumer           | void accept(long value)        | 接收一个 long 值             |\r\n| `ObjDoubleConsumer<T>` | void accept(T t, double value) | 接收一个对象和一个 double 值 |\r\n| `ObjIntConsumer<T>`    | void accept(T t, int value)    | 接收一个对象和一个 int 值    |\r\n| `ObjLongConsumer<T>`   | void accept(T t, long value)   | 接收一个对象和一个 long 值   |\r\n\r\n**类型 2：供给型接口**\r\n\r\n这类接口的抽象方法特点：无参，但是有返回值\r\n\r\n| 接口名          | 抽象方法               | 描述                |\r\n| --------------- | ---------------------- | ------------------- |\r\n| BooleanSupplier | boolean getAsBoolean() | 返回一个 boolean 值 |\r\n| DoubleSupplier  | double getAsDouble()   | 返回一个 double 值  |\r\n| IntSupplier     | int getAsInt()         | 返回一个 int 值     |\r\n| LongSupplier    | long getAsLong()       | 返回一个 long 值    |\r\n\r\n**类型 3：函数型接口**\r\n\r\n这类接口的抽象方法特点：既有参数又有返回值\r\n\r\n| 接口名                    | 抽象方法                                        | 描述                                                      |\r\n| ------------------------- | ----------------------------------------------- | --------------------------------------------------------- |\r\n| `UnaryOperator<T>`        | T apply(T t)                                    | 接收一个 T 类型对象，返回一个 T 类型对象结果              |\r\n| `DoubleFunction<R>`       | R apply(double value)                           | 接收一个 double 值，返回一个 R 类型对象                   |\r\n| `IntFunction<R>`          | R apply(int value)                              | 接收一个 int 值，返回一个 R 类型对象                      |\r\n| `LongFunction<R>`         | R apply(long value)                             | 接收一个 long 值，返回一个 R 类型对象                     |\r\n| `ToDoubleFunction<T>`     | double applyAsDouble(T value)                   | 接收一个 T 类型对象，返回一个 double                      |\r\n| `ToIntFunction<T>`        | int applyAsInt(T value)                         | 接收一个 T 类型对象，返回一个 int                         |\r\n| `ToLongFunction<T>`       | long applyAsLong(T value)                       | 接收一个 T 类型对象，返回一个 long                        |\r\n| DoubleToIntFunction       | int applyAsInt(double value)                    | 接收一个 double 值，返回一个 int 结果                     |\r\n| DoubleToLongFunction      | long applyAsLong(double value)                  | 接收一个 double 值，返回一个 long 结果                    |\r\n| IntToDoubleFunction       | double applyAsDouble(int value)                 | 接收一个 int 值，返回一个 double 结果                     |\r\n| IntToLongFunction         | long applyAsLong(int value)                     | 接收一个 int 值，返回一个 long 结果                       |\r\n| LongToDoubleFunction      | double applyAsDouble(long value)                | 接收一个 long 值，返回一个 double 结果                    |\r\n| LongToIntFunction         | int applyAsInt(long value)                      | 接收一个 long 值，返回一个 int 结果                       |\r\n| DoubleUnaryOperator       | double applyAsDouble(double operand)            | 接收一个 double 值，返回一个 double                       |\r\n| IntUnaryOperator          | int applyAsInt(int operand)                     | 接收一个 int 值，返回一个 int 结果                        |\r\n| LongUnaryOperator         | long applyAsLong(long operand)                  | 接收一个 long 值，返回一个 long 结果                      |\r\n| `BiFunction<T,U,R>`       | R apply(T t, U u)                               | 接收一个 T 类型和一个 U 类型对象，返回一个 R 类型对象结果 |\r\n| `BinaryOperator<T>`       | T apply(T t, T u)                               | 接收两个 T 类型对象，返回一个 T 类型对象结果              |\r\n| `ToDoubleBiFunction<T,U>` | double applyAsDouble(T t, U u)                  | 接收一个 T 类型和一个 U 类型对象，返回一个 double         |\r\n| `ToIntBiFunction<T,U>`    | int applyAsInt(T t, U u)                        | 接收一个 T 类型和一个 U 类型对象，返回一个 int            |\r\n| `ToLongBiFunction<T,U>`   | long applyAsLong(T t, U u)                      | 接收一个 T 类型和一个 U 类型对象，返回一个 long           |\r\n| DoubleBinaryOperator      | double applyAsDouble(double left, double right) | 接收两个 double 值，返回一个 double 结果                  |\r\n| IntBinaryOperator         | int applyAsInt(int left, int right)             | 接收两个 int 值，返回一个 int 结果                        |\r\n| LongBinaryOperator        | long applyAsLong(long left, long right)         | 接收两个 long 值，返回一个 long 结果                      |\r\n\r\n**类型 4：判断型接口**\r\n\r\n这类接口的抽象方法特点：有参，但是返回值类型是 boolean 结果。\r\n\r\n| 接口名             | 抽象方法                   | 描述               |\r\n| ------------------ | -------------------------- | ------------------ |\r\n| `BiPredicate<T,U>` | boolean test(T t, U u)     | 接收两个对象       |\r\n| DoublePredicate    | boolean test(double value) | 接收一个 double 值 |\r\n| IntPredicate       | boolean test(int value)    | 接收一个 int 值    |\r\n| LongPredicate      | boolean test(long value)   | 接收一个 long 值   |\r\n\r\n#### 内置接口代码演示\r\n\r\n举例 1：\r\n\r\n```java\r\npublic class TestConsumer {\r\n    public static void main(String[] args) {\r\n        List<String> list = Arrays.asList(\"java\",\"c\",\"python\",\"c++\",\"VB\",\"C#\");\r\n        //遍历 Collection 集合，并将传递给 action 参数的操作代码应用在每一个元素上。\r\n        list.forEach(s -> System.out.println(s));\r\n    }\r\n}\r\n```\r\n\r\n举例 2：\r\n\r\n```java\r\npublic class TestSupplier {\r\n    public static void main(String[] args) {\r\n        Supplier<String> supplier = () -> \"尚硅谷\";\r\n        System.out.println(supplier.get());\r\n    }\r\n}\r\n```\r\n\r\n举例 3：\r\n\r\n```java\r\npublic class TestPredicate {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> list = new ArrayList<>();\r\n        list.add(\"hello\");\r\n        list.add(\"java\");\r\n        list.add(\"atguigu\");\r\n        list.add(\"ok\");\r\n        list.add(\"yes\");\r\n\r\n        System.out.println(\"删除之前：\");\r\n        list.forEach(t-> System.out.println(t));\r\n\t\t\r\n        //用于删除集合中满足 filter 指定的条件判断的。\r\n        //删除包含 o 字母的元素\r\n        list.removeIf(s -> s.contains(\"o\"));\r\n\r\n        System.out.println(\"删除包含 o 字母的元素之后：\");\r\n        list.forEach(t-> System.out.println(t));\r\n    }\r\n}\r\n```\r\n\r\n举例 4：\r\n\r\n```java\r\npublic class TestFunction {\r\n    public static void main(String[] args) {\r\n        //使用 Lambda 表达式实现 Function<T,R>接口，可以实现将一个字符串首字母转为大写的功能。\r\n        Function<String,String> fun = s -> s.substring(0,1).toUpperCase() + s.substring(1);\r\n        System.out.println(fun.apply(\"hello\"));\r\n    }\r\n}\r\n```\r\n\r\n#### 练习\r\n\r\n**练习 1：无参无返回值形式**\r\n\r\n假如有自定义函数式接口 Call 如下：\r\n\r\n```java\r\npublic interface Call {\r\n    void shout();\r\n}\r\n```\r\n\r\n在测试类中声明一个如下方法：\r\n\r\n```java\r\npublic static void callSomething(Call call){\r\n\t\tcall.shout();\r\n}\r\n```\r\n\r\n在测试类的 main 方法中调用 callSomething 方法，并用 Lambda 表达式为形参 call 赋值，可以喊出任意你想说的话。\r\n\r\n```java\r\npublic class TestLambda {\r\n\tpublic static void main(String[] args) {\r\n\t\tcallSomething(()->System.out.println(\"回家吃饭\"));\r\n\t\tcallSomething(()->System.out.println(\"我爱你\"));\r\n\t\tcallSomething(()->System.out.println(\"滚蛋\"));\r\n\t\tcallSomething(()->System.out.println(\"回来\"));\r\n\t}\r\n\tpublic static void callSomething(Call call){\r\n\t\tcall.shout();\r\n\t}\r\n}\r\ninterface Call {\r\n    void shout();\r\n}\r\n```\r\n\r\n**练习 2：消费型接口**\r\n\r\n代码示例：`Consumer<T>` 接口\r\n\r\n在 JDK1.8 中 Collection 集合接口的父接口 Iterable 接口中增加了一个默认方法：\r\n\r\n`public default void forEach(Consumer<? super T> action) `遍历 Collection 集合的每个元素，执行“xxx 消费型”操作。\r\n\r\n在 JDK1.8 中 Map 集合接口中增加了一个默认方法：\r\n\r\n`public default void forEach(BiConsumer<? super K,? super V> action)`遍历 Map 集合的每对映射关系，执行“xxx 消费型”操作。\r\n\r\n案例：\r\n\r\n（1）创建一个 Collection 系列的集合，添加一些字符串，调用 forEach 方法遍历查看\r\n\r\n（2）创建一个 Map 系列的集合，添加一些 (key,value) 键值对，调用 forEach 方法遍历查看\r\n\r\n示例代码：\r\n\r\n```java\r\n@Test\r\npublic void test1(){\r\n    List<String> list = Arrays.asList(\"hello\",\"java\",\"lambda\",\"atguigu\");\r\n    list.forEach(s -> System.out.println(s));\r\n}\r\n@Test\r\npublic void test2(){\r\n    HashMap<Integer,String> map = new HashMap<>();\r\n    map.put(1, \"hello\");\r\n    map.put(2, \"java\");\r\n    map.put(3, \"lambda\");\r\n    map.put(4, \"atguigu\");\r\n    map.forEach((k,v) -> System.out.println(k+\"->\"+v));\r\n}\r\n```\r\n\r\n**练习 3：供给型接口**\r\n\r\n代码示例：`Supplier<T>` 接口\r\n\r\n在 JDK1.8 中增加了 StreamAPI，`java.util.stream.Stream<T>` 是一个数据流。这个类型有一个静态方法：\r\n\r\n`public static <T> Stream<T> generate(Supplier<T> s)`可以创建 Stream 的对象。而又包含一个 forEach 方法可以遍历流中的元素：`public void forEach(Consumer<? super T> action)`。\r\n\r\n案例：\r\n\r\n现在请调用 Stream 的 generate 方法，来产生一个流对象，并调用 Math.random() 方法来产生数据，为 Supplier 函数式接口的形参赋值。最后调用 forEach 方法遍历流中的数据查看结果。\r\n\r\n```java\r\n@Test\r\npublic void test2(){\r\n    Stream.generate(() -> Math.random()).forEach(num -> System.out.println(num));\r\n}\r\n```\r\n\r\n**练习 4：功能型接口**\r\n\r\n代码示例：`Function<T,R>` 接口\r\n\r\n在 JDK1.8 时 Map 接口增加了很多方法，例如：\r\n\r\n`public default void replaceAll(BiFunction<? super K,? super V,? extends V> function) `按照 function 指定的操作替换 map 中的 value。\r\n\r\n`public default void forEach(BiConsumer<? super K,? super V> action)`遍历 Map 集合的每对映射关系，执行“xxx 消费型”操作。\r\n\r\n案例：\r\n\r\n（1）声明一个 Employee 员工类型，包含编号、姓名、薪资。\r\n\r\n（2）添加 n 个员工对象到一个 HashMap<Integer,Employee>集合中，其中员工编号为 key，员工对象为 value。\r\n\r\n（3）调用 Map 的 forEach 遍历集合\r\n\r\n（4）调用 Map 的 replaceAll 方法，将其中薪资低于 10000 元的，薪资设置为 10000。\r\n\r\n（5）再次调用 Map 的 forEach 遍历集合查看结果\r\n\r\nEmployee 类：\r\n\r\n```java\r\nclass Employee{\r\n\tprivate int id;\r\n\tprivate String name;\r\n\tprivate double salary;\r\n\tpublic Employee(int id, String name, double salary) {\r\n\t\tsuper();\r\n\t\tthis.id = id;\r\n\t\tthis.name = name;\r\n\t\tthis.salary = salary;\r\n\t}\r\n\tpublic Employee() {\r\n\t\tsuper();\r\n\t}\r\n\tpublic int getId() {\r\n\t\treturn id;\r\n\t}\r\n\tpublic void setId(int id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\tpublic double getSalary() {\r\n\t\treturn salary;\r\n\t}\r\n\tpublic void setSalary(double salary) {\r\n\t\tthis.salary = salary;\r\n\t}\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Employee [id=\" + id + \", name=\" + name + \", salary=\" + salary + \"]\";\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n测试类：\r\n\r\n```java\r\npublic class TestLambda {\r\n\tpublic static void main(String[] args) {\r\n\t\tHashMap<Integer,Employee> map = new HashMap<>();\r\n\t\tEmployee e1 = new Employee(1, \"张三\", 8000);\r\n\t\tEmployee e2 = new Employee(2, \"李四\", 9000);\r\n\t\tEmployee e3 = new Employee(3, \"王五\", 10000);\r\n\t\tEmployee e4 = new Employee(4, \"赵六\", 11000);\r\n\t\tEmployee e5 = new Employee(5, \"钱七\", 12000);\r\n\t\t\r\n\t\tmap.put(e1.getId(), e1);\r\n\t\tmap.put(e2.getId(), e2);\r\n\t\tmap.put(e3.getId(), e3);\r\n\t\tmap.put(e4.getId(), e4);\r\n\t\tmap.put(e5.getId(), e5);\r\n\t\t\r\n\t\tmap.forEach((k,v) -> System.out.println(k+\"=\"+v));\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tmap.replaceAll((k,v)->{\r\n\t\t\tif(v.getSalary()<10000){\r\n\t\t\t\tv.setSalary(10000);\r\n\t\t\t}\r\n\t\t\treturn v;\r\n\t\t});\r\n\t\tmap.forEach((k,v) -> System.out.println(k+\"=\"+v));\r\n\t}\r\n}\r\n```\r\n\r\n**练习 5：判断型接口**\r\n\r\n代码示例：`Predicate<T>` 接口\r\n\r\nJDK1.8 时，`Collecton<E>` 接口增加了一下方法，其中一个如下：\r\n\r\n`public default boolean removeIf(Predicate<? super E> filter)` 用于删除集合中满足 filter 指定的条件判断的。\r\n\r\n`public default void forEach(Consumer<? super T> action) `遍历 Collection 集合的每个元素，执行“xxx 消费型”操作。\r\n\r\n案例：\r\n\r\n（1）添加一些字符串到一个 Collection 集合中\r\n\r\n（2）调用 forEach 遍历集合\r\n\r\n（3）调用 removeIf 方法，删除其中字符串的长度<5 的\r\n\r\n（4）再次调用 forEach 遍历集合\r\n\r\n```java\r\npublic class TestLambda {\r\n\tpublic static void main(String[] args) {\r\n\t\tArrayList<String> list = new ArrayList<>();\r\n\t\tlist.add(\"hello\");\r\n\t\tlist.add(\"java\");\r\n\t\tlist.add(\"atguigu\");\r\n\t\tlist.add(\"ok\");\r\n\t\tlist.add(\"yes\");\r\n\t\t\r\n\t\tlist.forEach(str->System.out.println(str));\r\n\t\tSystem.out.println();\r\n\t\t\r\n\t\tlist.removeIf(str->str.length()<5);\r\n\t\tlist.forEach(str->System.out.println(str));\r\n\t}\r\n}\r\n```\r\n\r\n**练习 6：判断型接口**\r\n\r\n案例：\r\n\r\n（1）声明一个 Employee 员工类型，包含编号、姓名、性别，年龄，薪资。\r\n\r\n（2）声明一个 EmployeeSerice 员工管理类，包含一个 `ArrayList<Employee>` 集合的属性 all，在 EmployeeSerice 的构造器中，创建一些员工对象，为 all 集合初始化。\r\n\r\n（3）在 EmployeeSerice 员工管理类中，声明一个方法：`ArrayList<Employee> `get(`Predicate<Employee>` p)，即将满足 p 指定的条件的员工，添加到一个新的 `ArrayList<Employee>` 集合中返回。\r\n\r\n（4）在测试类中创建 EmployeeSerice 员工管理类的对象，并调用 get 方法，分别获取：\r\n\r\n* 所有员工对象\r\n* 所有年龄超过 35 的员工\r\n* 所有薪资高于 15000 的女员工\r\n* 所有编号是偶数的员工\r\n* 名字是“张三”的员工\r\n* 年龄超过 25，薪资低于 10000 的男员工\r\n\r\n示例代码：\r\n\r\nEmployee 类：\r\n\r\n```java\r\npublic class Employee{\r\n\tprivate int id;\r\n\tprivate String name;\r\n\tprivate char gender;\r\n\tprivate int age;\r\n\tprivate double salary;\r\n\t\r\n\tpublic Employee(int id, String name, char gender, int age, double salary) {\r\n\t\tsuper();\r\n\t\tthis.id = id;\r\n\t\tthis.name = name;\r\n\t\tthis.gender = gender;\r\n\t\tthis.age = age;\r\n\t\tthis.salary = salary;\r\n\t}\r\n\tpublic Employee() {\r\n\t\tsuper();\r\n\t}\r\n\tpublic int getId() {\r\n\t\treturn id;\r\n\t}\r\n\tpublic void setId(int id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\tpublic double getSalary() {\r\n\t\treturn salary;\r\n\t}\r\n\tpublic void setSalary(double salary) {\r\n\t\tthis.salary = salary;\r\n\t}\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Employee [id=\" + id + \", name=\" + name + \", gender=\" + gender + \", age=\" + age + \", salary=\" + salary\r\n\t\t\t\t+ \"]\";\r\n\t}\r\n}\r\n```\r\n\r\n员工管理类：\r\n\r\n```java\r\nclass EmployeeService{\r\n\tprivate ArrayList<Employee> all;\r\n\tpublic EmployeeService(){\r\n\t\tall = new ArrayList<Employee>();\r\n\t\tall.add(new Employee(1, \"张三\", '男', 33, 8000));\r\n\t\tall.add(new Employee(2, \"翠花\", '女', 23, 18000));\r\n\t\tall.add(new Employee(3, \"无能\", '男', 46, 8000));\r\n\t\tall.add(new Employee(4, \"李四\", '女', 23, 9000));\r\n\t\tall.add(new Employee(5, \"老王\", '男', 23, 15000));\r\n\t\tall.add(new Employee(6, \"大嘴\", '男', 23, 11000));\r\n\t}\r\n\tpublic ArrayList<Employee> get(Predicate<Employee> p){\r\n\t\tArrayList<Employee> result = new ArrayList<Employee>();\r\n\t\tfor (Employee emp : result) {\r\n\t\t\tif(p.test(emp)){\r\n\t\t\t\tresult.add(emp);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n测试类：\r\n\r\n```java\r\npublic class TestLambda {\r\n\tpublic static void main(String[] args) {\r\n\t\tEmployeeService es = new EmployeeService();\r\n\t\t\r\n\t\tes.get(e -> true).forEach(e->System.out.println(e));\r\n\t\tSystem.out.println();\r\n\t\tes.get(e -> e.getAge()>35).forEach(e->System.out.println(e));\r\n\t\tSystem.out.println();\r\n\t\tes.get(e -> e.getSalary()>15000 && e.getGender()=='女').forEach(e->System.out.println(e));\r\n\t\tSystem.out.println();\r\n\t\tes.get(e -> e.getId()%2==0).forEach(e->System.out.println(e));\r\n\t\tSystem.out.println();\r\n\t\tes.get(e -> \"张三\".equals(e.getName())).forEach(e->System.out.println(e));\r\n\t\tSystem.out.println();\r\n\t\tes.get(e -> e.getAge()>25 && e.getSalary()<10000 && e.getGender()=='男').forEach(e->System.out.println(e));\r\n\t}\r\n}\r\n```\r\n\r\n## Java8 新特性：方法引用与构造器引用\r\n\r\nLambda 表达式是可以简化函数式接口的变量或形参赋值的语法。而方法引用和构造器引用是为了简化 Lambda 表达式的。\r\n\r\n### 方法引用\r\n\r\n当要传递给 Lambda 体的操作，已经有实现的方法了，可以使用方法引用！\r\n\r\n方法引用可以看做是 Lambda 表达式深层次的表达。换句话说，方法引用就是 Lambda 表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是 Lambda 表达式的一个语法糖。\r\n\r\n> 语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法`对语言的功能并没有影响，但是更方便程序员使用`。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。\r\n\r\n#### 方法引用格式\r\n\r\n- 格式：使用方法引用操作符“`::`”将类 (或对象) 与 方法名分隔开来。\r\n  - 两个：中间不能有空格，而且必须英文状态下半角输入\r\n\r\n- 如下三种主要使用情况：\r\n  - 情况 1：`对象 :: 实例方法名`\r\n  - 情况 2：`类 :: 静态方法名`\r\n  - 情况 3：`类 :: 实例方法名`\r\n\r\n#### 方法引用使用前提\r\n\r\n**要求 1：**Lambda 体只有一句语句，并且是通过调用一个对象的/类现有的方法来完成的\r\n\r\n例如：System.out 对象，调用 println() 方法来完成 Lambda 体\r\n\r\n\u200B           Math 类，调用 random() 静态方法来完成 Lambda 体\r\n\r\n**要求 2：**\r\n\r\n针对情况 1：函数式接口中的抽象方法 a 在被重写时使用了某一个对象的方法 b。如果方法 a 的形参列表、返回值类型与方法 b 的形参列表、返回值类型都相同，则我们可以使用方法 b 实现对方法 a 的重写、替换。\r\n\r\n\r\n针对情况 2：函数式接口中的抽象方法 a 在被重写时使用了某一个类的静态方法 b。如果方法 a 的形参列表、返回值类型与方法 b 的形参列表、返回值类型都相同，则我们可以使用方法 b 实现对方法 a 的重写、替换。\r\n\r\n针对情况 3：函数式接口中的抽象方法 a 在被重写时使用了某一个对象的方法 b。如果方法 a 的返回值类型与方法 b 的返回值类型相同，同时方法 a 的形参列表中有 n 个参数，方法 b 的形参列表有 n-1 个参数，且方法 a 的第 1 个参数作为方法 b 的调用者，且方法 a 的后 n-1 参数与方法 b 的 n-1 参数匹配（类型相同或满足多态场景也可以）\r\n\r\n例如：t->System.out.println(t)\r\n\r\n\u200B        () -> Math.random() 都是无参\r\n\r\n#### 举例\r\n\r\n```java\r\npublic class MethodRefTest {\r\n\r\n\t// 情况一：对象 :: 实例方法\r\n\t//Consumer 中的 void accept(T t)\r\n\t//PrintStream 中的 void println(T t)\r\n\t@Test\r\n\tpublic void test1() {\r\n\t\tConsumer<String> con1 = str -> System.out.println(str);\r\n\t\tcon1.accept(\"北京\");\r\n\r\n\t\tSystem.out.println(\"*******************\");\r\n\t\tPrintStream ps = System.out;\r\n\t\tConsumer<String> con2 = ps::println;\r\n\t\tcon2.accept(\"beijing\");\r\n\t}\r\n\t\r\n\t//Supplier 中的 T get()\r\n\t//Employee 中的 String getName()\r\n\t@Test\r\n\tpublic void test2() {\r\n\t\tEmployee emp = new Employee(1001,\"Tom\",23,5600);\r\n\r\n\t\tSupplier<String> sup1 = () -> emp.getName();\r\n\t\tSystem.out.println(sup1.get());\r\n\r\n\t\tSystem.out.println(\"*******************\");\r\n\t\tSupplier<String> sup2 = emp::getName;\r\n\t\tSystem.out.println(sup2.get());\r\n\r\n\t}\r\n\r\n\t// 情况二：类 :: 静态方法\r\n\t//Comparator 中的 int compare(T t1,T t2)\r\n\t//Integer 中的 int compare(T t1,T t2)\r\n\t@Test\r\n\tpublic void test3() {\r\n\t\tComparator<Integer> com1 = (t1,t2) -> Integer.compare(t1,t2);\r\n\t\tSystem.out.println(com1.compare(12,21));\r\n\r\n\t\tSystem.out.println(\"*******************\");\r\n\r\n\t\tComparator<Integer> com2 = Integer::compare;\r\n\t\tSystem.out.println(com2.compare(12,3));\r\n\r\n\t}\r\n\t\r\n\t//Function 中的 R apply(T t)\r\n\t//Math 中的 Long round(Double d)\r\n\t@Test\r\n\tpublic void test4() {\r\n\t\tFunction<Double,Long> func = new Function<Double, Long>() {\r\n\t\t\t@Override\r\n\t\t\tpublic Long apply(Double d) {\r\n\t\t\t\treturn Math.round(d);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tSystem.out.println(\"*******************\");\r\n\r\n\t\tFunction<Double,Long> func1 = d -> Math.round(d);\r\n\t\tSystem.out.println(func1.apply(12.3));\r\n\r\n\t\tSystem.out.println(\"*******************\");\r\n\r\n\t\tFunction<Double,Long> func2 = Math::round;\r\n\t\tSystem.out.println(func2.apply(12.6));\r\n\t}\r\n\r\n\t// 情况三：类 :: 实例方法  (有难度)\r\n\t// Comparator 中的 int comapre(T t1,T t2)\r\n\t// String 中的 int t1.compareTo(t2)\r\n\t@Test\r\n\tpublic void test5() {\r\n\t\tComparator<String> com1 = (s1,s2) -> s1.compareTo(s2);\r\n\t\tSystem.out.println(com1.compare(\"abc\",\"abd\"));\r\n\r\n\t\tSystem.out.println(\"*******************\");\r\n\r\n\t\tComparator<String> com2 = String :: compareTo;\r\n\t\tSystem.out.println(com2.compare(\"abd\",\"abm\"));\r\n\t}\r\n\r\n\t//BiPredicate 中的 boolean test(T t1, T t2);\r\n\t//String 中的 boolean t1.equals(t2)\r\n\t@Test\r\n\tpublic void test6() {\r\n\t\tBiPredicate<String,String> pre1 = (s1,s2) -> s1.equals(s2);\r\n\t\tSystem.out.println(pre1.test(\"abc\",\"abc\"));\r\n\r\n\t\tSystem.out.println(\"*******************\");\r\n\t\tBiPredicate<String,String> pre2 = String :: equals;\r\n\t\tSystem.out.println(pre2.test(\"abc\",\"abd\"));\r\n\t}\r\n\t\r\n\t// Function 中的 R apply(T t)\r\n\t// Employee 中的 String getName();\r\n\t@Test\r\n\tpublic void test7() {\r\n\t\tEmployee employee = new Employee(1001, \"Jerry\", 23, 6000);\r\n\r\n\r\n\t\tFunction<Employee,String> func1 = e -> e.getName();\r\n\t\tSystem.out.println(func1.apply(employee));\r\n\r\n\t\tSystem.out.println(\"*******************\");\r\n\t\tFunction<Employee,String> func2 = Employee::getName;\r\n\t\tSystem.out.println(func2.apply(employee));\r\n\t}\r\n\r\n}\r\n```\r\n\r\n### 构造器引用\r\n\r\n当 Lambda 表达式是创建一个对象，并且满足 Lambda 表达式形参，正好是给创建这个对象的构造器的实参列表，就可以使用构造器引用。\r\n\r\n格式：`类名::new`\r\n\r\n举例：\r\n\r\n```java\r\npublic class ConstructorRefTest {\r\n\t//构造器引用\r\n    //Supplier 中的 T get()\r\n    //Employee 的空参构造器：Employee()\r\n    @Test\r\n    public void test1(){\r\n\r\n        Supplier<Employee> sup = new Supplier<Employee>() {\r\n            @Override\r\n            public Employee get() {\r\n                return new Employee();\r\n            }\r\n        };\r\n        System.out.println(\"*******************\");\r\n\r\n        Supplier<Employee>  sup1 = () -> new Employee();\r\n        System.out.println(sup1.get());\r\n\r\n        System.out.println(\"*******************\");\r\n\r\n        Supplier<Employee>  sup2 = Employee :: new;\r\n        System.out.println(sup2.get());\r\n    }\r\n\r\n\t//Function 中的 R apply(T t)\r\n    @Test\r\n    public void test2(){\r\n        Function<Integer,Employee> func1 = id -> new Employee(id);\r\n        Employee employee = func1.apply(1001);\r\n        System.out.println(employee);\r\n\r\n        System.out.println(\"*******************\");\r\n\r\n        Function<Integer,Employee> func2 = Employee :: new;\r\n        Employee employee1 = func2.apply(1002);\r\n        System.out.println(employee1);\r\n\r\n    }\r\n\r\n\t//BiFunction 中的 R apply(T t,U u)\r\n    @Test\r\n    public void test3(){\r\n        BiFunction<Integer,String,Employee> func1 = (id,name) -> new Employee(id,name);\r\n        System.out.println(func1.apply(1001,\"Tom\"));\r\n\r\n        System.out.println(\"*******************\");\r\n\r\n        BiFunction<Integer,String,Employee> func2 = Employee :: new;\r\n        System.out.println(func2.apply(1002,\"Tom\"));\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n```java\r\n/**\r\n * @author 尚硅谷 - 宋红康 邮箱：shkstart@126.com\r\n */\r\npublic class Employee {\r\n\r\n\tprivate int id;\r\n\tprivate String name;\r\n\tprivate int age;\r\n\tprivate double salary;\r\n\r\n\tpublic int getId() {\r\n\t\treturn id;\r\n\t}\r\n\r\n\tpublic void setId(int id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic int getAge() {\r\n\t\treturn age;\r\n\t}\r\n\r\n\tpublic void setAge(int age) {\r\n\t\tthis.age = age;\r\n\t}\r\n\r\n\tpublic double getSalary() {\r\n\t\treturn salary;\r\n\t}\r\n\r\n\tpublic void setSalary(double salary) {\r\n\t\tthis.salary = salary;\r\n\t}\r\n\r\n\tpublic Employee() {\r\n\t\tSystem.out.println(\"Employee().....\");\r\n\t}\r\n\r\n\tpublic Employee(int id) {\r\n\t\tthis.id = id;\r\n\t\tSystem.out.println(\"Employee(int id).....\");\r\n\t}\r\n\r\n\tpublic Employee(int id, String name) {\r\n\t\tthis.id = id;\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic Employee(int id, String name, int age, double salary) {\r\n\r\n\t\tthis.id = id;\r\n\t\tthis.name = name;\r\n\t\tthis.age = age;\r\n\t\tthis.salary = salary;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Employee{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + \", salary=\" + salary + '}';\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n### 数组构造引用\r\n\r\n当 Lambda 表达式是创建一个数组对象，并且满足 Lambda 表达式形参，正好是给创建这个数组对象的长度，就可以数组构造引用。\r\n\r\n格式：`数组类型名::new`\r\n\r\n举例：\r\n\r\n```java\r\n//数组引用\r\n//Function 中的 R apply(T t)\r\n@Test\r\npublic void test4(){\r\n    Function<Integer,String[]> func1 = length -> new String[length];\r\n    String[] arr1 = func1.apply(5);\r\n    System.out.println(Arrays.toString(arr1));\r\n\r\n    System.out.println(\"*******************\");\r\n\r\n    Function<Integer,String[]> func2 = String[] :: new;\r\n    String[] arr2 = func2.apply(10);\r\n    System.out.println(Arrays.toString(arr2));\r\n\r\n}\r\n```\r\n\r\n## Java8 新特性：强大的 Stream API\r\n\r\n### 说明\r\n\r\n- Java8 中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。\r\n- Stream API ( java.util.stream) 把真正的函数式编程风格引入到 Java 中。这是目前为止对 Java 类库`最好的补充`，因为 Stream API 可以极大提供 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。\r\n- Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 **使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。**也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。\r\n\r\n### 为什么要使用 Stream API\r\n\r\n实际开发中，项目中多数数据源都来自于 MySQL、Oracle 等。但现在数据源可以更多了，有 MongDB，Radis 等，而这些 NoSQL 的数据就需要 Java 层面去处理。\r\n\r\n### 什么是 Stream\r\n\r\nStream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。\r\n\r\nStream 和 Collection 集合的区别：**Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。**前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。\r\n\r\n注意：\r\n\r\n①Stream 自己不会存储元素。\r\n\r\n②Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream。\r\n\r\n③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。\r\n\r\n④ Stream 一旦执行了终止操作，就不能再调用其它中间操作或终止操作了。\r\n\r\n### Stream 的操作三个步骤\r\n\r\n**1- 创建 Stream**\r\n一个数据源（如：集合、数组），获取一个流\r\n\r\n**2- 中间操作**\r\n每次处理都会返回一个持有结果的新 Stream，即中间操作的方法返回值仍然是 Stream 类型的对象。因此中间操作可以是个`操作链`，可对数据源的数据进行 n 次处理，但是在终结操作前，并不会真正执行。\r\n\r\n**3- 终止操作 (终端操作)**\r\n终止操作的方法返回值类型就不再是 Stream 了，因此一旦执行终止操作，就结束整个 Stream 操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束 Stream。\r\n\r\n![image-20230417134259037](./assets/image-20230417134259037.png)\r\n\r\n#### 创建 Stream 实例\r\n\r\n**方式一：通过集合**\r\n\r\nJava8 中的 Collection 接口被扩展，提供了两个获取流的方法：\r\n\r\n- `default Stream<E> stream()` : 返回一个顺序流\r\n\r\n- `default Stream<E> parallelStream() `: 返回一个并行流\r\n\r\n```java\r\n@Test\r\npublic void test01(){\r\n    List<Integer> list = Arrays.asList(1,2,3,4,5);\r\n\r\n    //JDK1.8 中，Collection 系列集合增加了方法\r\n    Stream<Integer> stream = list.stream、();\r\n}\r\n```\r\n\r\n**方式二：通过数组**\r\n\r\nJava8 中的 Arrays 的静态方法 stream() 可以获取数组流：\r\n\r\n- `static <T> Stream<T> stream(T[] array)`: 返回一个流\r\n- `public static IntStream stream(int[] array)`\r\n- `public static LongStream stream(long[] array)`\r\n- `public static DoubleStream stream(double[] array)`\r\n\r\n```java\r\n@Test\r\npublic void test02(){\r\n    String[] arr = {\"hello\",\"world\"};\r\n    Stream<String> stream = Arrays.stream(arr); \r\n}\r\n\r\n@Test\r\npublic void test03(){\r\n    int[] arr = {1,2,3,4,5};\r\n    IntStream stream = Arrays.stream(arr);\r\n}\r\n```\r\n\r\n**方式三：通过 Stream 的 of()**\r\n\r\n可以调用 Stream 类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。\r\n\r\n- `public static<T> Stream<T> of(T... values)` : 返回一个流\r\n\r\n```java\r\n@Test\r\npublic void test04(){\r\n    Stream<Integer> stream = Stream.of(1,2,3,4,5);\r\n    stream.forEach(System.out::println);\r\n}\r\n```\r\n\r\n**方式四：创建无限流 (了解)**\r\n\r\n可以使用静态方法 `Stream.iterate() 和 Stream.generate()`, 创建无限流。\r\n\r\n- 迭代\r\n  `public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) `\r\n\r\n- 生成\r\n  `public static<T> Stream<T> generate(Supplier<T> s) `\r\n\r\n```java\r\n// 方式四：创建无限流\r\n@Test\r\npublic void test05() {\r\n\t// 迭代\r\n\t// public static<T> Stream<T> iterate(final T seed, final\r\n\t// UnaryOperator<T> f)\r\n\tStream<Integer> stream = Stream.iterate(0, x -> x + 2);\r\n\tstream.limit(10).forEach(System.out::println);\r\n\r\n\t// 生成\r\n\t// public static<T> Stream<T> generate(Supplier<T> s)\r\n\tStream<Double> stream1 = Stream.generate(Math::random);\r\n\tstream1.limit(10).forEach(System.out::println);\r\n}\r\n```\r\n\r\n#### 一系列中间操作\r\n\r\n多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。\r\n\r\n1-筛选与切片\r\n\r\n| **方   法**             | **描   述**                                                                                         |\r\n| ----------------------- | --------------------------------------------------------------------------------------------------- |\r\n| **filter(Predicatep)**  | 接收  Lambda，从流中排除某些元素                                                                    |\r\n| **distinct()**          | 筛选，通过流所生成元素的  hashCode() 和 equals() 去除重复元素                                       |\r\n| **limit(long maxSize)** | 截断流，使其元素不超过给定数量                                                                      |\r\n| **skip(long n)**        | 跳过元素，返回一个扔掉了前  n 个元素的流。<br>若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 |\r\n\r\n2-映 射\r\n\r\n| **方法**                            | **描述**                                                                      |\r\n| ----------------------------------- | ----------------------------------------------------------------------------- |\r\n| **map(Function f)**                 | 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。  |\r\n| **mapToDouble(ToDoubleFunction f)** | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。 |\r\n| **mapToInt(ToIntFunction  f)**      | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  IntStream。   |\r\n| **mapToLong(ToLongFunction  f)**    | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  LongStream。  |\r\n| **flatMap(Function  f)**            | 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流  |\r\n\r\n3-排序\r\n\r\n| **方法**                       | **描述**                           |\r\n| ------------------------------ | ---------------------------------- |\r\n| **sorted()**                   | 产生一个新流，其中按自然顺序排序   |\r\n| **sorted(Comparator** **com)** | 产生一个新流，其中按比较器顺序排序 |\r\n\r\n代码举例：\r\n\r\n```java\r\npublic class StreamMiddleOperate {\r\n\t@Test\r\n    public void test01(){\r\n        //1、创建 Stream\r\n        Stream<Integer> stream = Stream.of(1,2,3,4,5,6);\r\n\r\n        //2、加工处理\r\n        //过滤：filter(Predicate p)\r\n        //把里面的偶数拿出来\r\n        /*\r\n         * filter(Predicate p)\r\n         * Predicate 是函数式接口，抽象方法：boolean test(T t)\r\n         */\r\n        stream = stream.filter(t -> t%2==0);\r\n\r\n        //3、终结操作：例如：遍历\r\n        stream.forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test02(){\r\n        Stream.of(1,2,3,4,5,6)\r\n                .filter(t -> t%2==0)\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test03(){\r\n        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)\r\n                .distinct()\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test04(){\r\n        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)\r\n                .limit(3)\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test05(){\r\n        Stream.of(1,2,2,3,3,4,4,5,2,3,4,5,6,7)\r\n                .distinct()  //(1,2,3,4,5,6,7)\r\n                .filter(t -> t%2!=0) //(1,3,5,7)\r\n                .limit(3)\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test06(){\r\n        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)\r\n                .skip(5)\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test07(){\r\n        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)\r\n                .skip(5)\r\n                .distinct()\r\n                .filter(t -> t%3==0)\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test08(){\r\n        long count = Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)\r\n                .distinct()\r\n                .peek(System.out::println)  //Consumer 接口的抽象方法  void accept(T t)\r\n                .count();\r\n        System.out.println(\"count=\"+count);\r\n    }\r\n    @Test\r\n    public void test09(){\r\n        //希望能够找出前三个最大值，前三名最大的，不重复\r\n        Stream.of(11,2,39,4,54,6,2,22,3,3,4,54,54)\r\n                .distinct()\r\n                .sorted((t1,t2) -> -Integer.compare(t1, t2))//Comparator 接口  int compare(T t1, T t2)\r\n                .limit(3)\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test10(){\r\n        Stream.of(1,2,3,4,5)\r\n                .map(t -> t+=1)//Function<T,R>接口抽象方法 R apply(T t)\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test11(){\r\n        String[] arr = {\"hello\",\"world\",\"java\"};\r\n\r\n        Arrays.stream(arr)\r\n                .map(t->t.toUpperCase())\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test12(){\r\n        String[] arr = {\"hello\",\"world\",\"java\"};\r\n        Arrays.stream(arr)\r\n                .flatMap(t -> Stream.of(t.split(\"|\")))//Function<T,R>接口抽象方法 R apply(T t)  现在的 R 是一个 Stream\r\n                .forEach(System.out::println);\r\n    } \r\n}\r\n\r\n```\r\n\r\n#### 终止操作\r\n\r\n- 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。\r\n\r\n- 流进行了终止操作后，不能再次使用。\r\n\r\n1-匹配与查找\r\n\r\n| **方法**                        | **描述**                                                                                                              |\r\n| ------------------------------- | --------------------------------------------------------------------------------------------------------------------- |\r\n| **allMatch(Predicate  p)**      | 检查是否匹配所有元素                                                                                                  |\r\n| **anyMatch(Predicate  p)  **    | 检查是否至少匹配一个元素                                                                                              |\r\n| **noneMatch(Predicate**  **p)** | 检查是否没有匹配所有元素                                                                                              |\r\n| **findFirst()**                 | 返回第一个元素                                                                                                        |\r\n| **findAny()**                   | 返回当前流中的任意元素                                                                                                |\r\n| **count()**                     | 返回流中元素总数                                                                                                      |\r\n| **max(Comparator c)**           | 返回流中最大值                                                                                                        |\r\n| **min(Comparator c)**           | 返回流中最小值                                                                                                        |\r\n| **forEach(Consumer c)**         | 内部迭代 (使用  Collection  接口需要用户去做迭代，称为外部迭代。<br>相反，Stream  API 使用内部迭代——它帮你把迭代做了) |\r\n\r\n2-归约\r\n\r\n| **方法**                                  | **描述**                                                   |\r\n| ----------------------------------------- | ---------------------------------------------------------- |\r\n| **reduce(T  identity, BinaryOperator b)** | `可以将流中元素反复结合起来，得到一个值。返回 T`           |\r\n| **reduce(BinaryOperator  b)**             | `可以将流中元素反复结合起来，得到一个值。返回 Optional<T>` |\r\n\r\n备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。\r\n\r\n3-收集\r\n\r\n| **方   法**               | **描   述**                                                                              |\r\n| ------------------------- | ---------------------------------------------------------------------------------------- |\r\n| **collect(Collector  c)** | 将流转换为其他形式。接收一个  Collector 接口的实现，<br>用于给 Stream 中元素做汇总的方法 |\r\n\r\nCollector 接口中方法的实现决定了如何对流执行收集的操作 (如收集到 List、Set、Map)。\r\n\r\n另外，Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：\r\n\r\n| **方法**   | **返回类型**               | **作用**              |\r\n| ---------- | -------------------------- | --------------------- |\r\n| **toList** | `Collector<T, ?, List<T>>` | 把流中元素收集到 List |\r\n\r\n```java\r\nList<Employee> emps= list.stream().collect(Collectors.toList());\r\n```\r\n\r\n| **方法**  | **返回类型**              | **作用**             |\r\n| --------- | ------------------------- | -------------------- |\r\n| **toSet** | `Collector<T, ?, Set<T>>` | 把流中元素收集到 Set |\r\n\r\n```java\r\nSet<Employee> emps= list.stream().collect(Collectors.toSet());\r\n```\r\n\r\n| **方法**         | **返回类型**         | **作用**                   |\r\n| ---------------- | -------------------- | -------------------------- |\r\n| **toCollection** | `Collector<T, ?, C>` | 把流中元素收集到创建的集合 |\r\n\r\n```java\r\nCollection<Employee> emps =list.stream().collect(Collectors.toCollection(ArrayList::new));\r\n```\r\n\r\n| **方法**     | **返回类型**            | **作用**           |\r\n| ------------ | ----------------------- | ------------------ |\r\n| **counting** | `Collector<T, ?, Long>` | 计算流中元素的个数 |\r\n\r\n```java\r\nlong count = list.stream().collect(Collectors.counting());\r\n```\r\n\r\n| **方法**       | **返回类型**               | **作用**                 |\r\n| -------------- | -------------------------- | ------------------------ |\r\n| **summingInt** | `Collector<T, ?, Integer>` | 对流中元素的整数属性求和 |\r\n\r\n```java\r\nint total=list.stream().collect(Collectors.summingInt(Employee::getSalary));\r\n```\r\n\r\n| **方法**         | **返回类型**              | **作用**                          |\r\n| ---------------- | ------------------------- | --------------------------------- |\r\n| **averagingInt** | `Collector<T, ?, Double>` | 计算流中元素 Integer 属性的平均值 |\r\n\r\n```java\r\ndouble avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));\r\n```\r\n\r\n| **方法**           | **返回类型**                            | **作用**                                  |\r\n| ------------------ | --------------------------------------- | ----------------------------------------- |\r\n| **summarizingInt** | `Collector<T, ?, IntSummaryStatistics>` | 收集流中 Integer 属性的统计值。如：平均值 |\r\n\r\n```java\r\nint SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));\r\n```\r\n\r\n| **方法**    | **返回类型**                         | **作用**           |\r\n| ----------- | ------------------------------------ | ------------------ |\r\n| **joining** | `Collector<CharSequence, ?, String>` | 连接流中每个字符串 |\r\n\r\n```java\r\nString str= list.stream().map(Employee::getName).collect(Collectors.joining());\r\n```\r\n\r\n| **方法**  | **返回类型**                   | **作用**             |\r\n| --------- | ------------------------------ | -------------------- |\r\n| **maxBy** | `Collector<T, ?, Optional<T>>` | 根据比较器选择最大值 |\r\n\r\n```java\r\nOptional<Emp>max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));\r\n```\r\n\r\n| **方法**  | **返回类型**                   | **作用**             |\r\n| --------- | ------------------------------ | -------------------- |\r\n| **minBy** | `Collector<T, ?, Optional<T>>` | 根据比较器选择最小值 |\r\n\r\n```java\r\nOptional<Emp> min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));\r\n```\r\n\r\n| **方法**     | **返回类型**                   | **作用**                                                                               |\r\n| ------------ | ------------------------------ | -------------------------------------------------------------------------------------- |\r\n| **reducing** | `Collector<T, ?, Optional<T>>` | 从一个作为累加器的初始值开始，利用 BinaryOperator 与流中元素逐个结合，从而归约成单个值 |\r\n\r\n```java\r\nint total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));\r\n```\r\n\r\n| **方法**              | **返回类型**        | **作用**                           |\r\n| --------------------- | ------------------- | ---------------------------------- |\r\n| **collectingAndThen** | `Collector<T,A,RR>` | 包裹另一个收集器，对其结果转换函数 |\r\n\r\n```java\r\nint how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));\r\n```\r\n\r\n| **方法**       | **返回类型**                       | **作用**                                 |\r\n| -------------- | ---------------------------------- | ---------------------------------------- |\r\n| **groupingBy** | `Collector<T, ?, Map<K, List<T>>>` | 根据某属性值对流分组，属性为 K，结果为 V |\r\n\r\n```java\r\nMap<Emp.Status, List<Emp>> map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));\r\n```\r\n\r\n| **方法**           | **返回类型**                             | **作用**                    |\r\n| ------------------ | ---------------------------------------- | --------------------------- |\r\n| **partitioningBy** | `Collector<T, ?, Map<Boolean, List<T>>>` | 根据 true 或 false 进行分区 |\r\n\r\n```java\r\nMap<Boolean,List<Emp>> vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));\r\n```\r\n\r\n举例：\r\n\r\n```java\r\npublic class StreamEndding {\r\n    @Test\r\n    public void test01(){\r\n        Stream.of(1,2,3,4,5)\r\n                .forEach(System.out::println);\r\n    }\r\n    @Test\r\n    public void test02(){\r\n        long count = Stream.of(1,2,3,4,5)\r\n                .count();\r\n        System.out.println(\"count = \" + count);\r\n    }\r\n    @Test\r\n    public void test03(){\r\n        boolean result = Stream.of(1,3,5,7,9)\r\n                .allMatch(t -> t%2!=0);\r\n        System.out.println(result);\r\n    }\r\n\t@Test\r\n    public void test04(){\r\n        boolean result = Stream.of(1,3,5,7,9)\r\n                .anyMatch(t -> t%2==0);\r\n        System.out.println(result);\r\n    }\r\n\t@Test\r\n    public void test05(){\r\n        Optional<Integer> opt = Stream.of(1,3,5,7,9).findFirst();\r\n        System.out.println(opt);\r\n    }\r\n\t@Test\r\n    public void test06(){\r\n        Optional<Integer> opt = Stream.of(1,2,3,4,5,7,9)\r\n                .filter(t -> t%3==0)\r\n                .findFirst();\r\n        System.out.println(opt);\r\n    }\r\n\t@Test\r\n    public void test07(){\r\n        Optional<Integer> opt = Stream.of(1,2,4,5,7,8)\r\n                .filter(t -> t%3==0)\r\n                .findFirst();\r\n        System.out.println(opt);\r\n    }\r\n    @Test\r\n    public void test08(){\r\n        Optional<Integer> max = Stream.of(1,2,4,5,7,8)\r\n                .max((t1,t2) -> Integer.compare(t1, t2));\r\n        System.out.println(max);\r\n    }\r\n    @Test\r\n    public void test09(){\r\n        Integer reduce = Stream.of(1,2,4,5,7,8)\r\n                .reduce(0, (t1,t2) -> t1+t2);//BinaryOperator 接口   T apply(T t1, T t2)\r\n        System.out.println(reduce);\r\n    }\r\n    @Test\r\n    public void test10(){\r\n        Optional<Integer> max = Stream.of(1,2,4,5,7,8)\r\n                .reduce((t1,t2) -> t1>t2?t1:t2);//BinaryOperator 接口   T apply(T t1, T t2)\r\n        System.out.println(max);\r\n    }\r\n    @Test\r\n    public void test11(){\r\n        List<Integer> list = Stream.of(1,2,4,5,7,8)\r\n                .filter(t -> t%2==0)\r\n                .collect(Collectors.toList());\r\n\r\n        System.out.println(list);\r\n    }   \r\n}\r\n```\r\n\r\n### Java9 新增 API\r\n\r\n**新增 1：Stream 实例化方法**\r\n\r\nofNullable() 的使用：\r\n\r\nJava 8 中 Stream 不能完全为 null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。\r\n\r\n```java\r\n//报 NullPointerException\r\n//Stream<Object> stream1 = Stream.of(null);\r\n//System.out.println(stream1.count());\r\n\r\n//不报异常，允许通过\r\nStream<String> stringStream = Stream.of(\"AA\", \"BB\", null);\r\nSystem.out.println(stringStream.count());//3\r\n\r\n//不报异常，允许通过\r\nList<String> list = new ArrayList<>();\r\nlist.add(\"AA\");\r\nlist.add(null);\r\nSystem.out.println(list.stream().count());//2\r\n//ofNullable()：允许值为 null\r\nStream<Object> stream1 = Stream.ofNullable(null);\r\nSystem.out.println(stream1.count());//0\r\n\r\nStream<String> stream = Stream.ofNullable(\"hello world\");\r\nSystem.out.println(stream.count());//1\r\n\r\n```\r\n\r\niterator() 重载的使用：\r\n\r\n```java\r\n//原来的控制终止方式：\r\nStream.iterate(1,i -> i + 1).limit(10).forEach(System.out::println);\r\n\r\n//现在的终止方式：\r\nStream.iterate(1,i -> i < 100,i -> i + 1).forEach(System.out::println);\r\n\r\n```\r\n\r\n### 练习\r\n\r\n现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的 for 循环（或增强 for 循环）依次进行以\r\n下若干操作步骤：\r\n\r\n1. 第一个队伍只要名字为 3 个字的成员姓名；存储到一个新集合中。\r\n2. 第一个队伍筛选之后只要前 3 个人；存储到一个新集合中。\r\n3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。\r\n4. 第二个队伍筛选之后不要前 2 个人；存储到一个新集合中。\r\n5. 将两个队伍合并为一个队伍；存储到一个新集合中。\r\n6. 根据姓名创建 Person 对象；存储到一个新集合中。\r\n7. 打印整个队伍的 Person 对象信息。\r\n\r\nPerson 类的代码为：\r\n\r\n```java\r\npublic class Person {\r\n    private String name;\r\n    public Person() {}\r\n    public Person(String name) {\r\n        this.name = name;\r\n    }    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Person{name='\" + name + \"'}\";\r\n    }\r\n}\r\n```\r\n\r\n两个队伍（集合）的代码如下：\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n   //第一支队伍\r\n    ArrayList<String> one = new ArrayList<>();\r\n    one.add(\"迪丽热巴\");\r\n    one.add(\"宋远桥\");\r\n    one.add(\"苏星河\");\r\n    one.add(\"石破天\");\r\n    one.add(\"石中玉\");\r\n    one.add(\"老子\");\r\n    one.add(\"庄子\");\r\n    one.add(\"洪七公\");\r\n    //第二支队伍\r\n    ArrayList<String> two = new ArrayList<>();\r\n    two.add(\"古力娜扎\");\r\n    two.add(\"张无忌\");\r\n    two.add(\"赵丽颖\");\r\n    two.add(\"张三丰\");\r\n    two.add(\"尼古拉斯赵四\");\r\n    two.add(\"张天爱\");\r\n    two.add(\"张二狗\");\r\n\r\n    // ....编写代码完成题目要求 \r\n}\r\n```\r\n\r\n参考答案：\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n   //第一支队伍\r\n    ArrayList<String> one = new ArrayList<>();\r\n    one.add(\"迪丽热巴\");\r\n    one.add(\"宋远桥\");\r\n    one.add(\"苏星河\");\r\n    one.add(\"石破天\");\r\n    one.add(\"石中玉\");\r\n    one.add(\"老子\");\r\n    one.add(\"庄子\");\r\n    one.add(\"洪七公\");\r\n\r\n    //第二支队伍\r\n    ArrayList<String> two = new ArrayList<>();\r\n    two.add(\"古力娜扎\");\r\n    two.add(\"张无忌\");\r\n    two.add(\"赵丽颖\");\r\n    two.add(\"张三丰\");\r\n    two.add(\"尼古拉斯赵四\");\r\n    two.add(\"张天爱\");\r\n    two.add(\"张二狗\");\r\n\r\n    // 第一个队伍只要名字为 3 个字的成员姓名；\r\n    // 第一个队伍筛选之后只要前 3 个人；\r\n    Stream<String> streamOne = one.stream().filter(s ‐> s.length() == 3).limit(3);\r\n\r\n    // 第二个队伍只要姓张的成员姓名；\r\n    // 第二个队伍筛选之后不要前 2 个人；\r\n    Stream<String> streamTwo = two.stream().filter(s ‐> s.startsWith(\"张\")).skip(2);\r\n\r\n    // 将两个队伍合并为一个队伍；\r\n    // 根据姓名创建 Person 对象；\r\n    // 打印整个队伍的 Person 对象信息。\r\n    Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println);\r\n\r\n}\r\n```\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java/JDK/02.JDK8-17 新特性上.md b/src/java/JDK/02.JDK8-17 新特性上.md
--- a/src/java/JDK/02.JDK8-17 新特性上.md	(revision 87bc1a332c52374b9f97c41255665a6cd9c2d3d4)
+++ b/src/java/JDK/02.JDK8-17 新特性上.md	(date 1682519463965)
@@ -1,12 +1,5 @@
 ---
-title: JDK8-17 新特性上
-date: 2023-04-17 13:28:04
-permalink: /pages/fdec07/
-categories:
-  - Java
-  - JDK
-tags:
-  - 
+
 ---
 # JDK8-17 新特性上
 
